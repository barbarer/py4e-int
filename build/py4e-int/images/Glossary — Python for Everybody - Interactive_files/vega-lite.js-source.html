<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title><title><no title></title></title>
  <meta http-equiv="content-type" content="text/html; charset=None">
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css">
</head>
<body>
<h2><title><no title></title></h2>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">global</span><span class="p">,</span> <span class="nx">factory</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">typeof</span> <span class="nx">exports</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">module</span> <span class="o">!==</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">?</span> <span class="nx">factory</span><span class="p">(</span><span class="nx">exports</span><span class="p">)</span> <span class="o">:</span>
  <span class="k">typeof</span> <span class="nx">define</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">define</span><span class="p">.</span><span class="nx">amd</span> <span class="o">?</span> <span class="nx">define</span><span class="p">([</span><span class="s1">&#39;exports&#39;</span><span class="p">],</span> <span class="nx">factory</span><span class="p">)</span> <span class="o">:</span>
  <span class="p">(</span><span class="nx">factory</span><span class="p">((</span><span class="nx">global</span><span class="p">.</span><span class="nx">vl</span> <span class="o">=</span> <span class="p">{})));</span>
<span class="p">}(</span><span class="k">this</span><span class="p">,</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">exports</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">accessor</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">fields</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">fields</span> <span class="o">=</span> <span class="nx">fields</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">fname</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">fn</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">error</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">q</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span>
        <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">n</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">c</span><span class="p">;</span>

    <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">push</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">));</span>
      <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;</span><span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">c</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="s1">&#39;\\&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">+=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="o">++</span><span class="nx">j</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">push</span><span class="p">();</span>
        <span class="nx">q</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="nx">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">===</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">q</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">===</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">q</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="s1">&#39;.&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">push</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="s1">&#39;[&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">i</span><span class="p">)</span> <span class="nx">push</span><span class="p">();</span>
        <span class="nx">b</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">b</span><span class="p">)</span> <span class="nx">error</span><span class="p">(</span><span class="s1">&#39;Access path missing open bracket: &#39;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">push</span><span class="p">();</span>
        <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="nx">error</span><span class="p">(</span><span class="s1">&#39;Access path missing closing bracket: &#39;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="nx">error</span><span class="p">(</span><span class="s1">&#39;Access path missing closing quote: &#39;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">j</span><span class="o">++</span><span class="p">;</span>
      <span class="nx">push</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">path</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">isArray</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">_</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">(</span><span class="nx">_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">_</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">$</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nx">x</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">$</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
      <span class="o">:</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">?</span>
        <span class="c1">// Output valid JSON and JS source strings.</span>
        <span class="c1">// See http://timelessrepo.com/json-isnt-a-javascript-subset</span>
        <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">x</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;\u2028&#39;</span><span class="p">,</span><span class="s1">&#39;\\u2028&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;\u2029&#39;</span><span class="p">,</span> <span class="s1">&#39;\\u2029&#39;</span><span class="p">)</span>
      <span class="o">:</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">field</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">field</span><span class="p">),</span>
        <span class="nx">code</span> <span class="o">=</span> <span class="s1">&#39;return _[&#39;</span> <span class="o">+</span> <span class="nx">path</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">$</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;][&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;];&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">accessor</span><span class="p">(</span>
      <span class="nb">Function</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="nx">code</span><span class="p">),</span>
      <span class="p">[(</span><span class="nx">field</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">length</span><span class="o">===</span><span class="mi">1</span> <span class="o">?</span> <span class="nx">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="nx">field</span><span class="p">)],</span>
      <span class="nx">name</span> <span class="o">||</span> <span class="nx">field</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">empty</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">field</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">identity</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">_</span><span class="p">;</span> <span class="p">},</span> <span class="nx">empty</span><span class="p">,</span> <span class="s1">&#39;identity&#39;</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">zero</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">},</span> <span class="nx">empty</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">one</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">},</span> <span class="nx">empty</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">truthy</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">},</span> <span class="nx">empty</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">falsy</span> <span class="o">=</span> <span class="nx">accessor</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">},</span> <span class="nx">empty</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="nx">level</span><span class="p">].</span><span class="nx">concat</span><span class="p">([].</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">input</span><span class="p">));</span>
    <span class="nx">console</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="nx">console</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span> <span class="c1">// eslint-disable-line no-console</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">None</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nb">Error</span><span class="nx">$1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">Warn</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">Info</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">Debug</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">logger</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">level</span> <span class="o">=</span> <span class="nx">_</span> <span class="o">||</span> <span class="nx">None</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">level</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">level</span> <span class="o">=</span> <span class="o">+</span><span class="nx">_</span><span class="p">;</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">level</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="nx">error</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">level</span> <span class="o">&gt;=</span> <span class="nb">Error</span><span class="nx">$1</span><span class="p">)</span> <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">warn</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">level</span> <span class="o">&gt;=</span> <span class="nx">Warn</span><span class="p">)</span> <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="s1">&#39;WARN&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">info</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">level</span> <span class="o">&gt;=</span> <span class="nx">Info</span><span class="p">)</span> <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">debug</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">level</span> <span class="o">&gt;=</span> <span class="nx">Debug</span><span class="p">)</span> <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;DEBUG&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isBoolean</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">_</span> <span class="o">===</span> <span class="s1">&#39;boolean&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">_</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">s</span><span class="o">=</span><span class="p">{},</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="o">=</span><span class="nx">_</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="nx">s</span><span class="p">[</span><span class="nx">_</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/*! *****************************************************************************</span>
<span class="cm">  Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="cm">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use</span>
<span class="cm">  this file except in compliance with the License. You may obtain a copy of the</span>
<span class="cm">  License at http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="cm">  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="cm">  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED</span>
<span class="cm">  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,</span>
<span class="cm">  MERCHANTABLITY OR NON-INFRINGEMENT.</span>

<span class="cm">  See the Apache Version 2.0 License for specific language governing permissions</span>
<span class="cm">  and limitations under the License.</span>
<span class="cm">  ***************************************************************************** */</span>
  <span class="cm">/* global Reflect, Promise */</span>

  <span class="kd">var</span> <span class="nx">extendStatics</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span> <span class="o">||</span>
      <span class="p">({</span> <span class="nx">__proto__</span><span class="o">:</span> <span class="p">[]</span> <span class="p">}</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="o">&amp;&amp;</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="nx">d</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span> <span class="p">})</span> <span class="o">||</span>
      <span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">p</span> <span class="k">in</span> <span class="nx">b</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="nx">d</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span> <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">__extends</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">extendStatics</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">__</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">d</span><span class="p">;</span> <span class="p">}</span>
      <span class="nx">d</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">?</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="nx">__</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="k">new</span> <span class="nx">__</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">__assign</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span> <span class="o">||</span> <span class="kd">function</span> <span class="nx">__assign</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">s</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">p</span> <span class="k">in</span> <span class="nx">s</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">p</span><span class="p">))</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">p</span> <span class="k">in</span> <span class="nx">s</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span> <span class="o">===</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">at</span><span class="p">,</span> <span class="c1">// The index of the current character</span>
      <span class="nx">ch</span><span class="p">,</span> <span class="c1">// The current character</span>
      <span class="nx">escapee</span> <span class="o">=</span> <span class="p">{</span>
          <span class="s1">&#39;&quot;&#39;</span><span class="o">:</span>  <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
          <span class="s1">&#39;\\&#39;</span><span class="o">:</span> <span class="s1">&#39;\\&#39;</span><span class="p">,</span>
          <span class="s1">&#39;/&#39;</span><span class="o">:</span>  <span class="s1">&#39;/&#39;</span><span class="p">,</span>
          <span class="nx">b</span><span class="o">:</span>    <span class="s1">&#39;\b&#39;</span><span class="p">,</span>
          <span class="nx">f</span><span class="o">:</span>    <span class="s1">&#39;\f&#39;</span><span class="p">,</span>
          <span class="nx">n</span><span class="o">:</span>    <span class="s1">&#39;\n&#39;</span><span class="p">,</span>
          <span class="nx">r</span><span class="o">:</span>    <span class="s1">&#39;\r&#39;</span><span class="p">,</span>
          <span class="nx">t</span><span class="o">:</span>    <span class="s1">&#39;\t&#39;</span>
      <span class="p">},</span>
      <span class="nx">text</span><span class="p">,</span>

      <span class="nx">error$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Call error when something is wrong.</span>
          <span class="k">throw</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span>    <span class="s1">&#39;SyntaxError&#39;</span><span class="p">,</span>
              <span class="nx">message</span><span class="o">:</span> <span class="nx">m</span><span class="p">,</span>
              <span class="nx">at</span><span class="o">:</span>      <span class="nx">at</span><span class="p">,</span>
              <span class="nx">text</span><span class="o">:</span>    <span class="nx">text</span>
          <span class="p">};</span>
      <span class="p">},</span>
      
      <span class="nx">next</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If a c parameter is provided, verify that it matches the current character.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">!==</span> <span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Expected &#39;&quot;</span> <span class="o">+</span> <span class="nx">c</span> <span class="o">+</span> <span class="s2">&quot;&#39; instead of &#39;&quot;</span> <span class="o">+</span> <span class="nx">ch</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
          <span class="p">}</span>
          
          <span class="c1">// Get the next character. When there are no more characters,</span>
          <span class="c1">// return the empty string.</span>
          
          <span class="nx">ch</span> <span class="o">=</span> <span class="nx">text</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nx">at</span><span class="p">);</span>
          <span class="nx">at</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">ch</span><span class="p">;</span>
      <span class="p">},</span>
      
      <span class="nx">number</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Parse a number value.</span>
          <span class="kd">var</span> <span class="nx">number</span><span class="p">,</span>
              <span class="nx">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          
          <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">string</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="p">;</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">while</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">&gt;=</span> <span class="s1">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">string</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
              <span class="nx">next</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">string</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span><span class="p">;</span>
              <span class="k">while</span> <span class="p">(</span><span class="nx">next</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&gt;=</span> <span class="s1">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">string</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;e&#39;</span> <span class="o">||</span> <span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">string</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
              <span class="nx">next</span><span class="p">();</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;-&#39;</span> <span class="o">||</span> <span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">string</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
                  <span class="nx">next</span><span class="p">();</span>
              <span class="p">}</span>
              <span class="k">while</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">&gt;=</span> <span class="s1">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">string</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
                  <span class="nx">next</span><span class="p">();</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">number</span> <span class="o">=</span> <span class="o">+</span><span class="nx">string</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isFinite</span><span class="p">(</span><span class="nx">number</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Bad number&quot;</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">number</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">},</span>
      
      <span class="nx">string</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Parse a string value.</span>
          <span class="kd">var</span> <span class="nx">hex</span><span class="p">,</span>
              <span class="nx">i</span><span class="p">,</span>
              <span class="nx">string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
              <span class="nx">uffff</span><span class="p">;</span>
          
          <span class="c1">// When parsing for string values, we must look for &quot; and \ characters.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">while</span> <span class="p">(</span><span class="nx">next</span><span class="p">())</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">next</span><span class="p">();</span>
                      <span class="k">return</span> <span class="nx">string</span><span class="p">;</span>
                  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;\\&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">next</span><span class="p">();</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;u&#39;</span><span class="p">)</span> <span class="p">{</span>
                          <span class="nx">uffff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                          <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                              <span class="nx">hex</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">next</span><span class="p">(),</span> <span class="mi">16</span><span class="p">);</span>
                              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isFinite</span><span class="p">(</span><span class="nx">hex</span><span class="p">))</span> <span class="p">{</span>
                                  <span class="k">break</span><span class="p">;</span>
                              <span class="p">}</span>
                              <span class="nx">uffff</span> <span class="o">=</span> <span class="nx">uffff</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="nx">hex</span><span class="p">;</span>
                          <span class="p">}</span>
                          <span class="nx">string</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">uffff</span><span class="p">);</span>
                      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">escapee</span><span class="p">[</span><span class="nx">ch</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
                          <span class="nx">string</span> <span class="o">+=</span> <span class="nx">escapee</span><span class="p">[</span><span class="nx">ch</span><span class="p">];</span>
                      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                          <span class="k">break</span><span class="p">;</span>
                      <span class="p">}</span>
                  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">string</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Bad string&quot;</span><span class="p">);</span>
      <span class="p">},</span>

      <span class="nx">white</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Skip whitespace.</span>

          <span class="k">while</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&lt;=</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">next</span><span class="p">();</span>
          <span class="p">}</span>
      <span class="p">},</span>

      <span class="nx">word</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="c1">// true, false, or null.</span>

          <span class="k">switch</span> <span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;t&#39;</span><span class="o">:</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">);</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;f&#39;</span><span class="o">:</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">);</span>
              <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;n&#39;</span><span class="o">:</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">);</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">);</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Unexpected &#39;&quot;</span> <span class="o">+</span> <span class="nx">ch</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">);</span>
      <span class="p">},</span>

      <span class="nx">value</span><span class="p">,</span>  <span class="c1">// Place holder for the value function.</span>

      <span class="nx">array$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Parse an array value.</span>

          <span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[];</span>

          <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;[&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">);</span>
              <span class="nx">white</span><span class="p">();</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">);</span>
                  <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>   <span class="c1">// empty array</span>
              <span class="p">}</span>
              <span class="k">while</span> <span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">());</span>
                  <span class="nx">white</span><span class="p">();</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">);</span>
                      <span class="k">return</span> <span class="nx">array</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
                  <span class="nx">white</span><span class="p">();</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Bad array&quot;</span><span class="p">);</span>
      <span class="p">},</span>

      <span class="nx">object</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Parse an object value.</span>

          <span class="kd">var</span> <span class="nx">key</span><span class="p">,</span>
              <span class="nx">object</span> <span class="o">=</span> <span class="p">{};</span>

          <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;{&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;{&#39;</span><span class="p">);</span>
              <span class="nx">white</span><span class="p">();</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">);</span>
                  <span class="k">return</span> <span class="nx">object</span><span class="p">;</span>   <span class="c1">// empty object</span>
              <span class="p">}</span>
              <span class="k">while</span> <span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">key</span> <span class="o">=</span> <span class="nx">string</span><span class="p">();</span>
                  <span class="nx">white</span><span class="p">();</span>
                  <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">error$1</span><span class="p">(</span><span class="s1">&#39;Duplicate key &quot;&#39;</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="nx">object</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">();</span>
                  <span class="nx">white</span><span class="p">();</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span> <span class="o">===</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">);</span>
                      <span class="k">return</span> <span class="nx">object</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="nx">next</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
                  <span class="nx">white</span><span class="p">();</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Bad object&quot;</span><span class="p">);</span>
      <span class="p">};</span>

  <span class="nx">value</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Parse a JSON value. It could be an object, an array, a string, a number,</span>
  <span class="c1">// or a word.</span>

      <span class="nx">white</span><span class="p">();</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="s1">&#39;{&#39;</span><span class="o">:</span>
          <span class="k">return</span> <span class="nx">object</span><span class="p">();</span>
      <span class="k">case</span> <span class="s1">&#39;[&#39;</span><span class="o">:</span>
          <span class="k">return</span> <span class="nx">array$1</span><span class="p">();</span>
      <span class="k">case</span> <span class="s1">&#39;&quot;&#39;</span><span class="o">:</span>
          <span class="k">return</span> <span class="nx">string</span><span class="p">();</span>
      <span class="k">case</span> <span class="s1">&#39;-&#39;</span><span class="o">:</span>
          <span class="k">return</span> <span class="nx">number</span><span class="p">();</span>
      <span class="k">default</span><span class="o">:</span>
          <span class="k">return</span> <span class="nx">ch</span> <span class="o">&gt;=</span> <span class="s1">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">ch</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span> <span class="o">?</span> <span class="nx">number</span><span class="p">()</span> <span class="o">:</span> <span class="nx">word</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// Return the json_parse function. It will have access to all of the above</span>
  <span class="c1">// functions and variables.</span>

  <span class="kd">var</span> <span class="nx">parse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">reviver</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
      
      <span class="nx">text</span> <span class="o">=</span> <span class="nx">source</span><span class="p">;</span>
      <span class="nx">at</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">ch</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">;</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="nx">value</span><span class="p">();</span>
      <span class="nx">white</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">error$1</span><span class="p">(</span><span class="s2">&quot;Syntax error&quot;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// If there is a reviver function, we recursively walk the new structure,</span>
      <span class="c1">// passing each name/value pair to the reviver function for possible</span>
      <span class="c1">// transformation, starting with a temporary root object that holds the result</span>
      <span class="c1">// in an empty key. If there is not a reviver function, we simply return the</span>
      <span class="c1">// result.</span>

      <span class="k">return</span> <span class="k">typeof</span> <span class="nx">reviver</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="p">(</span><span class="kd">function</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">holder</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">holder</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="nx">k</span> <span class="k">in</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">v</span> <span class="o">=</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                          <span class="nx">value</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
                      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                          <span class="k">delete</span> <span class="nx">value</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">reviver</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">holder</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
      <span class="p">}({</span><span class="s1">&#39;&#39;</span><span class="o">:</span> <span class="nx">result</span><span class="p">},</span> <span class="s1">&#39;&#39;</span><span class="p">))</span> <span class="o">:</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">escapable</span> <span class="o">=</span> <span class="sr">/[\\\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g</span><span class="p">,</span>
      <span class="nx">gap</span><span class="p">,</span>
      <span class="nx">indent</span><span class="p">,</span>
      <span class="nx">meta</span> <span class="o">=</span> <span class="p">{</span>    <span class="c1">// table of character substitutions</span>
          <span class="s1">&#39;\b&#39;</span><span class="o">:</span> <span class="s1">&#39;\\b&#39;</span><span class="p">,</span>
          <span class="s1">&#39;\t&#39;</span><span class="o">:</span> <span class="s1">&#39;\\t&#39;</span><span class="p">,</span>
          <span class="s1">&#39;\n&#39;</span><span class="o">:</span> <span class="s1">&#39;\\n&#39;</span><span class="p">,</span>
          <span class="s1">&#39;\f&#39;</span><span class="o">:</span> <span class="s1">&#39;\\f&#39;</span><span class="p">,</span>
          <span class="s1">&#39;\r&#39;</span><span class="o">:</span> <span class="s1">&#39;\\r&#39;</span><span class="p">,</span>
          <span class="s1">&#39;&quot;&#39;</span> <span class="o">:</span> <span class="s1">&#39;\\&quot;&#39;</span><span class="p">,</span>
          <span class="s1">&#39;\\&#39;</span><span class="o">:</span> <span class="s1">&#39;\\\\&#39;</span>
      <span class="p">},</span>
      <span class="nx">rep</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">quote</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// If the string contains no control characters, no quote characters, and no</span>
      <span class="c1">// backslash characters, then we can safely slap some quotes around it.</span>
      <span class="c1">// Otherwise we must also replace the offending characters with safe escape</span>
      <span class="c1">// sequences.</span>
      
      <span class="nx">escapable</span><span class="p">.</span><span class="nx">lastIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">escapable</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">escapable</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">meta</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span>
          <span class="k">return</span> <span class="k">typeof</span> <span class="nx">c</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">?</span> <span class="nx">c</span> <span class="o">:</span>
              <span class="s1">&#39;\\u&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;0000&#39;</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)).</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
      <span class="p">})</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">:</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="nx">string</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">str</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">holder</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Produce a string from holder[key].</span>
      <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span>          <span class="c1">// The loop counter.</span>
          <span class="nx">k</span><span class="p">,</span>          <span class="c1">// The member key.</span>
          <span class="nx">v</span><span class="p">,</span>          <span class="c1">// The member value.</span>
          <span class="nx">length</span><span class="p">,</span>
          <span class="nx">mind</span> <span class="o">=</span> <span class="nx">gap</span><span class="p">,</span>
          <span class="nx">partial</span><span class="p">,</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">holder</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
      
      <span class="c1">// If the value has a toJSON method, call it to obtain a replacement value.</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">&amp;&amp;</span>
              <span class="k">typeof</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toJSON</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="c1">// If we were called with a replacer function, then call the replacer to</span>
      <span class="c1">// obtain a replacement value.</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">rep</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">rep</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">holder</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="c1">// What happens next depends on the value&#39;s type.</span>
      <span class="k">switch</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;string&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">quote</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
          
          <span class="k">case</span> <span class="s1">&#39;number&#39;</span><span class="o">:</span>
              <span class="c1">// JSON numbers must be finite. Encode non-finite numbers as null.</span>
              <span class="k">return</span> <span class="nb">isFinite</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">?</span> <span class="nb">String</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;null&#39;</span><span class="p">;</span>
          
          <span class="k">case</span> <span class="s1">&#39;boolean&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;null&#39;</span><span class="o">:</span>
              <span class="c1">// If the value is a boolean or null, convert it to a string. Note:</span>
              <span class="c1">// typeof null does not produce &#39;null&#39;. The case is included here in</span>
              <span class="c1">// the remote chance that this gets fixed someday.</span>
              <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
              
          <span class="k">case</span> <span class="s1">&#39;object&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">value</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;null&#39;</span><span class="p">;</span>
              <span class="nx">gap</span> <span class="o">+=</span> <span class="nx">indent</span><span class="p">;</span>
              <span class="nx">partial</span> <span class="o">=</span> <span class="p">[];</span>
              
              <span class="c1">// Array.isArray</span>
              <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;[object Array]&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">length</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
                  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">partial</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">str</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;null&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  
                  <span class="c1">// Join all of the elements together, separated with commas, and</span>
                  <span class="c1">// wrap them in brackets.</span>
                  <span class="nx">v</span> <span class="o">=</span> <span class="nx">partial</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="s1">&#39;[]&#39;</span> <span class="o">:</span> <span class="nx">gap</span> <span class="o">?</span>
                      <span class="s1">&#39;[\n&#39;</span> <span class="o">+</span> <span class="nx">gap</span> <span class="o">+</span> <span class="nx">partial</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,\n&#39;</span> <span class="o">+</span> <span class="nx">gap</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;\n&#39;</span> <span class="o">+</span> <span class="nx">mind</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span> <span class="o">:</span>
                      <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nx">partial</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span><span class="p">;</span>
                  <span class="nx">gap</span> <span class="o">=</span> <span class="nx">mind</span><span class="p">;</span>
                  <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
              <span class="p">}</span>
              
              <span class="c1">// If the replacer is an array, use it to select the members to be</span>
              <span class="c1">// stringified.</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">rep</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">rep</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">length</span> <span class="o">=</span> <span class="nx">rep</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
                  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">k</span> <span class="o">=</span> <span class="nx">rep</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">k</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
                          <span class="nx">v</span> <span class="o">=</span> <span class="nx">str</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
                          <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
                              <span class="nx">partial</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">quote</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">gap</span> <span class="o">?</span> <span class="s1">&#39;: &#39;</span> <span class="o">:</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
                          <span class="p">}</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="c1">// Otherwise, iterate through all of the keys in the object.</span>
                  <span class="k">for</span> <span class="p">(</span><span class="nx">k</span> <span class="k">in</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">v</span> <span class="o">=</span> <span class="nx">str</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
                          <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
                              <span class="nx">partial</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">quote</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">gap</span> <span class="o">?</span> <span class="s1">&#39;: &#39;</span> <span class="o">:</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">v</span><span class="p">);</span>
                          <span class="p">}</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              
          <span class="c1">// Join all of the member texts together, separated with commas,</span>
          <span class="c1">// and wrap them in braces.</span>

          <span class="nx">v</span> <span class="o">=</span> <span class="nx">partial</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="s1">&#39;{}&#39;</span> <span class="o">:</span> <span class="nx">gap</span> <span class="o">?</span>
              <span class="s1">&#39;{\n&#39;</span> <span class="o">+</span> <span class="nx">gap</span> <span class="o">+</span> <span class="nx">partial</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,\n&#39;</span> <span class="o">+</span> <span class="nx">gap</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;\n&#39;</span> <span class="o">+</span> <span class="nx">mind</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span> <span class="o">:</span>
              <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="nx">partial</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span><span class="p">;</span>
          <span class="nx">gap</span> <span class="o">=</span> <span class="nx">mind</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">v</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">stringify</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">replacer</span><span class="p">,</span> <span class="nx">space</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
      <span class="nx">gap</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">indent</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      
      <span class="c1">// If the space parameter is a number, make an indent string containing that</span>
      <span class="c1">// many spaces.</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">space</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">space</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">indent</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// If the space parameter is a string, it will be used as the indent string.</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">space</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">indent</span> <span class="o">=</span> <span class="nx">space</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// If there is a replacer, it must be a function or an array.</span>
      <span class="c1">// Otherwise, throw an error.</span>
      <span class="nx">rep</span> <span class="o">=</span> <span class="nx">replacer</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">replacer</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">replacer</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span>
      <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">replacer</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">replacer</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="s1">&#39;number&#39;</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;JSON.stringify&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="c1">// Make a fake root object containing our value under the key of &#39;&#39;.</span>
      <span class="c1">// Return the result of stringifying the value.</span>
      <span class="k">return</span> <span class="nx">str</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="o">:</span> <span class="nx">value</span><span class="p">});</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">parse$1</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">stringify$1</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">jsonify</span> <span class="o">=</span> <span class="p">{</span>
  	<span class="nx">parse</span><span class="o">:</span> <span class="nx">parse$1</span><span class="p">,</span>
  	<span class="nx">stringify</span><span class="o">:</span> <span class="nx">stringify$1</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">json</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">JSON</span> <span class="o">!==</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">?</span> <span class="nx">JSON</span> <span class="o">:</span> <span class="nx">jsonify</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">jsonStableStringify</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">opts</span><span class="p">)</span> <span class="nx">opts</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">opts</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="nx">opts</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">cmp</span><span class="o">:</span> <span class="nx">opts</span> <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">space</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">space</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">space</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="nx">space</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">space</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">cycles</span> <span class="o">=</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">cycles</span> <span class="o">===</span> <span class="s1">&#39;boolean&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">cycles</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">replacer</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">replacer</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">value</span><span class="p">;</span> <span class="p">};</span>

      <span class="kd">var</span> <span class="nx">cmp</span> <span class="o">=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">cmp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">aobj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">node</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="p">};</span>
                  <span class="kd">var</span> <span class="nx">bobj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">node</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span> <span class="p">};</span>
                  <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">aobj</span><span class="p">,</span> <span class="nx">bobj</span><span class="p">);</span>
              <span class="p">};</span>
          <span class="p">};</span>
      <span class="p">})(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">cmp</span><span class="p">);</span>

      <span class="kd">var</span> <span class="nx">seen</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">return</span> <span class="p">(</span><span class="kd">function</span> <span class="nx">stringify</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">level</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">indent</span> <span class="o">=</span> <span class="nx">space</span> <span class="o">?</span> <span class="p">(</span><span class="s1">&#39;\n&#39;</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="nx">space</span><span class="p">))</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">colonSeparator</span> <span class="o">=</span> <span class="nx">space</span> <span class="o">?</span> <span class="s1">&#39;: &#39;</span> <span class="o">:</span> <span class="s1">&#39;:&#39;</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">toJSON</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">node</span><span class="p">.</span><span class="nx">toJSON</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">();</span>
          <span class="p">}</span>

          <span class="nx">node</span> <span class="o">=</span> <span class="nx">replacer</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">node</span><span class="p">);</span>

          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">node</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="nx">node</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isArray$1</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">[];</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">node</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="nx">json</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
                  <span class="nx">out</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">indent</span> <span class="o">+</span> <span class="nx">space</span> <span class="o">+</span> <span class="nx">item</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nx">out</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">indent</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">seen</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">cycles</span><span class="p">)</span> <span class="k">return</span> <span class="nx">json</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="s1">&#39;__cycle__&#39;</span><span class="p">);</span>
                  <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s1">&#39;Converting circular structure to JSON&#39;</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="nx">seen</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>

              <span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nx">objectKeys</span><span class="p">(</span><span class="nx">node</span><span class="p">).</span><span class="nx">sort</span><span class="p">(</span><span class="nx">cmp</span> <span class="o">&amp;&amp;</span> <span class="nx">cmp</span><span class="p">(</span><span class="nx">node</span><span class="p">));</span>
              <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">[];</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                  <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">stringify</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">node</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

                  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">value</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

                  <span class="kd">var</span> <span class="nx">keyValue</span> <span class="o">=</span> <span class="nx">json</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
                      <span class="o">+</span> <span class="nx">colonSeparator</span>
                      <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
                  <span class="nx">out</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">indent</span> <span class="o">+</span> <span class="nx">space</span> <span class="o">+</span> <span class="nx">keyValue</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="nx">seen</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">seen</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">node</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
              <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="nx">out</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">indent</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">})({</span> <span class="s1">&#39;&#39;</span><span class="o">:</span> <span class="nx">obj</span> <span class="p">},</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">isArray$1</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span> <span class="o">||</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{}.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;[object Array]&#39;</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">objectKeys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span> <span class="o">||</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">has</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span> <span class="o">||</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">has</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">stableStringify_</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="k">default</span><span class="o">:</span> <span class="nx">jsonStableStringify</span><span class="p">,</span>
    <span class="nx">__moduleExports</span><span class="o">:</span> <span class="nx">jsonStableStringify</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">isLogicalOr</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">op</span><span class="p">.</span><span class="nx">or</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isLogicalAnd</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">op</span><span class="p">.</span><span class="nx">and</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isLogicalNot</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">op</span><span class="p">.</span><span class="nx">not</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">forEachLeaf</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalNot</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">forEachLeaf</span><span class="p">(</span><span class="nx">op</span><span class="p">.</span><span class="nx">not</span><span class="p">,</span> <span class="nx">fn</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalAnd</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">op</span><span class="p">.</span><span class="nx">and</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">subop</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">forEachLeaf</span><span class="p">(</span><span class="nx">subop</span><span class="p">,</span> <span class="nx">fn</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalOr</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">op</span><span class="p">.</span><span class="nx">or</span><span class="p">;</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">subop</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
              <span class="nx">forEachLeaf</span><span class="p">(</span><span class="nx">subop</span><span class="p">,</span> <span class="nx">fn</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">fn</span><span class="p">(</span><span class="nx">op</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeLogicalOperand</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">normalizer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalNot</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">not</span><span class="o">:</span> <span class="nx">normalizeLogicalOperand</span><span class="p">(</span><span class="nx">op</span><span class="p">.</span><span class="nx">not</span><span class="p">,</span> <span class="nx">normalizer</span><span class="p">)</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalAnd</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">and</span><span class="o">:</span> <span class="nx">op</span><span class="p">.</span><span class="nx">and</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">normalizeLogicalOperand</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">normalizer</span><span class="p">);</span> <span class="p">})</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalOr</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">or</span><span class="o">:</span> <span class="nx">op</span><span class="p">.</span><span class="nx">or</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">normalizeLogicalOperand</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">normalizer</span><span class="p">);</span> <span class="p">})</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizer</span><span class="p">(</span><span class="nx">op</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">stableStringify</span> <span class="o">=</span> <span class="nx">jsonStableStringify</span> <span class="o">||</span> <span class="nx">stableStringify_</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Creates an object composed of the picked object properties.</span>
<span class="cm">   *</span>
<span class="cm">   * Example:  (from lodash)</span>
<span class="cm">   *</span>
<span class="cm">   * var object = {&#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3};</span>
<span class="cm">   * pick(object, [&#39;a&#39;, &#39;c&#39;]);</span>
<span class="cm">   * //  {&#39;a&#39;: 1, &#39;c&#39;: 3}</span>
<span class="cm">   *</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">pick</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">props_1</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">props_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">props_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">copy</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">copy</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * The opposite of _.pick; this method creates an object composed of the own</span>
<span class="cm">   * and inherited enumerable string keyed properties of object that are not omitted.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">omit</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">obj</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">props_2</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">props_2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">props_2</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">delete</span> <span class="nx">copy</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">copy</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Converts any object into a string representation that can be consumed by humans.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">stringify$2</span> <span class="o">=</span> <span class="nx">stableStringify</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Converts any object into a string of limited size, or a number.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">hash</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">?</span> <span class="nx">a</span> <span class="o">:</span> <span class="nx">stableStringify</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
      <span class="c1">// short strings can be used as hash directly, longer strings are hashed to reduce memory usage</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">str</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// from http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/</span>
      <span class="kd">var</span> <span class="nx">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="kr">char</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
          <span class="nx">h</span> <span class="o">=</span> <span class="p">((</span><span class="nx">h</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="nx">h</span><span class="p">)</span> <span class="o">+</span> <span class="kr">char</span><span class="p">;</span>
          <span class="nx">h</span> <span class="o">=</span> <span class="nx">h</span> <span class="o">&amp;</span> <span class="nx">h</span><span class="p">;</span> <span class="c1">// Convert to 32bit integer</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">h</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">array$$1</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">array$$1</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/** Returns the array without the elements in item */</span>
  <span class="kd">function</span> <span class="nx">without</span><span class="p">(</span><span class="nx">array$$1</span><span class="p">,</span> <span class="nx">excludedItems</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">array$$1</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="nx">contains</span><span class="p">(</span><span class="nx">excludedItems</span><span class="p">,</span> <span class="nx">item</span><span class="p">);</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">union</span><span class="p">(</span><span class="nx">array$$1</span><span class="p">,</span> <span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">array$$1</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">without</span><span class="p">(</span><span class="nx">other</span><span class="p">,</span> <span class="nx">array$$1</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns true if any item returns true.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">some</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">k</span><span class="p">],</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">i</span><span class="o">++</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns true if all items return true.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">every</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">f</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">k</span><span class="p">],</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">i</span><span class="o">++</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">arrays</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">.</span><span class="nx">apply</span><span class="p">([],</span> <span class="nx">arrays</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * recursively merges src into dest</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">mergeDeep</span><span class="p">(</span><span class="nx">dest</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">src</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">src</span><span class="p">[</span><span class="nx">_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">src_1</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">src_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">src_1</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
          <span class="nx">dest</span> <span class="o">=</span> <span class="nx">deepMerge_</span><span class="p">(</span><span class="nx">dest</span><span class="p">,</span> <span class="nx">s</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">dest</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// recursively merges src into dest</span>
  <span class="kd">function</span> <span class="nx">deepMerge_</span><span class="p">(</span><span class="nx">dest</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">src</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="nx">src</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">dest</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">p</span> <span class="k">in</span> <span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">src</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="o">||</span> <span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">dest</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">dest</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="nx">dest</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">dest</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">mergeDeep</span><span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">constructor</span><span class="p">)</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="p">{},</span> <span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">]);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">mergeDeep</span><span class="p">(</span><span class="nx">dest</span><span class="p">[</span><span class="nx">p</span><span class="p">],</span> <span class="nx">src</span><span class="p">[</span><span class="nx">p</span><span class="p">]);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">dest</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">values</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">u</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">v</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">values_1</span> <span class="o">=</span> <span class="nx">values</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">values_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">values_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">v</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">in</span> <span class="nx">u</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">u</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns true if the two dictionaries disagree. Applies only to defined values.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">differ</span><span class="p">(</span><span class="nx">dict</span><span class="p">,</span> <span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key$$1</span> <span class="k">in</span> <span class="nx">dict</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">dict</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key$$1</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">other</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">other</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">])</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">hasIntersection</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key$$1</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">key$$1</span> <span class="k">in</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isNumeric</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">differArray</span><span class="p">(</span><span class="nx">array$$1</span><span class="p">,</span> <span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">array$$1</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">other</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">array$$1</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
      <span class="nx">other</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array$$1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">other</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">array$$1</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// This is a stricter version of Object.keys but with better types. See https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208</span>
  <span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">vals</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_vals</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="k">in</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">_vals</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">_vals</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">duplicate</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isBoolean$1</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">b</span> <span class="o">===</span> <span class="kc">true</span> <span class="o">||</span> <span class="nx">b</span> <span class="o">===</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Convert a string into a valid variable name</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _</span>
      <span class="kd">var</span> <span class="nx">alphanumericS</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\W/g</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">);</span>
      <span class="c1">// Add _ if the string has leading numbers.</span>
      <span class="k">return</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^\d+/</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;_&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">alphanumericS</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">logicalExpr</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalNot</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;!(&#39;</span> <span class="o">+</span> <span class="nx">logicalExpr</span><span class="p">(</span><span class="nx">op</span><span class="p">.</span><span class="nx">not</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalAnd</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nx">op</span><span class="p">.</span><span class="nx">and</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">and</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">logicalExpr</span><span class="p">(</span><span class="nx">and</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;) &amp;&amp; (&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLogicalOr</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nx">op</span><span class="p">.</span><span class="nx">or</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">or</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">logicalExpr</span><span class="p">(</span><span class="nx">or</span><span class="p">,</span> <span class="nx">cb</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;) || (&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">cb</span><span class="p">(</span><span class="nx">op</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Delete nested property of an object, and delete the ancestors of the property if they become empty.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">deleteNestedProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">orderedProps</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orderedProps</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">orderedProps</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">deleteNestedProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">],</span> <span class="nx">orderedProps</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">delete</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">titlecase</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Converts a path to an access path with datum.</span>
<span class="cm">   * @param path The field name.</span>
<span class="cm">   * @param datum The string to use for `datum`.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">datum</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">datum</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">datum</span> <span class="o">=</span> <span class="s1">&#39;datum&#39;</span><span class="p">;</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">pieces</span> <span class="o">=</span> <span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">prefixes</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">pieces</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prefix</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">pieces</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">$</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;][&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">;</span>
          <span class="nx">prefixes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">datum</span> <span class="o">+</span> <span class="nx">prefix</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">prefixes</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return access with datum to the falttened field.</span>
<span class="cm">   * @param path The field name.</span>
<span class="cm">   * @param datum The string to use for `datum`.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">flatAccessWithDatum</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">datum</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">datum</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">datum</span> <span class="o">=</span> <span class="s1">&#39;datum&#39;</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">return</span> <span class="nx">datum</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Replaces path accesses with access to non-nested field.</span>
<span class="cm">   * For example, `foo[&quot;bar&quot;].baz` becomes `foo\\.bar\\.baz`.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">replacePathInField</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;\\.&#39;</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;\\.&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Remove path accesses with access from field.</span>
<span class="cm">   * For example, `foo[&quot;bar&quot;].baz` becomes `foo.bar.baz`.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">removePathFromField</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Count the depth of the path. Returns 1 for fields that are not nested.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">accessPathDepth</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">splitAccessPath</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">util</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">pick</span><span class="o">:</span> <span class="nx">pick</span><span class="p">,</span>
    <span class="nx">omit</span><span class="o">:</span> <span class="nx">omit</span><span class="p">,</span>
    <span class="nx">stringify</span><span class="o">:</span> <span class="nx">stringify$2</span><span class="p">,</span>
    <span class="nx">hash</span><span class="o">:</span> <span class="nx">hash</span><span class="p">,</span>
    <span class="nx">contains</span><span class="o">:</span> <span class="nx">contains</span><span class="p">,</span>
    <span class="nx">without</span><span class="o">:</span> <span class="nx">without</span><span class="p">,</span>
    <span class="nx">union</span><span class="o">:</span> <span class="nx">union</span><span class="p">,</span>
    <span class="nx">some</span><span class="o">:</span> <span class="nx">some</span><span class="p">,</span>
    <span class="nx">every</span><span class="o">:</span> <span class="nx">every</span><span class="p">,</span>
    <span class="nx">flatten</span><span class="o">:</span> <span class="nx">flatten</span><span class="p">,</span>
    <span class="nx">mergeDeep</span><span class="o">:</span> <span class="nx">mergeDeep</span><span class="p">,</span>
    <span class="nx">unique</span><span class="o">:</span> <span class="nx">unique</span><span class="p">,</span>
    <span class="nx">differ</span><span class="o">:</span> <span class="nx">differ</span><span class="p">,</span>
    <span class="nx">hasIntersection</span><span class="o">:</span> <span class="nx">hasIntersection</span><span class="p">,</span>
    <span class="nx">isNumeric</span><span class="o">:</span> <span class="nx">isNumeric</span><span class="p">,</span>
    <span class="nx">differArray</span><span class="o">:</span> <span class="nx">differArray</span><span class="p">,</span>
    <span class="nx">keys</span><span class="o">:</span> <span class="nx">keys</span><span class="p">,</span>
    <span class="nx">vals</span><span class="o">:</span> <span class="nx">vals</span><span class="p">,</span>
    <span class="nx">flagKeys</span><span class="o">:</span> <span class="nx">flagKeys</span><span class="p">,</span>
    <span class="nx">duplicate</span><span class="o">:</span> <span class="nx">duplicate</span><span class="p">,</span>
    <span class="nx">isBoolean</span><span class="o">:</span> <span class="nx">isBoolean$1</span><span class="p">,</span>
    <span class="nx">varName</span><span class="o">:</span> <span class="nx">varName</span><span class="p">,</span>
    <span class="nx">logicalExpr</span><span class="o">:</span> <span class="nx">logicalExpr</span><span class="p">,</span>
    <span class="nx">deleteNestedProperty</span><span class="o">:</span> <span class="nx">deleteNestedProperty</span><span class="p">,</span>
    <span class="nx">titlecase</span><span class="o">:</span> <span class="nx">titlecase</span><span class="p">,</span>
    <span class="nx">accessPathWithDatum</span><span class="o">:</span> <span class="nx">accessPathWithDatum</span><span class="p">,</span>
    <span class="nx">flatAccessWithDatum</span><span class="o">:</span> <span class="nx">flatAccessWithDatum</span><span class="p">,</span>
    <span class="nx">replacePathInField</span><span class="o">:</span> <span class="nx">replacePathInField</span><span class="p">,</span>
    <span class="nx">removePathFromField</span><span class="o">:</span> <span class="nx">removePathFromField</span><span class="p">,</span>
    <span class="nx">accessPathDepth</span><span class="o">:</span> <span class="nx">accessPathDepth</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">AGGREGATE_OP_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">argmax</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">argmin</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">average</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">count</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">distinct</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">max</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">mean</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">median</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">min</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">missing</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">q1</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">q3</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">ci0</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">ci1</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">stderr</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">stdev</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">stdevp</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">sum</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">valid</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">values</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">variance</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">variancep</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">AGGREGATE_OPS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">AGGREGATE_OP_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isAggregateOp</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">AGGREGATE_OP_INDEX</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">COUNTING_OPS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">,</span> <span class="s1">&#39;distinct&#39;</span><span class="p">];</span>
  <span class="kd">function</span> <span class="nx">isCountingAggregateOp</span><span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">COUNTING_OPS</span><span class="p">,</span> <span class="nx">aggregate</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/** Additive-based aggregation operations.  These can be applied to stack. */</span>
  <span class="kd">var</span> <span class="nx">SUM_OPS</span> <span class="o">=</span> <span class="p">[</span>
      <span class="s1">&#39;count&#39;</span><span class="p">,</span>
      <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
      <span class="s1">&#39;distinct&#39;</span><span class="p">,</span>
      <span class="s1">&#39;valid&#39;</span><span class="p">,</span>
      <span class="s1">&#39;missing&#39;</span>
  <span class="p">];</span>
  <span class="cm">/**</span>
<span class="cm">   * Aggregation operators that always produce values within the range [domainMin, domainMax].</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">SHARED_DOMAIN_OPS</span> <span class="o">=</span> <span class="p">[</span>
      <span class="s1">&#39;mean&#39;</span><span class="p">,</span>
      <span class="s1">&#39;average&#39;</span><span class="p">,</span>
      <span class="s1">&#39;median&#39;</span><span class="p">,</span>
      <span class="s1">&#39;q1&#39;</span><span class="p">,</span>
      <span class="s1">&#39;q3&#39;</span><span class="p">,</span>
      <span class="s1">&#39;min&#39;</span><span class="p">,</span>
      <span class="s1">&#39;max&#39;</span><span class="p">,</span>
  <span class="p">];</span>
  <span class="kd">var</span> <span class="nx">SHARED_DOMAIN_OP_INDEX</span> <span class="o">=</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">SHARED_DOMAIN_OPS</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">AGGREGATE_OPS</span><span class="o">:</span> <span class="nx">AGGREGATE_OPS</span><span class="p">,</span>
    <span class="nx">isAggregateOp</span><span class="o">:</span> <span class="nx">isAggregateOp</span><span class="p">,</span>
    <span class="nx">COUNTING_OPS</span><span class="o">:</span> <span class="nx">COUNTING_OPS</span><span class="p">,</span>
    <span class="nx">isCountingAggregateOp</span><span class="o">:</span> <span class="nx">isCountingAggregateOp</span><span class="p">,</span>
    <span class="nx">SUM_OPS</span><span class="o">:</span> <span class="nx">SUM_OPS</span><span class="p">,</span>
    <span class="nx">SHARED_DOMAIN_OPS</span><span class="o">:</span> <span class="nx">SHARED_DOMAIN_OPS</span><span class="p">,</span>
    <span class="nx">SHARED_DOMAIN_OP_INDEX</span><span class="o">:</span> <span class="nx">SHARED_DOMAIN_OP_INDEX</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">AXIS_PARTS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="s1">&#39;ticks&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">];</span>
  <span class="cm">/**</span>
<span class="cm">   * A dictionary listing whether a certain axis property is applicable for only main axes or only grid axes.</span>
<span class="cm">   * (Properties not listed are applicable for both)</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">AXIS_PROPERTY_TYPE</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">grid</span><span class="o">:</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span>
      <span class="nx">gridScale</span><span class="o">:</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span>
      <span class="nx">domain</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">labels</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">labelFlush</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">labelOverlap</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">minExtent</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">maxExtent</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">offset</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">ticks</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span>
      <span class="nx">values</span><span class="o">:</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span>
      <span class="nx">scale</span><span class="o">:</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span>
      <span class="nx">zindex</span><span class="o">:</span> <span class="s1">&#39;both&#39;</span> <span class="c1">// this is actually set afterward, so it doesn&#39;t matter</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">COMMON_AXIS_PROPERTIES_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">orient</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">domain</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">format</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">grid</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">labelBound</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">labelFlush</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">labelPadding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">labels</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">labelOverlap</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">maxExtent</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">minExtent</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">offset</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">position</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">tickCount</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">ticks</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">tickSize</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">title</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">titlePadding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">values</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">zindex</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">AXIS_PROPERTIES_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">COMMON_AXIS_PROPERTIES_INDEX</span><span class="p">,</span> <span class="p">{</span> <span class="nx">encoding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">labelAngle</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">titleMaxLength</span><span class="o">:</span> <span class="mi">1</span> <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">VG_AXIS_PROPERTIES_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">scale</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="nx">COMMON_AXIS_PROPERTIES_INDEX</span><span class="p">,</span> <span class="p">{</span> <span class="nx">gridScale</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">encode</span><span class="o">:</span> <span class="mi">1</span> <span class="p">});</span>
  <span class="kd">function</span> <span class="nx">isAxisProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">AXIS_PROPERTIES_INDEX</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">VG_AXIS_PROPERTIES</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">VG_AXIS_PROPERTIES_INDEX</span><span class="p">);</span>
  <span class="c1">// Export for dependent projects</span>
  <span class="kd">var</span> <span class="nx">AXIS_PROPERTIES</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">AXIS_PROPERTIES_INDEX</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">axis</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">AXIS_PARTS</span><span class="o">:</span> <span class="nx">AXIS_PARTS</span><span class="p">,</span>
    <span class="nx">AXIS_PROPERTY_TYPE</span><span class="o">:</span> <span class="nx">AXIS_PROPERTY_TYPE</span><span class="p">,</span>
    <span class="nx">isAxisProperty</span><span class="o">:</span> <span class="nx">isAxisProperty</span><span class="p">,</span>
    <span class="nx">VG_AXIS_PROPERTIES</span><span class="o">:</span> <span class="nx">VG_AXIS_PROPERTIES</span><span class="p">,</span>
    <span class="nx">AXIS_PROPERTIES</span><span class="o">:</span> <span class="nx">AXIS_PROPERTIES</span>
  <span class="p">});</span>

  <span class="cm">/*</span>
<span class="cm">   * Constants and utilities for encoding channels (Visual variables)</span>
<span class="cm">   * such as &#39;x&#39;, &#39;y&#39;, &#39;color&#39;.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">Channel</span><span class="p">;</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">Channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Facet</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">ROW</span> <span class="o">=</span> <span class="s1">&#39;row&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">COLUMN</span> <span class="o">=</span> <span class="s1">&#39;column&#39;</span><span class="p">;</span>
      <span class="c1">// Position</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">X</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">Y</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">X2</span> <span class="o">=</span> <span class="s1">&#39;x2&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">Y2</span> <span class="o">=</span> <span class="s1">&#39;y2&#39;</span><span class="p">;</span>
      <span class="c1">// Geo Position</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">LATITUDE</span> <span class="o">=</span> <span class="s1">&#39;latitude&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">LONGITUDE</span> <span class="o">=</span> <span class="s1">&#39;longitude&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">LATITUDE2</span> <span class="o">=</span> <span class="s1">&#39;latitude2&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">LONGITUDE2</span> <span class="o">=</span> <span class="s1">&#39;longitude2&#39;</span><span class="p">;</span>
      <span class="c1">// Mark property with scale</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">COLOR</span> <span class="o">=</span> <span class="s1">&#39;color&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">FILL</span> <span class="o">=</span> <span class="s1">&#39;fill&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">STROKE</span> <span class="o">=</span> <span class="s1">&#39;stroke&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">SHAPE</span> <span class="o">=</span> <span class="s1">&#39;shape&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">SIZE</span> <span class="o">=</span> <span class="s1">&#39;size&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">OPACITY</span> <span class="o">=</span> <span class="s1">&#39;opacity&#39;</span><span class="p">;</span>
      <span class="c1">// Non-scale channel</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">TEXT</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">ORDER</span> <span class="o">=</span> <span class="s1">&#39;order&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">DETAIL</span> <span class="o">=</span> <span class="s1">&#39;detail&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">KEY</span> <span class="o">=</span> <span class="s1">&#39;key&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">TOOLTIP</span> <span class="o">=</span> <span class="s1">&#39;tooltip&#39;</span><span class="p">;</span>
      <span class="nx">Channel</span><span class="p">.</span><span class="nx">HREF</span> <span class="o">=</span> <span class="s1">&#39;href&#39;</span><span class="p">;</span>
  <span class="p">})(</span><span class="nx">Channel</span> <span class="o">||</span> <span class="p">(</span><span class="nx">Channel</span> <span class="o">=</span> <span class="p">{}));</span>
  <span class="kd">var</span> <span class="nx">X</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">X</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">Y</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">Y</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">X2</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">X2</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">Y2</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">Y2</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">LATITUDE</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">LATITUDE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">LATITUDE2</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">LATITUDE2</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">LONGITUDE</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">LONGITUDE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">LONGITUDE2</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">LONGITUDE2</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">ROW</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">ROW</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">COLUMN</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">COLUMN</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">SHAPE</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">SHAPE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">SIZE</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">SIZE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">COLOR</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">COLOR</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">FILL</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">FILL</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">STROKE</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">STROKE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TEXT</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">TEXT</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">DETAIL</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">DETAIL</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">KEY</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">KEY</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">ORDER</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">ORDER</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">OPACITY</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">OPACITY</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TOOLTIP</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">TOOLTIP</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">HREF</span> <span class="o">=</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">HREF</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">GEOPOSITION_CHANNEL_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">longitude</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">longitude2</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">latitude</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">latitude2</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">GEOPOSITION_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">GEOPOSITION_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">UNIT_CHANNEL_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> 
      <span class="c1">// position</span>
      <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">x2</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y2</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="nx">GEOPOSITION_CHANNEL_INDEX</span><span class="p">,</span> <span class="p">{</span> 
      <span class="c1">// color</span>
      <span class="nx">color</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">fill</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">stroke</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> 
      <span class="c1">// other non-position with scale</span>
      <span class="nx">opacity</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">size</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">shape</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> 
      <span class="c1">// channels without scales</span>
      <span class="nx">order</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">detail</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">tooltip</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">href</span><span class="o">:</span> <span class="mi">1</span> <span class="p">});</span>
  <span class="kd">function</span> <span class="nx">isColorChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;color&#39;</span> <span class="o">||</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;fill&#39;</span> <span class="o">||</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;stroke&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">FACET_CHANNEL_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">row</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">column</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">CHANNEL_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">,</span> <span class="nx">FACET_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">CHANNEL_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">_o</span> <span class="o">=</span> <span class="nx">CHANNEL_INDEX</span><span class="p">.</span><span class="nx">order</span><span class="p">,</span> <span class="nx">_d</span> <span class="o">=</span> <span class="nx">CHANNEL_INDEX</span><span class="p">.</span><span class="nx">detail</span><span class="p">,</span> <span class="nx">SINGLE_DEF_CHANNEL_INDEX</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">CHANNEL_INDEX</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="s2">&quot;detail&quot;</span><span class="p">]);</span>
  <span class="cm">/**</span>
<span class="cm">   * Channels that cannot have an array of channelDef.</span>
<span class="cm">   * model.fieldDef, getFieldDef only work for these channels.</span>
<span class="cm">   *</span>
<span class="cm">   * (The only two channels that can have an array of channelDefs are &quot;detail&quot; and &quot;order&quot;.</span>
<span class="cm">   * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef</span>
<span class="cm">   * are not applicable for them.  Similarly, selection projection won&#39;t work with &quot;detail&quot; and &quot;order&quot;.)</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">SINGLE_DEF_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">SINGLE_DEF_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isChannel</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">CHANNEL_INDEX</span><span class="p">[</span><span class="nx">str</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="c1">// CHANNELS without COLUMN, ROW</span>
  <span class="kd">var</span> <span class="nx">UNIT_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="c1">// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;</span>
  <span class="kd">var</span> <span class="nx">_x</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">_y</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> 
  <span class="c1">// x2 and y2 share the same scale as x and y</span>
  <span class="nx">_x2</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">_y2</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">y2</span><span class="p">,</span> <span class="nx">_latitude</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">latitude</span><span class="p">,</span> <span class="nx">_longitude</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">longitude</span><span class="p">,</span> <span class="nx">_latitude2</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">latitude2</span><span class="p">,</span> <span class="nx">_longitude2</span> <span class="o">=</span> <span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">.</span><span class="nx">longitude2</span><span class="p">,</span> 
  <span class="c1">// The rest of unit channels then have scale</span>
  <span class="nx">NONPOSITION_CHANNEL_INDEX</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">UNIT_CHANNEL_INDEX</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="s2">&quot;y2&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;latitude2&quot;</span><span class="p">,</span> <span class="s2">&quot;longitude2&quot;</span><span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">NONPOSITION_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">NONPOSITION_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="c1">// POSITION_SCALE_CHANNELS = X and Y;</span>
  <span class="kd">var</span> <span class="nx">POSITION_SCALE_CHANNEL_INDEX</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">POSITION_SCALE_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">POSITION_SCALE_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="c1">// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y</span>
  <span class="kd">var</span>  
  <span class="nx">NONPOSITION_SCALE_CHANNEL_INDEX</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">NONPOSITION_CHANNEL_INDEX</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;tooltip&quot;</span><span class="p">,</span> <span class="s2">&quot;href&quot;</span><span class="p">,</span> <span class="s2">&quot;detail&quot;</span><span class="p">,</span> <span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">NONPOSITION_SCALE_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">NONPOSITION_SCALE_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="c1">// Declare SCALE_CHANNEL_INDEX</span>
  <span class="kd">var</span> <span class="nx">SCALE_CHANNEL_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">POSITION_SCALE_CHANNEL_INDEX</span><span class="p">,</span> <span class="nx">NONPOSITION_SCALE_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="cm">/** List of channels with scales */</span>
  <span class="kd">var</span> <span class="nx">SCALE_CHANNELS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">SCALE_CHANNEL_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">SCALE_CHANNEL_INDEX</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return whether a channel supports a particular mark type.</span>
<span class="cm">   * @param channel  channel name</span>
<span class="cm">   * @param mark the mark type</span>
<span class="cm">   * @return whether the mark supports the channel</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">supportMark</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mark</span> <span class="k">in</span> <span class="nx">getSupportedMark</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return a dictionary showing whether a channel supports mark type.</span>
<span class="cm">   * @param channel</span>
<span class="cm">   * @return A dictionary mapping mark types to boolean values.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getSupportedMark</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">COLOR</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">FILL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">STROKE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">DETAIL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">KEY</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">TOOLTIP</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">HREF</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">ORDER</span><span class="o">:</span> <span class="c1">// TODO: revise (order might not support rect, which is not stackable?)</span>
          <span class="k">case</span> <span class="nx">OPACITY</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">ROW</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">COLUMN</span><span class="o">:</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">point</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">tick</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rule</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">circle</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">square</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
                  <span class="nx">bar</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rect</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">line</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">trail</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">area</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">geoshape</span><span class="o">:</span> <span class="kc">true</span>
              <span class="p">};</span>
          <span class="k">case</span> <span class="nx">X</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Y</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LATITUDE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LONGITUDE</span><span class="o">:</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">point</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">tick</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rule</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">circle</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">square</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
                  <span class="nx">bar</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rect</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">line</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">trail</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">area</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="kc">true</span>
              <span class="p">};</span>
          <span class="k">case</span> <span class="nx">X2</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Y2</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LATITUDE2</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LONGITUDE2</span><span class="o">:</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">rule</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">bar</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rect</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">area</span><span class="o">:</span> <span class="kc">true</span>
              <span class="p">};</span>
          <span class="k">case</span> <span class="nx">SIZE</span><span class="o">:</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">point</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">tick</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">rule</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">circle</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">square</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
                  <span class="nx">bar</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">line</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">trail</span><span class="o">:</span> <span class="kc">true</span>
              <span class="p">};</span>
          <span class="k">case</span> <span class="nx">SHAPE</span><span class="o">:</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">point</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">geoshape</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
          <span class="k">case</span> <span class="nx">TEXT</span><span class="o">:</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">text</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">rangeType</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">X</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Y</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SIZE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">OPACITY</span><span class="o">:</span>
          <span class="c1">// X2 and Y2 use X and Y scales, so they similarly have continuous range.</span>
          <span class="k">case</span> <span class="nx">X2</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Y2</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;continuous&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="nx">ROW</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">COLUMN</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SHAPE</span><span class="o">:</span>
          <span class="c1">// TEXT, TOOLTIP, and HREF have no scale but have discrete output</span>
          <span class="k">case</span> <span class="nx">TEXT</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">TOOLTIP</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">HREF</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;discrete&#39;</span><span class="p">;</span>
          <span class="c1">// Color can be either continuous or discrete, depending on scale type.</span>
          <span class="k">case</span> <span class="nx">COLOR</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">FILL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">STROKE</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;flexible&#39;</span><span class="p">;</span>
          <span class="c1">// No scale, no range type.</span>
          <span class="k">case</span> <span class="nx">LATITUDE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LONGITUDE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LATITUDE2</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LONGITUDE2</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">DETAIL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">KEY</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">ORDER</span><span class="o">:</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach here. */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;rangeType not implemented for &#39;</span> <span class="o">+</span> <span class="nx">channel</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">get</span> <span class="nx">Channel</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Channel</span><span class="p">;</span> <span class="p">},</span>
    <span class="nx">X</span><span class="o">:</span> <span class="nx">X</span><span class="p">,</span>
    <span class="nx">Y</span><span class="o">:</span> <span class="nx">Y</span><span class="p">,</span>
    <span class="nx">X2</span><span class="o">:</span> <span class="nx">X2</span><span class="p">,</span>
    <span class="nx">Y2</span><span class="o">:</span> <span class="nx">Y2</span><span class="p">,</span>
    <span class="nx">LATITUDE</span><span class="o">:</span> <span class="nx">LATITUDE</span><span class="p">,</span>
    <span class="nx">LATITUDE2</span><span class="o">:</span> <span class="nx">LATITUDE2</span><span class="p">,</span>
    <span class="nx">LONGITUDE</span><span class="o">:</span> <span class="nx">LONGITUDE</span><span class="p">,</span>
    <span class="nx">LONGITUDE2</span><span class="o">:</span> <span class="nx">LONGITUDE2</span><span class="p">,</span>
    <span class="nx">ROW</span><span class="o">:</span> <span class="nx">ROW</span><span class="p">,</span>
    <span class="nx">COLUMN</span><span class="o">:</span> <span class="nx">COLUMN</span><span class="p">,</span>
    <span class="nx">SHAPE</span><span class="o">:</span> <span class="nx">SHAPE</span><span class="p">,</span>
    <span class="nx">SIZE</span><span class="o">:</span> <span class="nx">SIZE</span><span class="p">,</span>
    <span class="nx">COLOR</span><span class="o">:</span> <span class="nx">COLOR</span><span class="p">,</span>
    <span class="nx">FILL</span><span class="o">:</span> <span class="nx">FILL</span><span class="p">,</span>
    <span class="nx">STROKE</span><span class="o">:</span> <span class="nx">STROKE</span><span class="p">,</span>
    <span class="nx">TEXT</span><span class="o">:</span> <span class="nx">TEXT</span><span class="p">,</span>
    <span class="nx">DETAIL</span><span class="o">:</span> <span class="nx">DETAIL</span><span class="p">,</span>
    <span class="nx">KEY</span><span class="o">:</span> <span class="nx">KEY</span><span class="p">,</span>
    <span class="nx">ORDER</span><span class="o">:</span> <span class="nx">ORDER</span><span class="p">,</span>
    <span class="nx">OPACITY</span><span class="o">:</span> <span class="nx">OPACITY</span><span class="p">,</span>
    <span class="nx">TOOLTIP</span><span class="o">:</span> <span class="nx">TOOLTIP</span><span class="p">,</span>
    <span class="nx">HREF</span><span class="o">:</span> <span class="nx">HREF</span><span class="p">,</span>
    <span class="nx">GEOPOSITION_CHANNEL_INDEX</span><span class="o">:</span> <span class="nx">GEOPOSITION_CHANNEL_INDEX</span><span class="p">,</span>
    <span class="nx">GEOPOSITION_CHANNELS</span><span class="o">:</span> <span class="nx">GEOPOSITION_CHANNELS</span><span class="p">,</span>
    <span class="nx">isColorChannel</span><span class="o">:</span> <span class="nx">isColorChannel</span><span class="p">,</span>
    <span class="nx">CHANNELS</span><span class="o">:</span> <span class="nx">CHANNELS</span><span class="p">,</span>
    <span class="nx">SINGLE_DEF_CHANNELS</span><span class="o">:</span> <span class="nx">SINGLE_DEF_CHANNELS</span><span class="p">,</span>
    <span class="nx">isChannel</span><span class="o">:</span> <span class="nx">isChannel</span><span class="p">,</span>
    <span class="nx">UNIT_CHANNELS</span><span class="o">:</span> <span class="nx">UNIT_CHANNELS</span><span class="p">,</span>
    <span class="nx">NONPOSITION_CHANNELS</span><span class="o">:</span> <span class="nx">NONPOSITION_CHANNELS</span><span class="p">,</span>
    <span class="nx">POSITION_SCALE_CHANNELS</span><span class="o">:</span> <span class="nx">POSITION_SCALE_CHANNELS</span><span class="p">,</span>
    <span class="nx">NONPOSITION_SCALE_CHANNELS</span><span class="o">:</span> <span class="nx">NONPOSITION_SCALE_CHANNELS</span><span class="p">,</span>
    <span class="nx">SCALE_CHANNELS</span><span class="o">:</span> <span class="nx">SCALE_CHANNELS</span><span class="p">,</span>
    <span class="nx">isScaleChannel</span><span class="o">:</span> <span class="nx">isScaleChannel</span><span class="p">,</span>
    <span class="nx">supportMark</span><span class="o">:</span> <span class="nx">supportMark</span><span class="p">,</span>
    <span class="nx">getSupportedMark</span><span class="o">:</span> <span class="nx">getSupportedMark</span><span class="p">,</span>
    <span class="nx">rangeType</span><span class="o">:</span> <span class="nx">rangeType</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">binToString</span><span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isBoolean</span><span class="p">(</span><span class="nx">bin</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;bin&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="s1">&#39;bin&#39;</span> <span class="o">+</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">bin</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">varName</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">p</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">bin</span><span class="p">[</span><span class="nx">p</span><span class="p">]);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isBinParams</span><span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isBoolean</span><span class="p">(</span><span class="nx">bin</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">autoMaxBins</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">ROW</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">COLUMN</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SIZE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">COLOR</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">FILL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">STROKE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">OPACITY</span><span class="o">:</span>
          <span class="c1">// Facets and Size shouldn&#39;t have too many bins</span>
          <span class="c1">// We choose 6 like shape to simplify the rule</span>
          <span class="k">case</span> <span class="nx">SHAPE</span><span class="o">:</span>
              <span class="k">return</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// Vega&#39;s &quot;shape&quot; has 6 distinct values</span>
          <span class="k">default</span><span class="o">:</span>
              <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">bin</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">binToString</span><span class="o">:</span> <span class="nx">binToString</span><span class="p">,</span>
    <span class="nx">isBinParams</span><span class="o">:</span> <span class="nx">isBinParams</span><span class="p">,</span>
    <span class="nx">autoMaxBins</span><span class="o">:</span> <span class="nx">autoMaxBins</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">Mark</span><span class="p">;</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">Mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">AREA</span> <span class="o">=</span> <span class="s1">&#39;area&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">BAR</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">LINE</span> <span class="o">=</span> <span class="s1">&#39;line&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">POINT</span> <span class="o">=</span> <span class="s1">&#39;point&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">RECT</span> <span class="o">=</span> <span class="s1">&#39;rect&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">RULE</span> <span class="o">=</span> <span class="s1">&#39;rule&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">TEXT</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">TICK</span> <span class="o">=</span> <span class="s1">&#39;tick&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">TRAIL</span> <span class="o">=</span> <span class="s1">&#39;trail&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">CIRCLE</span> <span class="o">=</span> <span class="s1">&#39;circle&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">SQUARE</span> <span class="o">=</span> <span class="s1">&#39;square&#39;</span><span class="p">;</span>
      <span class="nx">Mark</span><span class="p">.</span><span class="nx">GEOSHAPE</span> <span class="o">=</span> <span class="s1">&#39;geoshape&#39;</span><span class="p">;</span>
  <span class="p">})(</span><span class="nx">Mark</span> <span class="o">||</span> <span class="p">(</span><span class="nx">Mark</span> <span class="o">=</span> <span class="p">{}));</span>
  <span class="kd">var</span> <span class="nx">AREA</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">AREA</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">BAR</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">BAR</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">LINE</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">LINE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">POINT</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">POINT</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TEXT$1</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">TEXT</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TICK</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">TICK</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TRAIL</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">TRAIL</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">RECT</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">RECT</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">RULE</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">RULE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">GEOSHAPE</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">GEOSHAPE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">CIRCLE</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">CIRCLE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">SQUARE</span> <span class="o">=</span> <span class="nx">Mark</span><span class="p">.</span><span class="nx">SQUARE</span><span class="p">;</span>
  <span class="c1">// Using mapped type to declare index, ensuring we always have all marks when we add more.</span>
  <span class="kd">var</span> <span class="nx">MARK_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">area</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">bar</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">line</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">point</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">text</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">tick</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">trail</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">rect</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">geoshape</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">rule</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">circle</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">square</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">isMark</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">MARK_INDEX</span><span class="p">[</span><span class="nx">m</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isPathMark</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;trail&#39;</span><span class="p">],</span> <span class="nx">m</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">PRIMITIVE_MARKS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">MARK_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mark</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">PRIMITIVE_MARK_INDEX</span> <span class="o">=</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">PRIMITIVE_MARKS</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isPrimitiveMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">markType</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">mark</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">markType</span> <span class="k">in</span> <span class="nx">PRIMITIVE_MARK_INDEX</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">STROKE_CONFIG</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;strokeWidth&#39;</span><span class="p">,</span>
      <span class="s1">&#39;strokeDash&#39;</span><span class="p">,</span> <span class="s1">&#39;strokeDashOffset&#39;</span><span class="p">,</span> <span class="s1">&#39;strokeOpacity&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">FILL_CONFIG</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;fillOpacity&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">FILL_STROKE_CONFIG</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">STROKE_CONFIG</span><span class="p">,</span> <span class="nx">FILL_CONFIG</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">area</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">],</span>
      <span class="nx">bar</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;binSpacing&#39;</span><span class="p">,</span> <span class="s1">&#39;continuousBandSize&#39;</span><span class="p">,</span> <span class="s1">&#39;discreteBandSize&#39;</span><span class="p">],</span>
      <span class="nx">line</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;point&#39;</span><span class="p">],</span>
      <span class="nx">text</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;shortTimeLabels&#39;</span><span class="p">],</span>
      <span class="nx">tick</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;bandSize&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">]</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">defaultMarkConfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;#4c78a8&#39;</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">defaultBarConfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">binSpacing</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">continuousBandSize</span><span class="o">:</span> <span class="mi">5</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">defaultTickConfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">thickness</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">get</span> <span class="nx">Mark</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Mark</span><span class="p">;</span> <span class="p">},</span>
    <span class="nx">AREA</span><span class="o">:</span> <span class="nx">AREA</span><span class="p">,</span>
    <span class="nx">BAR</span><span class="o">:</span> <span class="nx">BAR</span><span class="p">,</span>
    <span class="nx">LINE</span><span class="o">:</span> <span class="nx">LINE</span><span class="p">,</span>
    <span class="nx">POINT</span><span class="o">:</span> <span class="nx">POINT</span><span class="p">,</span>
    <span class="nx">TEXT</span><span class="o">:</span> <span class="nx">TEXT$1</span><span class="p">,</span>
    <span class="nx">TICK</span><span class="o">:</span> <span class="nx">TICK</span><span class="p">,</span>
    <span class="nx">TRAIL</span><span class="o">:</span> <span class="nx">TRAIL</span><span class="p">,</span>
    <span class="nx">RECT</span><span class="o">:</span> <span class="nx">RECT</span><span class="p">,</span>
    <span class="nx">RULE</span><span class="o">:</span> <span class="nx">RULE</span><span class="p">,</span>
    <span class="nx">GEOSHAPE</span><span class="o">:</span> <span class="nx">GEOSHAPE</span><span class="p">,</span>
    <span class="nx">CIRCLE</span><span class="o">:</span> <span class="nx">CIRCLE</span><span class="p">,</span>
    <span class="nx">SQUARE</span><span class="o">:</span> <span class="nx">SQUARE</span><span class="p">,</span>
    <span class="nx">isMark</span><span class="o">:</span> <span class="nx">isMark</span><span class="p">,</span>
    <span class="nx">isPathMark</span><span class="o">:</span> <span class="nx">isPathMark</span><span class="p">,</span>
    <span class="nx">PRIMITIVE_MARKS</span><span class="o">:</span> <span class="nx">PRIMITIVE_MARKS</span><span class="p">,</span>
    <span class="nx">isMarkDef</span><span class="o">:</span> <span class="nx">isMarkDef</span><span class="p">,</span>
    <span class="nx">isPrimitiveMark</span><span class="o">:</span> <span class="nx">isPrimitiveMark</span><span class="p">,</span>
    <span class="nx">STROKE_CONFIG</span><span class="o">:</span> <span class="nx">STROKE_CONFIG</span><span class="p">,</span>
    <span class="nx">FILL_CONFIG</span><span class="o">:</span> <span class="nx">FILL_CONFIG</span><span class="p">,</span>
    <span class="nx">FILL_STROKE_CONFIG</span><span class="o">:</span> <span class="nx">FILL_STROKE_CONFIG</span><span class="p">,</span>
    <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES</span><span class="o">:</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES</span><span class="p">,</span>
    <span class="nx">VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="o">:</span> <span class="nx">VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="p">,</span>
    <span class="nx">defaultMarkConfig</span><span class="o">:</span> <span class="nx">defaultMarkConfig</span><span class="p">,</span>
    <span class="nx">defaultBarConfig</span><span class="o">:</span> <span class="nx">defaultBarConfig</span><span class="p">,</span>
    <span class="nx">defaultTickConfig</span><span class="o">:</span> <span class="nx">defaultTickConfig</span>
  <span class="p">});</span>

  <span class="cm">/**</span>
<span class="cm">   * Vega-Lite&#39;s singleton logger utility.</span>
<span class="cm">   */</span>
  <span class="cm">/**</span>
<span class="cm">   * Main (default) Vega Logger instance for Vega-Lite</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">logger</span><span class="p">(</span><span class="nx">Warn</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">main</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Set the singleton logger to be a custom logger</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">set</span><span class="p">(</span><span class="nx">newLogger</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">newLogger</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">current</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Reset the main logger to use the default Vega Logger</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">reset</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">current</span> <span class="o">=</span> <span class="nx">main</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">current</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">warn</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">_</span><span class="p">[</span><span class="nx">_i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="nx">current</span><span class="p">.</span><span class="nx">warn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">debug</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">_</span><span class="p">[</span><span class="nx">_i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="nx">current</span><span class="p">.</span><span class="nx">debug</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Collection of all Vega-Lite Error Messages</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">message</span><span class="p">;</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">INVALID_SPEC</span> <span class="o">=</span> <span class="s1">&#39;Invalid spec&#39;</span><span class="p">;</span>
      <span class="c1">// FIT</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">FIT_NON_SINGLE</span> <span class="o">=</span> <span class="s1">&#39;Autosize &quot;fit&quot; only works for single views and layered views.&#39;</span><span class="p">;</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">CANNOT_FIX_RANGE_STEP_WITH_FIT</span> <span class="o">=</span> <span class="s1">&#39;Cannot use a fixed value of &quot;rangeStep&quot; when &quot;autosize&quot; is &quot;fit&quot;.&#39;</span><span class="p">;</span>
      <span class="c1">// SELECTION</span>
      <span class="kd">function</span> <span class="nx">cannotProjectOnChannelWithoutField</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot project a selection on encoding channel \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot;, which has no field.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">cannotProjectOnChannelWithoutField</span> <span class="o">=</span> <span class="nx">cannotProjectOnChannelWithoutField</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">nearestNotSupportForContinuous</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;The \&quot;nearest\&quot; transform is not supported for &quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot; marks.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">nearestNotSupportForContinuous</span> <span class="o">=</span> <span class="nx">nearestNotSupportForContinuous</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">selectionNotFound</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot find a selection named \&quot;&quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;\&quot;&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">selectionNotFound</span> <span class="o">=</span> <span class="nx">selectionNotFound</span><span class="p">;</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">SCALE_BINDINGS_CONTINUOUS</span> <span class="o">=</span> <span class="s1">&#39;Scale bindings are currently only supported for scales with unbinned, continuous domains.&#39;</span><span class="p">;</span>
      <span class="c1">// REPEAT</span>
      <span class="kd">function</span> <span class="nx">noSuchRepeatedValue</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Unknown repeated value \&quot;&quot;</span> <span class="o">+</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot;\&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">noSuchRepeatedValue</span> <span class="o">=</span> <span class="nx">noSuchRepeatedValue</span><span class="p">;</span>
      <span class="c1">// CONCAT</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">CONCAT_CANNOT_SHARE_AXIS</span> <span class="o">=</span> <span class="s1">&#39;Axes cannot be shared in concatenated views.&#39;</span><span class="p">;</span>
      <span class="c1">// REPEAT</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">REPEAT_CANNOT_SHARE_AXIS</span> <span class="o">=</span> <span class="s1">&#39;Axes cannot be shared in repeated views.&#39;</span><span class="p">;</span>
      <span class="c1">// TITLE</span>
      <span class="kd">function</span> <span class="nx">cannotSetTitleAnchor</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot set title \&quot;anchor\&quot; for a &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; spec&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">cannotSetTitleAnchor</span> <span class="o">=</span> <span class="nx">cannotSetTitleAnchor</span><span class="p">;</span>
      <span class="c1">// DATA</span>
      <span class="kd">function</span> <span class="nx">unrecognizedParse</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Unrecognized parse \&quot;&quot;</span> <span class="o">+</span> <span class="nx">p</span> <span class="o">+</span> <span class="s2">&quot;\&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">unrecognizedParse</span> <span class="o">=</span> <span class="nx">unrecognizedParse</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">differentParse</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">local</span><span class="p">,</span> <span class="nx">ancestor</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;An ancestor parsed field \&quot;&quot;</span> <span class="o">+</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot;\&quot; as &quot;</span> <span class="o">+</span> <span class="nx">ancestor</span> <span class="o">+</span> <span class="s2">&quot; but a child wants to parse the field as &quot;</span> <span class="o">+</span> <span class="nx">local</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">differentParse</span> <span class="o">=</span> <span class="nx">differentParse</span><span class="p">;</span>
      <span class="c1">// TRANSFORMS</span>
      <span class="kd">function</span> <span class="nx">invalidTransformIgnored</span><span class="p">(</span><span class="nx">transform</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Ignoring an invalid transform: &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">transform</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">invalidTransformIgnored</span> <span class="o">=</span> <span class="nx">invalidTransformIgnored</span><span class="p">;</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">NO_FIELDS_NEEDS_AS</span> <span class="o">=</span> <span class="s1">&#39;If &quot;from.fields&quot; is not specified, &quot;as&quot; has to be a string that specifies the key to be used for the data from the secondary source.&#39;</span><span class="p">;</span>
      <span class="c1">// ENCODING &amp; FACET</span>
      <span class="kd">function</span> <span class="nx">encodingOverridden</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Layer&#39;s shared &quot;</span> <span class="o">+</span> <span class="nx">channels</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; channel &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">channels</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">?</span> <span class="s1">&#39;is&#39;</span> <span class="o">:</span> <span class="s1">&#39;are&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; overriden&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">encodingOverridden</span> <span class="o">=</span> <span class="nx">encodingOverridden</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">projectionOverridden</span><span class="p">(</span><span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">parentProjection</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">parentProjection</span><span class="p">,</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">projection</span><span class="p">;</span>
          <span class="k">return</span> <span class="s2">&quot;Layer&#39;s shared projection &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">parentProjection</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is overridden by a child projection &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">projection</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">projectionOverridden</span> <span class="o">=</span> <span class="nx">projectionOverridden</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">primitiveChannelDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Channel &quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; is a &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot;. Converted to {value: &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">primitiveChannelDef</span> <span class="o">=</span> <span class="nx">primitiveChannelDef</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">invalidFieldType</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Invalid field type \&quot;&quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot;\&quot;&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">invalidFieldType</span> <span class="o">=</span> <span class="nx">invalidFieldType</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">nonZeroScaleUsedWithLengthMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scaleText</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">scaleType</span> <span class="o">?</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">scaleType</span> <span class="o">+</span> <span class="s2">&quot; scale&quot;</span> <span class="o">:</span>
              <span class="nx">opt</span><span class="p">.</span><span class="nx">zeroFalse</span> <span class="o">?</span> <span class="s1">&#39;scale with zero=false&#39;</span> <span class="o">:</span>
                  <span class="s1">&#39;scale with custom domain that excludes zero&#39;</span><span class="p">;</span>
          <span class="k">return</span> <span class="s2">&quot;A &quot;</span> <span class="o">+</span> <span class="nx">scaleText</span> <span class="o">+</span> <span class="s2">&quot; is used with &quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot; mark. This can be misleading as the &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of the &quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot; can be arbitrary based on the scale domain. You may want to use point mark instead.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">nonZeroScaleUsedWithLengthMark</span> <span class="o">=</span> <span class="nx">nonZeroScaleUsedWithLengthMark</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">invalidFieldTypeForCountAggregate</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Invalid field type \&quot;&quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot;\&quot; for aggregate: \&quot;&quot;</span> <span class="o">+</span> <span class="nx">aggregate</span> <span class="o">+</span> <span class="s2">&quot;\&quot;, using \&quot;quantitative\&quot; instead.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">invalidFieldTypeForCountAggregate</span> <span class="o">=</span> <span class="nx">invalidFieldTypeForCountAggregate</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">invalidAggregate</span><span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Invalid aggregation operator \&quot;&quot;</span> <span class="o">+</span> <span class="nx">aggregate</span> <span class="o">+</span> <span class="s2">&quot;\&quot;&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">invalidAggregate</span> <span class="o">=</span> <span class="nx">invalidAggregate</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">emptyOrInvalidFieldType</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">newType</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Invalid field type \&quot;&quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot;\&quot; for channel \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot;, using \&quot;&quot;</span> <span class="o">+</span> <span class="nx">newType</span> <span class="o">+</span> <span class="s2">&quot;\&quot; instead.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">emptyOrInvalidFieldType</span> <span class="o">=</span> <span class="nx">emptyOrInvalidFieldType</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">droppingColor</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fill</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">fill</span><span class="p">,</span> <span class="nx">stroke</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">stroke</span><span class="p">;</span>
          <span class="k">return</span> <span class="s2">&quot;Dropping color &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; as the plot also has &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">fill</span> <span class="o">&amp;&amp;</span> <span class="nx">stroke</span> <span class="o">?</span> <span class="s1">&#39;fill and stroke&#39;</span> <span class="o">:</span> <span class="nx">fill</span> <span class="o">?</span> <span class="s1">&#39;fill&#39;</span> <span class="o">:</span> <span class="s1">&#39;stroke&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">droppingColor</span> <span class="o">=</span> <span class="nx">droppingColor</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">emptyFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Dropping &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; from channel \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot; since it does not contain data field or value.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">emptyFieldDef</span> <span class="o">=</span> <span class="nx">emptyFieldDef</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">latLongDeprecated</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">newChannel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;-encoding with type &quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; is deprecated. Replacing with &quot;</span> <span class="o">+</span> <span class="nx">newChannel</span> <span class="o">+</span> <span class="s2">&quot;-encoding.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">latLongDeprecated</span> <span class="o">=</span> <span class="nx">latLongDeprecated</span><span class="p">;</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">LINE_WITH_VARYING_SIZE</span> <span class="o">=</span> <span class="s1">&#39;Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.&#39;</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">incompatibleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">markOrFacet</span><span class="p">,</span> <span class="nx">when</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; dropped as it is incompatible with \&quot;&quot;</span> <span class="o">+</span> <span class="nx">markOrFacet</span> <span class="o">+</span> <span class="s2">&quot;\&quot;&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">when</span> <span class="o">?</span> <span class="s2">&quot; when &quot;</span> <span class="o">+</span> <span class="nx">when</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">incompatibleChannel</span> <span class="o">=</span> <span class="nx">incompatibleChannel</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">invalidEncodingChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;-encoding is dropped as &quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; is not a valid encoding channel.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">invalidEncodingChannel</span> <span class="o">=</span> <span class="nx">invalidEncodingChannel</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">facetChannelShouldBeDiscrete</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; encoding should be discrete (ordinal / nominal / binned).&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">facetChannelShouldBeDiscrete</span> <span class="o">=</span> <span class="nx">facetChannelShouldBeDiscrete</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">discreteChannelCannotEncode</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Using discrete channel \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot; to encode \&quot;&quot;</span> <span class="o">+</span> <span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot;\&quot; field can be misleading as it does not encode &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;ordinal&#39;</span> <span class="o">?</span> <span class="s1">&#39;order&#39;</span> <span class="o">:</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">discreteChannelCannotEncode</span> <span class="o">=</span> <span class="nx">discreteChannelCannotEncode</span><span class="p">;</span>
      <span class="c1">// Mark</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL</span> <span class="o">=</span> <span class="s1">&#39;Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.&#39;</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">lineWithRange</span><span class="p">(</span><span class="nx">hasX2</span><span class="p">,</span> <span class="nx">hasY2</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channels</span> <span class="o">=</span> <span class="nx">hasX2</span> <span class="o">&amp;&amp;</span> <span class="nx">hasY2</span> <span class="o">?</span> <span class="s1">&#39;x2 and y2&#39;</span> <span class="o">:</span> <span class="nx">hasX2</span> <span class="o">?</span> <span class="s1">&#39;x2&#39;</span> <span class="o">:</span> <span class="s1">&#39;y2&#39;</span><span class="p">;</span>
          <span class="k">return</span> <span class="s2">&quot;Line mark is for continuous lines and thus cannot be used with &quot;</span> <span class="o">+</span> <span class="nx">channels</span> <span class="o">+</span> <span class="s2">&quot;. We will use the rule mark (line segments) instead.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">lineWithRange</span> <span class="o">=</span> <span class="nx">lineWithRange</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">unclearOrientContinuous</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot clearly determine orientation for \&quot;&quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot;\&quot; since both x and y channel encode continuous fields. In this case, we use vertical by default&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">unclearOrientContinuous</span> <span class="o">=</span> <span class="nx">unclearOrientContinuous</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">unclearOrientDiscreteOrEmpty</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot clearly determine orientation for \&quot;&quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot;\&quot; since both x and y channel encode discrete or empty fields.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">unclearOrientDiscreteOrEmpty</span> <span class="o">=</span> <span class="nx">unclearOrientDiscreteOrEmpty</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">orientOverridden</span><span class="p">(</span><span class="nx">original</span><span class="p">,</span> <span class="nx">actual</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Specified orient \&quot;&quot;</span> <span class="o">+</span> <span class="nx">original</span> <span class="o">+</span> <span class="s2">&quot;\&quot; overridden with \&quot;&quot;</span> <span class="o">+</span> <span class="nx">actual</span> <span class="o">+</span> <span class="s2">&quot;\&quot;&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">orientOverridden</span> <span class="o">=</span> <span class="nx">orientOverridden</span><span class="p">;</span>
      <span class="c1">// SCALE</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN</span> <span class="o">=</span> <span class="s1">&#39;custom domain scale cannot be unioned with default field-based domain&#39;</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">cannotUseScalePropertyWithNonColor</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot use the scale property \&quot;&quot;</span> <span class="o">+</span> <span class="nx">prop</span> <span class="o">+</span> <span class="s2">&quot;\&quot; with non-color channel.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">cannotUseScalePropertyWithNonColor</span> <span class="o">=</span> <span class="nx">cannotUseScalePropertyWithNonColor</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">unaggregateDomainHasNoEffectForRawField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Using unaggregated domain with raw field has no effect (&quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">unaggregateDomainHasNoEffectForRawField</span> <span class="o">=</span> <span class="nx">unaggregateDomainHasNoEffectForRawField</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">unaggregateDomainWithNonSharedDomainOp</span><span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Unaggregated domain not applicable for \&quot;&quot;</span> <span class="o">+</span> <span class="nx">aggregate</span> <span class="o">+</span> <span class="s2">&quot;\&quot; since it produces values outside the origin domain of the source data.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">unaggregateDomainWithNonSharedDomainOp</span> <span class="o">=</span> <span class="nx">unaggregateDomainWithNonSharedDomainOp</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">unaggregatedDomainWithLogScale</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Unaggregated domain is currently unsupported for log scale (&quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">unaggregatedDomainWithLogScale</span> <span class="o">=</span> <span class="nx">unaggregatedDomainWithLogScale</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">cannotApplySizeToNonOrientedMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot apply size to non-oriented mark \&quot;&quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot;\&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">cannotApplySizeToNonOrientedMark</span> <span class="o">=</span> <span class="nx">cannotApplySizeToNonOrientedMark</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">rangeStepDropped</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;rangeStep for \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot; is dropped as top-level &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is provided.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">rangeStepDropped</span> <span class="o">=</span> <span class="nx">rangeStepDropped</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">scaleTypeNotWorkWithChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">defaultScaleType</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Channel \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot; does not work with \&quot;&quot;</span> <span class="o">+</span> <span class="nx">scaleType</span> <span class="o">+</span> <span class="s2">&quot;\&quot; scale. We are using \&quot;&quot;</span> <span class="o">+</span> <span class="nx">defaultScaleType</span> <span class="o">+</span> <span class="s2">&quot;\&quot; scale instead.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithChannel</span> <span class="o">=</span> <span class="nx">scaleTypeNotWorkWithChannel</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">scaleTypeNotWorkWithFieldDef</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">defaultScaleType</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;FieldDef does not work with \&quot;&quot;</span> <span class="o">+</span> <span class="nx">scaleType</span> <span class="o">+</span> <span class="s2">&quot;\&quot; scale. We are using \&quot;&quot;</span> <span class="o">+</span> <span class="nx">defaultScaleType</span> <span class="o">+</span> <span class="s2">&quot;\&quot; scale instead.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithFieldDef</span> <span class="o">=</span> <span class="nx">scaleTypeNotWorkWithFieldDef</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">scalePropertyNotWorkWithScaleType</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">propName</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;-scale&#39;s \&quot;&quot;</span> <span class="o">+</span> <span class="nx">propName</span> <span class="o">+</span> <span class="s2">&quot;\&quot; is dropped as it does not work with &quot;</span> <span class="o">+</span> <span class="nx">scaleType</span> <span class="o">+</span> <span class="s2">&quot; scale.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">scalePropertyNotWorkWithScaleType</span> <span class="o">=</span> <span class="nx">scalePropertyNotWorkWithScaleType</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">scaleTypeNotWorkWithMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Scale type \&quot;&quot;</span> <span class="o">+</span> <span class="nx">scaleType</span> <span class="o">+</span> <span class="s2">&quot;\&quot; does not work with mark \&quot;&quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot;\&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithMark</span> <span class="o">=</span> <span class="nx">scaleTypeNotWorkWithMark</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">mergeConflictingProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Conflicting &quot;</span> <span class="o">+</span> <span class="nx">propertyOf</span> <span class="o">+</span> <span class="s2">&quot; property \&quot;&quot;</span> <span class="o">+</span> <span class="nx">property</span> <span class="o">+</span> <span class="s2">&quot;\&quot; (&quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">v1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; and &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">v2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;).  Using &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">v1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">mergeConflictingProperty</span> <span class="o">=</span> <span class="nx">mergeConflictingProperty</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">independentScaleMeansIndependentGuide</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Setting the scale to be independent for \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot; means we also have to set the guide (axis or legend) to be independent.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">independentScaleMeansIndependentGuide</span> <span class="o">=</span> <span class="nx">independentScaleMeansIndependentGuide</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">domainSortDropped</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Dropping sort property &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; as unioned domains only support boolean or op &#39;count&#39;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">domainSortDropped</span> <span class="o">=</span> <span class="nx">domainSortDropped</span><span class="p">;</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">UNABLE_TO_MERGE_DOMAINS</span> <span class="o">=</span> <span class="s1">&#39;Unable to merge domains&#39;</span><span class="p">;</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">MORE_THAN_ONE_SORT</span> <span class="o">=</span> <span class="s1">&#39;Domains that should be unioned has conflicting sort properties. Sort will be set to true.&#39;</span><span class="p">;</span>
      <span class="c1">// AXIS</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">INVALID_CHANNEL_FOR_AXIS</span> <span class="o">=</span> <span class="s1">&#39;Invalid channel for axis.&#39;</span><span class="p">;</span>
      <span class="c1">// STACK</span>
      <span class="kd">function</span> <span class="nx">cannotStackRangedMark</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot stack \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;\&quot; if there is already \&quot;&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;2\&quot;&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">cannotStackRangedMark</span> <span class="o">=</span> <span class="nx">cannotStackRangedMark</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">cannotStackNonLinearScale</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Cannot stack non-linear scale (&quot;</span> <span class="o">+</span> <span class="nx">scaleType</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">cannotStackNonLinearScale</span> <span class="o">=</span> <span class="nx">cannotStackNonLinearScale</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">stackNonSummativeAggregate</span><span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Stacking is applied even though the aggregate function is non-summative (\&quot;&quot;</span> <span class="o">+</span> <span class="nx">aggregate</span> <span class="o">+</span> <span class="s2">&quot;\&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">stackNonSummativeAggregate</span> <span class="o">=</span> <span class="nx">stackNonSummativeAggregate</span><span class="p">;</span>
      <span class="c1">// TIMEUNIT</span>
      <span class="kd">function</span> <span class="nx">invalidTimeUnit</span><span class="p">(</span><span class="nx">unitName</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Invalid &quot;</span> <span class="o">+</span> <span class="nx">unitName</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">invalidTimeUnit</span> <span class="o">=</span> <span class="nx">invalidTimeUnit</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">dayReplacedWithDate</span><span class="p">(</span><span class="nx">fullTimeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Time unit \&quot;&quot;</span> <span class="o">+</span> <span class="nx">fullTimeUnit</span> <span class="o">+</span> <span class="s2">&quot;\&quot; is not supported. We are replacing it with &quot;</span> <span class="o">+</span> <span class="nx">fullTimeUnit</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">dayReplacedWithDate</span> <span class="o">=</span> <span class="nx">dayReplacedWithDate</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">droppedDay</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;Dropping day from datetime &quot;</span> <span class="o">+</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; as day cannot be combined with other units.&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">message</span><span class="p">.</span><span class="nx">droppedDay</span> <span class="o">=</span> <span class="nx">droppedDay</span><span class="p">;</span>
  <span class="p">})(</span><span class="nx">message</span> <span class="o">||</span> <span class="p">(</span><span class="nx">message</span> <span class="o">=</span> <span class="p">{}));</span>

  <span class="c1">// DateTime definition object</span>
  <span class="cm">/*</span>
<span class="cm">   * A designated year that starts on Sunday.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">SUNDAY_YEAR</span> <span class="o">=</span> <span class="mi">2006</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">isDateTime</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">o</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">year</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">quarter</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">month</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">date</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">day</span> <span class="o">||</span>
          <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">hours</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">minutes</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">seconds</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">o</span><span class="p">.</span><span class="nx">milliseconds</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">MONTHS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;january&#39;</span><span class="p">,</span> <span class="s1">&#39;february&#39;</span><span class="p">,</span> <span class="s1">&#39;march&#39;</span><span class="p">,</span> <span class="s1">&#39;april&#39;</span><span class="p">,</span> <span class="s1">&#39;may&#39;</span><span class="p">,</span> <span class="s1">&#39;june&#39;</span><span class="p">,</span> <span class="s1">&#39;july&#39;</span><span class="p">,</span> <span class="s1">&#39;august&#39;</span><span class="p">,</span> <span class="s1">&#39;september&#39;</span><span class="p">,</span> <span class="s1">&#39;october&#39;</span><span class="p">,</span> <span class="s1">&#39;november&#39;</span><span class="p">,</span> <span class="s1">&#39;december&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">SHORT_MONTHS</span> <span class="o">=</span> <span class="nx">MONTHS</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">DAYS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sunday&#39;</span><span class="p">,</span> <span class="s1">&#39;monday&#39;</span><span class="p">,</span> <span class="s1">&#39;tuesday&#39;</span><span class="p">,</span> <span class="s1">&#39;wednesday&#39;</span><span class="p">,</span> <span class="s1">&#39;thursday&#39;</span><span class="p">,</span> <span class="s1">&#39;friday&#39;</span><span class="p">,</span> <span class="s1">&#39;saturday&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">SHORT_DAYS</span> <span class="o">=</span> <span class="nx">DAYS</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">});</span>
  <span class="kd">function</span> <span class="nx">normalizeQuarter</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">q</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">q</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidTimeUnit</span><span class="p">(</span><span class="s1">&#39;quarter&#39;</span><span class="p">,</span> <span class="nx">q</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="c1">// We accept 1-based quarter, so need to readjust to 0-based quarter</span>
          <span class="k">return</span> <span class="p">(</span><span class="nx">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// Invalid quarter</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidTimeUnit</span><span class="p">(</span><span class="s1">&#39;quarter&#39;</span><span class="p">,</span> <span class="nx">q</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeMonth</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// We accept 1-based month, so need to readjust to 0-based month</span>
          <span class="k">return</span> <span class="p">(</span><span class="nx">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">lowerM</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
          <span class="kd">var</span> <span class="nx">monthIndex</span> <span class="o">=</span> <span class="nx">MONTHS</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">lowerM</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">monthIndex</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">monthIndex</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> <span class="c1">// 0 for january, ...</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">shortM</span> <span class="o">=</span> <span class="nx">lowerM</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">shortMonthIndex</span> <span class="o">=</span> <span class="nx">SHORT_MONTHS</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">shortM</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">shortMonthIndex</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">shortMonthIndex</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Invalid month</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidTimeUnit</span><span class="p">(</span><span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="nx">m</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeDay</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// mod so that this can be both 0-based where 0 = sunday</span>
          <span class="c1">// and 1-based where 7=sunday</span>
          <span class="k">return</span> <span class="p">(</span><span class="nx">d</span> <span class="o">%</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">lowerD</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
          <span class="kd">var</span> <span class="nx">dayIndex</span> <span class="o">=</span> <span class="nx">DAYS</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">lowerD</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">dayIndex</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">dayIndex</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> <span class="c1">// 0 for january, ...</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">shortD</span> <span class="o">=</span> <span class="nx">lowerD</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">shortDayIndex</span> <span class="o">=</span> <span class="nx">SHORT_DAYS</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">shortD</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">shortDayIndex</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">shortDayIndex</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Invalid day</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidTimeUnit</span><span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="nx">d</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return Vega Expression for a particular date time.</span>
<span class="cm">   * @param d</span>
<span class="cm">   * @param normalize whether to normalize quarter, month, day.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">normalize</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">normalize</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">normalize</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">units</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">normalize</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">day</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">d</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">droppedDay</span><span class="p">(</span><span class="nx">d</span><span class="p">));</span>
              <span class="nx">d</span> <span class="o">=</span> <span class="nx">duplicate</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
              <span class="k">delete</span> <span class="nx">d</span><span class="p">.</span><span class="nx">day</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">year</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">year</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">day</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Set year to 2006 for working with day since January 1 2006 is a Sunday</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">SUNDAY_YEAR</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">month</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">month</span> <span class="o">=</span> <span class="nx">normalize</span> <span class="o">?</span> <span class="nx">normalizeMonth</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">month</span><span class="p">)</span> <span class="o">:</span> <span class="nx">d</span><span class="p">.</span><span class="nx">month</span><span class="p">;</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">month</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">quarter</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">quarter</span> <span class="o">=</span> <span class="nx">normalize</span> <span class="o">?</span> <span class="nx">normalizeQuarter</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">quarter</span><span class="p">)</span> <span class="o">:</span> <span class="nx">d</span><span class="p">.</span><span class="nx">quarter</span><span class="p">;</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">quarter</span> <span class="o">+</span> <span class="s1">&#39;*3&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// months start at zero in JS</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">date</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">date</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">day</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// HACK: Day only works as a standalone unit</span>
          <span class="c1">// This is only correct because we always set year to 2006 for day</span>
          <span class="kd">var</span> <span class="nx">day</span> <span class="o">=</span> <span class="nx">normalize</span> <span class="o">?</span> <span class="nx">normalizeDay</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">day</span><span class="p">)</span> <span class="o">:</span> <span class="nx">d</span><span class="p">.</span><span class="nx">day</span><span class="p">;</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">day</span> <span class="o">+</span> <span class="s1">&#39;+1&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Date starts at 1 in JS</span>
      <span class="p">}</span>
      <span class="c1">// Note: can&#39;t use TimeUnit enum here as importing it will create</span>
      <span class="c1">// circular dependency problem!</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;hours&#39;</span><span class="p">,</span> <span class="s1">&#39;minutes&#39;</span><span class="p">,</span> <span class="s1">&#39;seconds&#39;</span><span class="p">,</span> <span class="s1">&#39;milliseconds&#39;</span><span class="p">];</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">timeUnit</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">[</span><span class="nx">timeUnit</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">d</span><span class="p">[</span><span class="nx">timeUnit</span><span class="p">]);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">units</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">utc</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;utc(&quot;</span> <span class="o">+</span> <span class="nx">units</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;datetime(&quot;</span> <span class="o">+</span> <span class="nx">units</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">datetime</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isDateTime</span><span class="o">:</span> <span class="nx">isDateTime</span><span class="p">,</span>
    <span class="nx">MONTHS</span><span class="o">:</span> <span class="nx">MONTHS</span><span class="p">,</span>
    <span class="nx">SHORT_MONTHS</span><span class="o">:</span> <span class="nx">SHORT_MONTHS</span><span class="p">,</span>
    <span class="nx">DAYS</span><span class="o">:</span> <span class="nx">DAYS</span><span class="p">,</span>
    <span class="nx">SHORT_DAYS</span><span class="o">:</span> <span class="nx">SHORT_DAYS</span><span class="p">,</span>
    <span class="nx">dateTimeExpr</span><span class="o">:</span> <span class="nx">dateTimeExpr</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">TimeUnit</span><span class="p">;</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">TimeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEAR</span> <span class="o">=</span> <span class="s1">&#39;year&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MONTH</span> <span class="o">=</span> <span class="s1">&#39;month&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">DAY</span> <span class="o">=</span> <span class="s1">&#39;day&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">DATE</span> <span class="o">=</span> <span class="s1">&#39;date&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">HOURS</span> <span class="o">=</span> <span class="s1">&#39;hours&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MINUTES</span> <span class="o">=</span> <span class="s1">&#39;minutes&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">SECONDS</span> <span class="o">=</span> <span class="s1">&#39;seconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MILLISECONDS</span> <span class="o">=</span> <span class="s1">&#39;milliseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARMONTH</span> <span class="o">=</span> <span class="s1">&#39;yearmonth&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARMONTHDATE</span> <span class="o">=</span> <span class="s1">&#39;yearmonthdate&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARMONTHDATEHOURS</span> <span class="o">=</span> <span class="s1">&#39;yearmonthdatehours&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARMONTHDATEHOURSMINUTES</span> <span class="o">=</span> <span class="s1">&#39;yearmonthdatehoursminutes&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARMONTHDATEHOURSMINUTESSECONDS</span> <span class="o">=</span> <span class="s1">&#39;yearmonthdatehoursminutesseconds&#39;</span><span class="p">;</span>
      <span class="c1">// MONTHDATE always include 29 February since we use year 0th (which is a leap year);</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MONTHDATE</span> <span class="o">=</span> <span class="s1">&#39;monthdate&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">HOURSMINUTES</span> <span class="o">=</span> <span class="s1">&#39;hoursminutes&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">HOURSMINUTESSECONDS</span> <span class="o">=</span> <span class="s1">&#39;hoursminutesseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MINUTESSECONDS</span> <span class="o">=</span> <span class="s1">&#39;minutesseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">SECONDSMILLISECONDS</span> <span class="o">=</span> <span class="s1">&#39;secondsmilliseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">QUARTER</span> <span class="o">=</span> <span class="s1">&#39;quarter&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARQUARTER</span> <span class="o">=</span> <span class="s1">&#39;yearquarter&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">QUARTERMONTH</span> <span class="o">=</span> <span class="s1">&#39;quartermonth&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEARQUARTERMONTH</span> <span class="o">=</span> <span class="s1">&#39;yearquartermonth&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEAR</span> <span class="o">=</span> <span class="s1">&#39;utcyear&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCMONTH</span> <span class="o">=</span> <span class="s1">&#39;utcmonth&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCDAY</span> <span class="o">=</span> <span class="s1">&#39;utcday&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCDATE</span> <span class="o">=</span> <span class="s1">&#39;utcdate&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCHOURS</span> <span class="o">=</span> <span class="s1">&#39;utchours&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCMINUTES</span> <span class="o">=</span> <span class="s1">&#39;utcminutes&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCSECONDS</span> <span class="o">=</span> <span class="s1">&#39;utcseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCMILLISECONDS</span> <span class="o">=</span> <span class="s1">&#39;utcmilliseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARMONTH</span> <span class="o">=</span> <span class="s1">&#39;utcyearmonth&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARMONTHDATE</span> <span class="o">=</span> <span class="s1">&#39;utcyearmonthdate&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARMONTHDATEHOURS</span> <span class="o">=</span> <span class="s1">&#39;utcyearmonthdatehours&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARMONTHDATEHOURSMINUTES</span> <span class="o">=</span> <span class="s1">&#39;utcyearmonthdatehoursminutes&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARMONTHDATEHOURSMINUTESSECONDS</span> <span class="o">=</span> <span class="s1">&#39;utcyearmonthdatehoursminutesseconds&#39;</span><span class="p">;</span>
      <span class="c1">// MONTHDATE always include 29 February since we use year 0th (which is a leap year);</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCMONTHDATE</span> <span class="o">=</span> <span class="s1">&#39;utcmonthdate&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCHOURSMINUTES</span> <span class="o">=</span> <span class="s1">&#39;utchoursminutes&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCHOURSMINUTESSECONDS</span> <span class="o">=</span> <span class="s1">&#39;utchoursminutesseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCMINUTESSECONDS</span> <span class="o">=</span> <span class="s1">&#39;utcminutesseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCSECONDSMILLISECONDS</span> <span class="o">=</span> <span class="s1">&#39;utcsecondsmilliseconds&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCQUARTER</span> <span class="o">=</span> <span class="s1">&#39;utcquarter&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARQUARTER</span> <span class="o">=</span> <span class="s1">&#39;utcyearquarter&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCQUARTERMONTH</span> <span class="o">=</span> <span class="s1">&#39;utcquartermonth&#39;</span><span class="p">;</span>
      <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">UTCYEARQUARTERMONTH</span> <span class="o">=</span> <span class="s1">&#39;utcyearquartermonth&#39;</span><span class="p">;</span>
  <span class="p">})(</span><span class="nx">TimeUnit</span> <span class="o">||</span> <span class="p">(</span><span class="nx">TimeUnit</span> <span class="o">=</span> <span class="p">{}));</span>
  <span class="cm">/** Time Unit that only corresponds to only one part of Date objects. */</span>
  <span class="kd">var</span> <span class="nx">LOCAL_SINGLE_TIMEUNIT_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">year</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">quarter</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">month</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">day</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">date</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">hours</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">minutes</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">seconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">milliseconds</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">TIMEUNIT_PARTS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">LOCAL_SINGLE_TIMEUNIT_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isLocalSingleTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">LOCAL_SINGLE_TIMEUNIT_INDEX</span><span class="p">[</span><span class="nx">timeUnit</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">UTC_SINGLE_TIMEUNIT_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">utcyear</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcquarter</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcmonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcday</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcdate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utchours</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcminutes</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcmilliseconds</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">isUtcSingleTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">UTC_SINGLE_TIMEUNIT_INDEX</span><span class="p">[</span><span class="nx">timeUnit</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">LOCAL_MULTI_TIMEUNIT_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">yearquarter</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">yearquartermonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">yearmonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">yearmonthdate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">yearmonthdatehours</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">yearmonthdatehoursminutes</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">yearmonthdatehoursminutesseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">quartermonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">monthdate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">hoursminutes</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">hoursminutesseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">minutesseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">secondsmilliseconds</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">UTC_MULTI_TIMEUNIT_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">utcyearquarter</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcyearquartermonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcyearmonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcyearmonthdate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcyearmonthdatehours</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcyearmonthdatehoursminutes</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcyearmonthdatehoursminutesseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcquartermonth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcmonthdate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utchoursminutes</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utchoursminutesseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcminutesseconds</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">utcsecondsmilliseconds</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">UTC_TIMEUNIT_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">UTC_SINGLE_TIMEUNIT_INDEX</span><span class="p">,</span> <span class="nx">UTC_MULTI_TIMEUNIT_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isUTCTimeUnit</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">UTC_TIMEUNIT_INDEX</span><span class="p">[</span><span class="nx">t</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getLocalTimeUnit</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">TIMEUNIT_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">LOCAL_SINGLE_TIMEUNIT_INDEX</span><span class="p">,</span> <span class="nx">UTC_SINGLE_TIMEUNIT_INDEX</span><span class="p">,</span> <span class="nx">LOCAL_MULTI_TIMEUNIT_INDEX</span><span class="p">,</span> <span class="nx">UTC_MULTI_TIMEUNIT_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">TIMEUNITS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">TIMEUNIT_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">isTimeUnit</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">TIMEUNIT_INDEX</span><span class="p">[</span><span class="nx">t</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">SET_DATE_METHOD</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">year</span><span class="o">:</span> <span class="s1">&#39;setFullYear&#39;</span><span class="p">,</span>
      <span class="nx">month</span><span class="o">:</span> <span class="s1">&#39;setMonth&#39;</span><span class="p">,</span>
      <span class="nx">date</span><span class="o">:</span> <span class="s1">&#39;setDate&#39;</span><span class="p">,</span>
      <span class="nx">hours</span><span class="o">:</span> <span class="s1">&#39;setHours&#39;</span><span class="p">,</span>
      <span class="nx">minutes</span><span class="o">:</span> <span class="s1">&#39;setMinutes&#39;</span><span class="p">,</span>
      <span class="nx">seconds</span><span class="o">:</span> <span class="s1">&#39;setSeconds&#39;</span><span class="p">,</span>
      <span class="nx">milliseconds</span><span class="o">:</span> <span class="s1">&#39;setMilliseconds&#39;</span><span class="p">,</span>
      <span class="c1">// Day and quarter have their own special cases</span>
      <span class="nx">quarter</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
      <span class="nx">day</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="cm">/**</span>
<span class="cm">   * Converts a date to only have the measurements relevant to the specified unit</span>
<span class="cm">   * i.e. (&#39;yearmonth&#39;, &#39;2000-12-04 07:58:14&#39;) -&gt; &#39;2000-12-01 00:00:00&#39;</span>
<span class="cm">   * Note: the base date is Jan 01 1900 00:00:00</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">convert</span><span class="p">(</span><span class="nx">unit</span><span class="p">,</span> <span class="nx">date</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">isUTC</span> <span class="o">=</span> <span class="nx">isUTCTimeUnit</span><span class="p">(</span><span class="nx">unit</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">isUTC</span> <span class="o">?</span>
          <span class="c1">// start with uniform date</span>
          <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">UTC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">:</span>
          <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">TIMEUNIT_PARTS_1</span> <span class="o">=</span> <span class="nx">TIMEUNIT_PARTS</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">TIMEUNIT_PARTS_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">timeUnitPart</span> <span class="o">=</span> <span class="nx">TIMEUNIT_PARTS_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">unit</span><span class="p">,</span> <span class="nx">timeUnitPart</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">switch</span> <span class="p">(</span><span class="nx">timeUnitPart</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">case</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">DAY</span><span class="o">:</span>
                      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Cannot convert to TimeUnits containing \&#39;day\&#39;&#39;</span><span class="p">);</span>
                  <span class="k">case</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">QUARTER</span><span class="o">:</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">dateMethods</span><span class="p">(</span><span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="nx">isUTC</span><span class="p">),</span> <span class="nx">getDateMethod_1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">getDateMethod</span><span class="p">,</span> <span class="nx">setDateMethod_1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">setDateMethod</span><span class="p">;</span>
                      <span class="c1">// indicate quarter by setting month to be the first of the quarter i.e. may (4) -&gt; april (3)</span>
                      <span class="nx">result</span><span class="p">[</span><span class="nx">setDateMethod_1</span><span class="p">]((</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">date</span><span class="p">[</span><span class="nx">getDateMethod_1</span><span class="p">]()</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
                      <span class="k">break</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">default</span><span class="o">:</span>
                      <span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">dateMethods</span><span class="p">(</span><span class="nx">timeUnitPart</span><span class="p">,</span> <span class="nx">isUTC</span><span class="p">),</span> <span class="nx">getDateMethod</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">getDateMethod</span><span class="p">,</span> <span class="nx">setDateMethod</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">setDateMethod</span><span class="p">;</span>
                      <span class="nx">result</span><span class="p">[</span><span class="nx">setDateMethod</span><span class="p">](</span><span class="nx">date</span><span class="p">[</span><span class="nx">getDateMethod</span><span class="p">]());</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">dateMethods</span><span class="p">(</span><span class="nx">singleUnit</span><span class="p">,</span> <span class="nx">isUtc</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">rawSetDateMethod</span> <span class="o">=</span> <span class="nx">SET_DATE_METHOD</span><span class="p">[</span><span class="nx">singleUnit</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">setDateMethod</span> <span class="o">=</span> <span class="nx">isUtc</span> <span class="o">?</span> <span class="s1">&#39;setUTC&#39;</span> <span class="o">+</span> <span class="nx">rawSetDateMethod</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">:</span> <span class="nx">rawSetDateMethod</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">getDateMethod</span> <span class="o">=</span> <span class="s1">&#39;get&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">isUtc</span> <span class="o">?</span> <span class="s1">&#39;UTC&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">rawSetDateMethod</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">setDateMethod</span><span class="o">:</span> <span class="nx">setDateMethod</span><span class="p">,</span> <span class="nx">getDateMethod</span><span class="o">:</span> <span class="nx">getDateMethod</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getTimeUnitParts</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">TIMEUNIT_PARTS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">parts</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">part</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">parts</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">part</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">parts</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">}</span>
  <span class="cm">/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */</span>
  <span class="kd">function</span> <span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">fullTimeUnit</span><span class="p">,</span> <span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">fullTimeUnit</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">index</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
          <span class="p">(</span><span class="nx">timeUnit</span> <span class="o">!==</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">SECONDS</span> <span class="o">||</span>
              <span class="nx">index</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span>
              <span class="nx">fullTimeUnit</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!==</span> <span class="s1">&#39;i&#39;</span> <span class="c1">// exclude milliseconds</span>
          <span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns Vega expresssion for a given timeUnit and fieldRef</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">fieldExpr</span><span class="p">(</span><span class="nx">fullTimeUnit</span><span class="p">,</span> <span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldRef</span> <span class="o">=</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">field</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">utc</span> <span class="o">=</span> <span class="nx">isUTCTimeUnit</span><span class="p">(</span><span class="nx">fullTimeUnit</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;utc&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">timeUnit</span> <span class="o">===</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">QUARTER</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// quarter starting at 0 (0,3,6,9).</span>
              <span class="k">return</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">utc</span> <span class="o">+</span> <span class="s2">&quot;quarter(&quot;</span> <span class="o">+</span> <span class="nx">fieldRef</span> <span class="o">+</span> <span class="s2">&quot;)-1)&quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">utc</span> <span class="o">+</span> <span class="nx">timeUnit</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">fieldRef</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">TIMEUNIT_PARTS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">dateExpr</span><span class="p">,</span> <span class="nx">tu</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">fullTimeUnit</span><span class="p">,</span> <span class="nx">tu</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">dateExpr</span><span class="p">[</span><span class="nx">tu</span><span class="p">]</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="nx">tu</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">dateExpr</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
      <span class="k">return</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * returns the signal expression used for axis labels for a time unit</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">formatExpression</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">shortTimeLabels</span><span class="p">,</span> <span class="nx">isUTCScale</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">dateComponents</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">expression</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">hasYear</span> <span class="o">=</span> <span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">YEAR</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">QUARTER</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// special expression for quarter as prefix</span>
          <span class="nx">expression</span> <span class="o">=</span> <span class="s2">&quot;&#39;Q&#39; + quarter(&quot;</span> <span class="o">+</span> <span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MONTH</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// By default use short month name</span>
          <span class="nx">dateComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">shortTimeLabels</span> <span class="o">!==</span> <span class="kc">false</span> <span class="o">?</span> <span class="s1">&#39;%b&#39;</span> <span class="o">:</span> <span class="s1">&#39;%B&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">DAY</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">dateComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">shortTimeLabels</span> <span class="o">?</span> <span class="s1">&#39;%a&#39;</span> <span class="o">:</span> <span class="s1">&#39;%A&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">DATE</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">dateComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;%d&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hasYear</span> <span class="o">?</span> <span class="s1">&#39;,&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">));</span> <span class="c1">// add comma if there is year</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasYear</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">dateComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">shortTimeLabels</span> <span class="o">?</span> <span class="s1">&#39;%y&#39;</span> <span class="o">:</span> <span class="s1">&#39;%Y&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">timeComponents</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">HOURS</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">timeComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;%H&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MINUTES</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">timeComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;%M&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">SECONDS</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">timeComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;%S&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">containsTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">TimeUnit</span><span class="p">.</span><span class="nx">MILLISECONDS</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">timeComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;%L&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">dateTimeComponents</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dateComponents</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">dateTimeComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dateComponents</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">timeComponents</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">dateTimeComponents</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">timeComponents</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dateTimeComponents</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">expression</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Add space between quarter and main time format</span>
              <span class="nx">expression</span> <span class="o">+=</span> <span class="s2">&quot; + &#39; &#39; + &quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// We only use utcFormat for utc scale</span>
          <span class="c1">// For utc time units, the data is already converted as a part of timeUnit transform.</span>
          <span class="c1">// Thus, utc time units should use timeFormat to avoid shifting the time twice.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isUTCScale</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">expression</span> <span class="o">+=</span> <span class="s2">&quot;utcFormat(&quot;</span> <span class="o">+</span> <span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;, &#39;&quot;</span> <span class="o">+</span> <span class="nx">dateTimeComponents</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;)&quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">expression</span> <span class="o">+=</span> <span class="s2">&quot;timeFormat(&quot;</span> <span class="o">+</span> <span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;, &#39;&quot;</span> <span class="o">+</span> <span class="nx">dateTimeComponents</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;)&quot;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// If expression is still an empty string, return undefined instead.</span>
      <span class="k">return</span> <span class="nx">expression</span> <span class="o">||</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">timeUnit</span> <span class="o">!==</span> <span class="s1">&#39;day&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">timeUnit</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">dayReplacedWithDate</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">));</span>
          <span class="k">return</span> <span class="nx">timeUnit</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">timeUnit</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">timeunit</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">get</span> <span class="nx">TimeUnit</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">TimeUnit</span><span class="p">;</span> <span class="p">},</span>
    <span class="nx">TIMEUNIT_PARTS</span><span class="o">:</span> <span class="nx">TIMEUNIT_PARTS</span><span class="p">,</span>
    <span class="nx">isLocalSingleTimeUnit</span><span class="o">:</span> <span class="nx">isLocalSingleTimeUnit</span><span class="p">,</span>
    <span class="nx">isUtcSingleTimeUnit</span><span class="o">:</span> <span class="nx">isUtcSingleTimeUnit</span><span class="p">,</span>
    <span class="nx">isUTCTimeUnit</span><span class="o">:</span> <span class="nx">isUTCTimeUnit</span><span class="p">,</span>
    <span class="nx">getLocalTimeUnit</span><span class="o">:</span> <span class="nx">getLocalTimeUnit</span><span class="p">,</span>
    <span class="nx">TIMEUNITS</span><span class="o">:</span> <span class="nx">TIMEUNITS</span><span class="p">,</span>
    <span class="nx">isTimeUnit</span><span class="o">:</span> <span class="nx">isTimeUnit</span><span class="p">,</span>
    <span class="nx">convert</span><span class="o">:</span> <span class="nx">convert</span><span class="p">,</span>
    <span class="nx">getTimeUnitParts</span><span class="o">:</span> <span class="nx">getTimeUnitParts</span><span class="p">,</span>
    <span class="nx">containsTimeUnit</span><span class="o">:</span> <span class="nx">containsTimeUnit</span><span class="p">,</span>
    <span class="nx">fieldExpr</span><span class="o">:</span> <span class="nx">fieldExpr</span><span class="p">,</span>
    <span class="nx">formatExpression</span><span class="o">:</span> <span class="nx">formatExpression</span><span class="p">,</span>
    <span class="nx">normalizeTimeUnit</span><span class="o">:</span> <span class="nx">normalizeTimeUnit</span>
  <span class="p">});</span>

  <span class="cm">/** Constants and utilities for data type */</span>
  <span class="cm">/** Data type based on level of measurement */</span>
  <span class="kd">var</span> <span class="nx">Type</span><span class="p">;</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">Type</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">QUANTITATIVE</span> <span class="o">=</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">;</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">ORDINAL</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">TEMPORAL</span> <span class="o">=</span> <span class="s1">&#39;temporal&#39;</span><span class="p">;</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">NOMINAL</span> <span class="o">=</span> <span class="s1">&#39;nominal&#39;</span><span class="p">;</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">LATITUDE</span> <span class="o">=</span> <span class="s1">&#39;latitude&#39;</span><span class="p">;</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">LONGITUDE</span> <span class="o">=</span> <span class="s1">&#39;longitude&#39;</span><span class="p">;</span>
      <span class="nx">Type</span><span class="p">.</span><span class="nx">GEOJSON</span> <span class="o">=</span> <span class="s1">&#39;geojson&#39;</span><span class="p">;</span>
  <span class="p">})(</span><span class="nx">Type</span> <span class="o">||</span> <span class="p">(</span><span class="nx">Type</span> <span class="o">=</span> <span class="p">{}));</span>
  <span class="kd">var</span> <span class="nx">TYPE_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">quantitative</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">ordinal</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">temporal</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">nominal</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">latitude</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">longitude</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">geojson</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">isType</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">TYPE_INDEX</span><span class="p">[</span><span class="nx">t</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">QUANTITATIVE</span> <span class="o">=</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">QUANTITATIVE</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">ORDINAL</span> <span class="o">=</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">ORDINAL</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TEMPORAL</span> <span class="o">=</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">TEMPORAL</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">NOMINAL</span> <span class="o">=</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">NOMINAL</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">GEOJSON</span> <span class="o">=</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">GEOJSON</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Get full, lowercase type name for a given type.</span>
<span class="cm">   * @param  type</span>
<span class="cm">   * @return Full type name.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getFullName</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
          <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">case</span> <span class="s1">&#39;q&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="nx">QUANTITATIVE</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">;</span>
              <span class="k">case</span> <span class="s1">&#39;t&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="nx">TEMPORAL</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;temporal&#39;</span><span class="p">;</span>
              <span class="k">case</span> <span class="s1">&#39;o&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="nx">ORDINAL</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
              <span class="k">case</span> <span class="s1">&#39;n&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="nx">NOMINAL</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;nominal&#39;</span><span class="p">;</span>
              <span class="k">case</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">LATITUDE</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;latitude&#39;</span><span class="p">;</span>
              <span class="k">case</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">LONGITUDE</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;longitude&#39;</span><span class="p">;</span>
              <span class="k">case</span> <span class="nx">GEOJSON</span><span class="o">:</span>
                  <span class="k">return</span> <span class="s1">&#39;geojson&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// If we get invalid input, return undefined type.</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">get</span> <span class="nx">Type</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">Type</span><span class="p">;</span> <span class="p">},</span>
    <span class="nx">TYPE_INDEX</span><span class="o">:</span> <span class="nx">TYPE_INDEX</span><span class="p">,</span>
    <span class="nx">isType</span><span class="o">:</span> <span class="nx">isType</span><span class="p">,</span>
    <span class="nx">QUANTITATIVE</span><span class="o">:</span> <span class="nx">QUANTITATIVE</span><span class="p">,</span>
    <span class="nx">ORDINAL</span><span class="o">:</span> <span class="nx">ORDINAL</span><span class="p">,</span>
    <span class="nx">TEMPORAL</span><span class="o">:</span> <span class="nx">TEMPORAL</span><span class="p">,</span>
    <span class="nx">NOMINAL</span><span class="o">:</span> <span class="nx">NOMINAL</span><span class="p">,</span>
    <span class="nx">GEOJSON</span><span class="o">:</span> <span class="nx">GEOJSON</span><span class="p">,</span>
    <span class="nx">getFullName</span><span class="o">:</span> <span class="nx">getFullName</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">isConditionalSelection</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">c</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isRepeatRef</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">field$$1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isString</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;repeat&#39;</span> <span class="k">in</span> <span class="nx">field$$1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">toFieldDefBase</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">timeUnit</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">bin</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">,</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">timeUnit</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">timeUnit</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">bin</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">bin</span><span class="o">:</span> <span class="nx">bin</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">aggregate</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="nx">aggregate</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isConditionalDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">hasConditionalValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!!</span><span class="nx">channelDef</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="nx">channelDef</span><span class="p">[</span><span class="s1">&#39;aggregate&#39;</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isStringFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;value&#39;</span> <span class="k">in</span> <span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDef</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isScaleFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!!</span><span class="nx">channelDef</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">channelDef</span><span class="p">[</span><span class="s1">&#39;sort&#39;</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isOpFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">prefix</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">prefix</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">suffix</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">suffix</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isCount</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">field$$1</span> <span class="o">=</span> <span class="s1">&#39;count_*&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">opt</span><span class="p">.</span><span class="nx">nofn</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isOpFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">fn</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">op</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fn</span> <span class="o">=</span> <span class="nx">binToString</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">);</span>
                  <span class="nx">suffix</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">binSuffix</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fn</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fn</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">field$$1</span> <span class="o">?</span> <span class="nx">fn</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">field$$1</span> <span class="o">:</span> <span class="nx">fn</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">suffix</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">suffix</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">field$$1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Expression to access flattened field. No need to escape dots.</span>
          <span class="k">return</span> <span class="nx">flatAccessWithDatum</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">expr</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// We flattened all fields so paths should have become dot.</span>
          <span class="k">return</span> <span class="nx">replacePathInField</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isDiscrete</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;nominal&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;ordinal&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;geojson&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;quantitative&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;latitude&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;longitude&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;temporal&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidFieldType</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isContinuous</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="nx">isDiscrete</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isCount</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">verbalTitleFormatter</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">bin</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">,</span> <span class="nx">timeUnit</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">countTitle</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot; (binned)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">units</span> <span class="o">=</span> <span class="nx">getTimeUnitParts</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot; (&quot;</span> <span class="o">+</span> <span class="nx">units</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">titlecase</span><span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of &quot;</span> <span class="o">+</span> <span class="nx">field$$1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">field$$1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">functionalTitleFormatter</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">||</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span> <span class="o">||</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;bin&#39;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">defaultTitleFormatter</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">fieldTitle</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;plain&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;functional&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">functionalTitleFormatter</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="k">default</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">verbalTitleFormatter</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">titleFormatter</span> <span class="o">=</span> <span class="nx">defaultTitleFormatter</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">setTitleFormatter</span><span class="p">(</span><span class="nx">formatter</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">titleFormatter</span> <span class="o">=</span> <span class="nx">formatter</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">resetTitleFormatter</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">setTitleFormatter</span><span class="p">(</span><span class="nx">defaultTitleFormatter</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">title</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">titleFormatter</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defaultType</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;temporal&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">rangeType</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;continuous&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;discrete&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;nominal&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;flexible&#39;</span><span class="o">:</span> <span class="c1">// color</span>
              <span class="k">return</span> <span class="s1">&#39;nominal&#39;</span><span class="p">;</span>
          <span class="k">default</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.</span>
<span class="cm">   * @param channelDef</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channelDef</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isBoolean</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">primitiveType</span> <span class="o">=</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;string&#39;</span> <span class="o">:</span>
              <span class="nx">isNumber</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;number&#39;</span> <span class="o">:</span> <span class="s1">&#39;boolean&#39;</span><span class="p">;</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">primitiveChannelDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">primitiveType</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">));</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">channelDef</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="c1">// If a fieldDef contains a field, we need type.</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizeFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="p">{</span> 
              <span class="c1">// Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition&lt;FieldDef&gt;</span>
              <span class="nx">condition</span><span class="o">:</span> <span class="nx">normalizeFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">channelDef</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Drop invalid aggregate</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isAggregateOp</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">,</span> <span class="nx">fieldDefWithoutAggregate</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;aggregate&quot;</span><span class="p">]);</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidAggregate</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">));</span>
          <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">fieldDefWithoutAggregate</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Normalize Time Unit</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">normalizeTimeUnit</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="c1">// Normalize bin</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">bin</span><span class="o">:</span> <span class="nx">normalizeBin</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="c1">// Normalize Type</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fullType</span> <span class="o">=</span> <span class="nx">getFullName</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="nx">fullType</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// convert short type to full type</span>
              <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">fullType</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isCountingAggregateOp</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidFieldTypeForCountAggregate</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">));</span>
                  <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;quantitative&#39;</span> <span class="p">});</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// If type is empty / invalid, then augment with default type</span>
          <span class="kd">var</span> <span class="nx">newType</span> <span class="o">=</span> <span class="nx">defaultType</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">emptyOrInvalidFieldType</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">newType</span><span class="p">));</span>
          <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">newType</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">channelCompatibility</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">),</span> <span class="nx">compatible</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">compatible</span><span class="p">,</span> <span class="nx">warning</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">warning</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">compatible</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">warning</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeBin</span><span class="p">(</span><span class="nx">bin</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isBoolean</span><span class="p">(</span><span class="nx">bin</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">maxbins</span><span class="o">:</span> <span class="nx">autoMaxBins</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">bin</span><span class="p">.</span><span class="nx">maxbins</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">bin</span><span class="p">.</span><span class="nx">step</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">bin</span><span class="p">,</span> <span class="p">{</span> <span class="nx">maxbins</span><span class="o">:</span> <span class="nx">autoMaxBins</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">bin</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">COMPATIBLE</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">compatible</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">channelCompatibility</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;row&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;column&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isContinuous</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span>
                      <span class="nx">compatible</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                      <span class="nx">warning</span><span class="o">:</span> <span class="nx">message</span><span class="p">.</span><span class="nx">facetChannelShouldBeDiscrete</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">COMPATIBLE</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;x&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;y&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;color&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;fill&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;stroke&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;text&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;detail&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;key&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;tooltip&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;href&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">COMPATIBLE</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;longitude&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;longitude2&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;latitude&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;latitude2&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">!==</span> <span class="nx">QUANTITATIVE</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span>
                      <span class="nx">compatible</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                      <span class="nx">warning</span><span class="o">:</span> <span class="s2">&quot;Channel &quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; should be used with a quantitative field only, not &quot;</span> <span class="o">+</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; field.&quot;</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">COMPATIBLE</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;opacity&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;size&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;x2&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;y2&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">((</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;nominal&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">fieldDef</span><span class="p">[</span><span class="s1">&#39;sort&#39;</span><span class="p">])</span> <span class="o">||</span> <span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;geojson&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span>
                      <span class="nx">compatible</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                      <span class="nx">warning</span><span class="o">:</span> <span class="s2">&quot;Channel &quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; should not be used with an unsorted discrete field.&quot;</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">COMPATIBLE</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;shape&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">&#39;nominal&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">&#39;geojson&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span>
                      <span class="nx">compatible</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                      <span class="nx">warning</span><span class="o">:</span> <span class="s1">&#39;Shape channel should be used with only either nominal or geojson data&#39;</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">COMPATIBLE</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;order&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;nominal&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span>
                      <span class="nx">compatible</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                      <span class="nx">warning</span><span class="o">:</span> <span class="s2">&quot;Channel order is inappropriate for nominal field, which has no inherent order.&quot;</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">COMPATIBLE</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;channelCompatability not implemented for channel &#39;</span> <span class="o">+</span> <span class="nx">channel</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isNumberFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isTimeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;temporal&#39;</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">fielddef</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isConditionalSelection</span><span class="o">:</span> <span class="nx">isConditionalSelection</span><span class="p">,</span>
    <span class="nx">isRepeatRef</span><span class="o">:</span> <span class="nx">isRepeatRef</span><span class="p">,</span>
    <span class="nx">toFieldDefBase</span><span class="o">:</span> <span class="nx">toFieldDefBase</span><span class="p">,</span>
    <span class="nx">isConditionalDef</span><span class="o">:</span> <span class="nx">isConditionalDef</span><span class="p">,</span>
    <span class="nx">hasConditionalFieldDef</span><span class="o">:</span> <span class="nx">hasConditionalFieldDef</span><span class="p">,</span>
    <span class="nx">hasConditionalValueDef</span><span class="o">:</span> <span class="nx">hasConditionalValueDef</span><span class="p">,</span>
    <span class="nx">isFieldDef</span><span class="o">:</span> <span class="nx">isFieldDef</span><span class="p">,</span>
    <span class="nx">isStringFieldDef</span><span class="o">:</span> <span class="nx">isStringFieldDef</span><span class="p">,</span>
    <span class="nx">isValueDef</span><span class="o">:</span> <span class="nx">isValueDef</span><span class="p">,</span>
    <span class="nx">isScaleFieldDef</span><span class="o">:</span> <span class="nx">isScaleFieldDef</span><span class="p">,</span>
    <span class="nx">vgField</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">,</span>
    <span class="nx">isDiscrete</span><span class="o">:</span> <span class="nx">isDiscrete</span><span class="p">,</span>
    <span class="nx">isContinuous</span><span class="o">:</span> <span class="nx">isContinuous</span><span class="p">,</span>
    <span class="nx">isCount</span><span class="o">:</span> <span class="nx">isCount</span><span class="p">,</span>
    <span class="nx">verbalTitleFormatter</span><span class="o">:</span> <span class="nx">verbalTitleFormatter</span><span class="p">,</span>
    <span class="nx">functionalTitleFormatter</span><span class="o">:</span> <span class="nx">functionalTitleFormatter</span><span class="p">,</span>
    <span class="nx">defaultTitleFormatter</span><span class="o">:</span> <span class="nx">defaultTitleFormatter</span><span class="p">,</span>
    <span class="nx">setTitleFormatter</span><span class="o">:</span> <span class="nx">setTitleFormatter</span><span class="p">,</span>
    <span class="nx">resetTitleFormatter</span><span class="o">:</span> <span class="nx">resetTitleFormatter</span><span class="p">,</span>
    <span class="nx">title</span><span class="o">:</span> <span class="nx">title</span><span class="p">,</span>
    <span class="nx">defaultType</span><span class="o">:</span> <span class="nx">defaultType</span><span class="p">,</span>
    <span class="nx">getFieldDef</span><span class="o">:</span> <span class="nx">getFieldDef</span><span class="p">,</span>
    <span class="nx">normalize</span><span class="o">:</span> <span class="nx">normalize</span><span class="p">,</span>
    <span class="nx">normalizeFieldDef</span><span class="o">:</span> <span class="nx">normalizeFieldDef</span><span class="p">,</span>
    <span class="nx">normalizeBin</span><span class="o">:</span> <span class="nx">normalizeBin</span><span class="p">,</span>
    <span class="nx">channelCompatibility</span><span class="o">:</span> <span class="nx">channelCompatibility</span><span class="p">,</span>
    <span class="nx">isNumberFieldDef</span><span class="o">:</span> <span class="nx">isNumberFieldDef</span><span class="p">,</span>
    <span class="nx">isTimeFieldDef</span><span class="o">:</span> <span class="nx">isTimeFieldDef</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span> <span class="o">&amp;&amp;</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">some</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">||</span> <span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isAggregate</span><span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">some</span><span class="p">(</span><span class="nx">CHANNELS</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">some</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">;</span> <span class="p">});</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">);</span>
                  <span class="k">return</span> <span class="nx">fieldDef</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeEncoding</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">encoding</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">normalizedEncoding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// Drop invalid channel</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidEncodingChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
              <span class="k">return</span> <span class="nx">normalizedEncoding</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">supportMark</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// Drop unsupported channel</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">incompatibleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">mark</span><span class="p">));</span>
              <span class="k">return</span> <span class="nx">normalizedEncoding</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Drop line&#39;s size if the field is aggregated.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;size&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;line&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">LINE_WITH_VARYING_SIZE</span><span class="p">);</span>
                  <span class="k">return</span> <span class="nx">normalizedEncoding</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="c1">// Drop color if either fill or stroke is specified</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;color&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="s1">&#39;fill&#39;</span> <span class="k">in</span> <span class="nx">encoding</span> <span class="o">||</span> <span class="s1">&#39;stroke&#39;</span> <span class="k">in</span> <span class="nx">encoding</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">droppingColor</span><span class="p">(</span><span class="s1">&#39;encoding&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="s1">&#39;fill&#39;</span> <span class="k">in</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">stroke</span><span class="o">:</span> <span class="s1">&#39;stroke&#39;</span> <span class="k">in</span> <span class="nx">encoding</span> <span class="p">}));</span>
              <span class="k">return</span> <span class="nx">normalizedEncoding</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;detail&#39;</span> <span class="o">||</span>
              <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;order&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="o">||</span>
              <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;tooltip&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Array of fieldDefs for detail channel (or production rule)</span>
                  <span class="nx">normalizedEncoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span> <span class="o">:</span> <span class="p">[</span><span class="nx">channelDef</span><span class="p">])</span>
                      <span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">defs</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">emptyFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="p">{</span>
                          <span class="nx">defs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">normalizeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
                      <span class="p">}</span>
                      <span class="k">return</span> <span class="nx">defs</span><span class="p">;</span>
                  <span class="p">},</span> <span class="p">[]);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">Type</span><span class="p">.</span><span class="nx">LATITUDE</span><span class="p">,</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">LONGITUDE</span><span class="p">],</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">))</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">_</span> <span class="o">=</span> <span class="nx">normalizedEncoding</span><span class="p">[</span><span class="nx">_a</span><span class="p">],</span> <span class="nx">newEncoding</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">normalizedEncoding</span><span class="p">,</span> <span class="p">[</span><span class="k">typeof</span> <span class="nx">_a</span> <span class="o">===</span> <span class="s2">&quot;symbol&quot;</span> <span class="o">?</span> <span class="nx">_a</span> <span class="o">:</span> <span class="nx">_a</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="p">]);</span>
                  <span class="kd">var</span> <span class="nx">newChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;longitude&#39;</span> <span class="o">:</span>
                      <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span> <span class="o">?</span> <span class="s1">&#39;latitude&#39;</span> <span class="o">:</span>
                          <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x2&#39;</span> <span class="o">?</span> <span class="s1">&#39;longitude2&#39;</span> <span class="o">:</span>
                              <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y2&#39;</span> <span class="o">?</span> <span class="s1">&#39;latitude2&#39;</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">latLongDeprecated</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">newChannel</span><span class="p">));</span>
                  <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">newEncoding</span><span class="p">,</span> <span class="p">(</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">newChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">),</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;quantitative&#39;</span> <span class="p">}),</span> <span class="nx">_b</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isConditionalDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">emptyFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
                  <span class="k">return</span> <span class="nx">normalizedEncoding</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="nx">normalizedEncoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">normalizedEncoding</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">_b</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isRanged</span><span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">encoding</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">!!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">fieldDefs</span><span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="nx">CHANNELS</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span> <span class="o">:</span> <span class="p">[</span><span class="nx">channelDef</span><span class="p">]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">def</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">def</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">def</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">def</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">def</span><span class="p">.</span><span class="nx">condition</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">});</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">forEach</span><span class="p">(</span><span class="nx">mapping</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">mapping</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">mapping</span><span class="p">[</span><span class="nx">channel</span><span class="p">]))</span> <span class="p">{</span>
              <span class="nx">mapping</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">channel</span><span class="p">],</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">mapping</span><span class="p">);</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">mapping</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">init</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">mapping</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">init</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">mapping</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">map</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">map</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">r1</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="nx">r1</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="p">},</span> <span class="nx">r</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisArg</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">map</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">},</span> <span class="nx">init</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">channelHasField</span><span class="o">:</span> <span class="nx">channelHasField</span><span class="p">,</span>
    <span class="nx">isAggregate</span><span class="o">:</span> <span class="nx">isAggregate</span><span class="p">,</span>
    <span class="nx">normalizeEncoding</span><span class="o">:</span> <span class="nx">normalizeEncoding</span><span class="p">,</span>
    <span class="nx">isRanged</span><span class="o">:</span> <span class="nx">isRanged</span><span class="p">,</span>
    <span class="nx">fieldDefs</span><span class="o">:</span> <span class="nx">fieldDefs</span><span class="p">,</span>
    <span class="nx">forEach</span><span class="o">:</span> <span class="nx">forEach</span><span class="p">,</span>
    <span class="nx">reduce</span><span class="o">:</span> <span class="nx">reduce</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">getMarkSpecificConfigMixins</span><span class="p">(</span><span class="nx">markSpecificConfig</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">markSpecificConfig</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="k">return</span> <span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="p">(</span><span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">},</span> <span class="nx">_a</span><span class="p">)</span> <span class="o">:</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">BOXPLOT</span> <span class="o">=</span> <span class="s1">&#39;box-plot&#39;</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">isBoxPlotDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">mark</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">BOXPLOT_STYLES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;boxWhisker&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">,</span> <span class="s1">&#39;boxMid&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">VL_ONLY_BOXPLOT_CONFIG_PROPERTY_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">box</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;extent&#39;</span><span class="p">],</span>
      <span class="nx">boxWhisker</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">],</span>
      <span class="nx">boxMid</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">supportedChannels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">,</span> <span class="s1">&#39;opacity&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">];</span>
  <span class="kd">function</span> <span class="nx">filterUnsupportedChannels</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">spec</span><span class="p">,</span> <span class="p">{</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">newEncoding</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">supportedChannels</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">newEncoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">incompatibleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">BOXPLOT</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">newEncoding</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{})</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeBoxPlot</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">spec</span> <span class="o">=</span> <span class="nx">filterUnsupportedChannels</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
      <span class="c1">// TODO: use selection</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">selection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">selection</span><span class="p">,</span> <span class="nx">_p</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">outerSpec</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="s2">&quot;selection&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">kIQRScalar</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">box</span><span class="p">.</span><span class="nx">extent</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">kIQRScalar</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">box</span><span class="p">.</span><span class="nx">extent</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isBoxPlotDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">extent</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">extent</span> <span class="o">===</span> <span class="s1">&#39;min-max&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">kIQRScalar</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">boxOrient</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">boxParams</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">orient</span><span class="p">,</span> <span class="nx">kIQRScalar</span><span class="p">),</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">transform</span><span class="p">,</span> <span class="nx">continuousAxisChannelDef</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">continuousAxisChannelDef</span><span class="p">,</span> <span class="nx">continuousAxis</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">continuousAxis</span><span class="p">,</span> <span class="nx">encodingWithoutContinuousAxis</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">encodingWithoutContinuousAxis</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">encodingWithoutContinuousAxis</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">encodingWithoutSizeColorAndContinuousAxis</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">encodingWithoutContinuousAxis</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">]);</span>
      <span class="c1">// Size encoding or the default config.box.size is applied to box and boxMid</span>
      <span class="kd">var</span> <span class="nx">sizeMixins</span> <span class="o">=</span> <span class="nx">size</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="nx">size</span> <span class="p">}</span> <span class="o">:</span> <span class="nx">getMarkSpecificConfigMixins</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">box</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">continuousAxisScaleAndAxis</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">continuousAxisScaleAndAxis</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">axis</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">continuousAxisScaleAndAxis</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">axis</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">outerSpec</span><span class="p">,</span> <span class="p">{</span> <span class="nx">transform</span><span class="o">:</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">layer</span><span class="o">:</span> <span class="p">[</span>
              <span class="p">{</span>
                  <span class="nx">mark</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;rule&#39;</span><span class="p">,</span>
                      <span class="nx">style</span><span class="o">:</span> <span class="s1">&#39;boxWhisker&#39;</span>
                  <span class="p">},</span>
                  <span class="nx">encoding</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">((</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">continuousAxis</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;lower_whisker_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span> <span class="p">},</span> <span class="nx">continuousAxisScaleAndAxis</span><span class="p">),</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">continuousAxis</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;lower_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span>
                  <span class="p">},</span> <span class="nx">_b</span><span class="p">),</span> <span class="nx">encodingWithoutSizeColorAndContinuousAxis</span><span class="p">,</span> <span class="nx">getMarkSpecificConfigMixins</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">boxWhisker</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">))</span>
              <span class="p">},</span> <span class="p">{</span>
                  <span class="nx">mark</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;rule&#39;</span><span class="p">,</span>
                      <span class="nx">style</span><span class="o">:</span> <span class="s1">&#39;boxWhisker&#39;</span>
                  <span class="p">},</span>
                  <span class="nx">encoding</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">((</span><span class="nx">_c</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">continuousAxis</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;upper_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span>
                  <span class="p">},</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">continuousAxis</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;upper_whisker_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span>
                  <span class="p">},</span> <span class="nx">_c</span><span class="p">),</span> <span class="nx">encodingWithoutSizeColorAndContinuousAxis</span><span class="p">,</span> <span class="nx">getMarkSpecificConfigMixins</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">boxWhisker</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">))</span>
              <span class="p">},</span>
              <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">selection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">selection</span><span class="o">:</span> <span class="nx">selection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">mark</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
                      <span class="nx">style</span><span class="o">:</span> <span class="s1">&#39;box&#39;</span>
                  <span class="p">},</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">((</span><span class="nx">_d</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_d</span><span class="p">[</span><span class="nx">continuousAxis</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;lower_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span>
                  <span class="p">},</span> <span class="nx">_d</span><span class="p">[</span><span class="nx">continuousAxis</span> <span class="o">+</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;upper_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span>
                  <span class="p">},</span> <span class="nx">_d</span><span class="p">),</span> <span class="nx">encodingWithoutContinuousAxis</span><span class="p">,</span> <span class="p">(</span><span class="nx">encodingWithoutContinuousAxis</span><span class="p">.</span><span class="nx">color</span> <span class="o">?</span> <span class="p">{}</span> <span class="o">:</span> <span class="nx">getMarkSpecificConfigMixins</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">box</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">)),</span> <span class="nx">sizeMixins</span><span class="p">)</span> <span class="p">}),</span>
              <span class="p">{</span>
                  <span class="nx">mark</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;tick&#39;</span><span class="p">,</span>
                      <span class="nx">style</span><span class="o">:</span> <span class="s1">&#39;boxMid&#39;</span>
                  <span class="p">},</span>
                  <span class="nx">encoding</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">((</span><span class="nx">_e</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_e</span><span class="p">[</span><span class="nx">continuousAxis</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;mid_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">type</span>
                  <span class="p">},</span> <span class="nx">_e</span><span class="p">),</span> <span class="nx">encodingWithoutSizeColorAndContinuousAxis</span><span class="p">,</span> <span class="nx">getMarkSpecificConfigMixins</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">boxMid</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">),</span> <span class="nx">sizeMixins</span><span class="p">)</span>
              <span class="p">}</span>
          <span class="p">]</span> <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">_b</span><span class="p">,</span> <span class="nx">_c</span><span class="p">,</span> <span class="nx">_d</span><span class="p">,</span> <span class="nx">_e</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">boxOrient</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">_p</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">_outerSpec</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isContinuous</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// x is continuous</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isContinuous</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// both x and y are continuous</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="nx">BOXPLOT</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="nx">BOXPLOT</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="nx">BOXPLOT</span> <span class="o">&amp;&amp;</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="nx">BOXPLOT</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Both x and y cannot have aggregate&#39;</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">isBoxPlotDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// default orientation = vertical</span>
                  <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="c1">// x is continuous but y is not</span>
          <span class="k">return</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isContinuous</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// y is continuous but x is not</span>
          <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// Neither x nor y is continuous.</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Need a valid continuous axis for boxplots&#39;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">boxContinousAxis</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">_p</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">_outerSpec</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">continuousAxisChannelDef</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">continuousAxis</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;vertical&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">continuousAxis</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
          <span class="nx">continuousAxisChannelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span> <span class="c1">// Safe to cast because if y is not continuous fielddef, the orient would not be vertical.</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">continuousAxis</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
          <span class="nx">continuousAxisChannelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">continuousAxisChannelDef</span> <span class="o">&amp;&amp;</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">,</span> <span class="nx">continuousAxisWithoutAggregate</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">continuousAxisChannelDef</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;aggregate&quot;</span><span class="p">]);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">aggregate</span> <span class="o">!==</span> <span class="nx">BOXPLOT</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="s2">&quot;Continuous axis should not have customized aggregation function &quot;</span> <span class="o">+</span> <span class="nx">aggregate</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="nx">continuousAxisChannelDef</span> <span class="o">=</span> <span class="nx">continuousAxisWithoutAggregate</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">continuousAxisChannelDef</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">,</span>
          <span class="nx">continuousAxis</span><span class="o">:</span> <span class="nx">continuousAxis</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">boxParams</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">orient</span><span class="p">,</span> <span class="nx">kIQRScalar</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">boxContinousAxis</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">orient</span><span class="p">),</span> <span class="nx">continuousAxisChannelDef</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">continuousAxisChannelDef</span><span class="p">,</span> <span class="nx">continuousAxis</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">continuousAxis</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">isMinMax</span> <span class="o">=</span> <span class="nx">kIQRScalar</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="p">[</span>
          <span class="p">{</span>
              <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;q1&#39;</span><span class="p">,</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="s1">&#39;lower_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
          <span class="p">},</span>
          <span class="p">{</span>
              <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;q3&#39;</span><span class="p">,</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="s1">&#39;upper_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
          <span class="p">},</span>
          <span class="p">{</span>
              <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="s1">&#39;mid_box_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
          <span class="p">}</span>
      <span class="p">];</span>
      <span class="kd">var</span> <span class="nx">postAggregateCalculates</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="nx">aggregate</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span>
          <span class="nx">field</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
          <span class="nx">as</span><span class="o">:</span> <span class="p">(</span><span class="nx">isMinMax</span> <span class="o">?</span> <span class="s1">&#39;lower_whisker_&#39;</span> <span class="o">:</span> <span class="s1">&#39;min_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
      <span class="p">});</span>
      <span class="nx">aggregate</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span>
          <span class="nx">field</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
          <span class="nx">as</span><span class="o">:</span> <span class="p">(</span><span class="nx">isMinMax</span> <span class="o">?</span> <span class="s1">&#39;upper_whisker_&#39;</span> <span class="o">:</span> <span class="s1">&#39;max_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
      <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isMinMax</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">postAggregateCalculates</span> <span class="o">=</span> <span class="p">[</span>
              <span class="p">{</span>
                  <span class="nx">calculate</span><span class="o">:</span> <span class="s2">&quot;datum.upper_box_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot; - datum.lower_box_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="s1">&#39;iqr_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
              <span class="p">},</span>
              <span class="p">{</span>
                  <span class="nx">calculate</span><span class="o">:</span> <span class="s2">&quot;min(datum.upper_box_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot; + datum.iqr_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot; * &quot;</span> <span class="o">+</span> <span class="nx">kIQRScalar</span> <span class="o">+</span> <span class="s2">&quot;, datum.max_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="s1">&#39;upper_whisker_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
              <span class="p">},</span>
              <span class="p">{</span>
                  <span class="nx">calculate</span><span class="o">:</span> <span class="s2">&quot;max(datum.lower_box_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot; - datum.iqr_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot; * &quot;</span> <span class="o">+</span> <span class="nx">kIQRScalar</span> <span class="o">+</span> <span class="s2">&quot;, datum.min_&quot;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="s1">&#39;lower_whisker_&#39;</span> <span class="o">+</span> <span class="nx">continuousAxisChannelDef</span><span class="p">.</span><span class="nx">field</span>
              <span class="p">}</span>
          <span class="p">];</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">groupby</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">bins</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">timeUnits</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">encodingWithoutContinuousAxis</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="nx">forEach</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">continuousAxis</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Skip continuous axis as we already handle it separately</span>
              <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">!==</span> <span class="nx">BOXPLOT</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">aggregate</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                      <span class="nx">op</span><span class="o">:</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">,</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">as</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span>
                  <span class="p">});</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">transformedField</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">);</span>
                  <span class="c1">// Add bin or timeUnit transform if applicable</span>
                  <span class="kd">var</span> <span class="nx">bin</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
                      <span class="nx">bins</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">bin</span><span class="o">:</span> <span class="nx">bin</span><span class="p">,</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span> <span class="nx">as</span><span class="o">:</span> <span class="nx">transformedField</span> <span class="p">});</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">timeUnit</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
                      <span class="nx">timeUnits</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span> <span class="nx">as</span><span class="o">:</span> <span class="nx">transformedField</span> <span class="p">});</span>
                  <span class="p">}</span>
                  <span class="nx">groupby</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">transformedField</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="c1">// now the field should refer to post-transformed field instead</span>
              <span class="nx">encodingWithoutContinuousAxis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">),</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">type</span>
              <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// For value def, just copy</span>
              <span class="nx">encodingWithoutContinuousAxis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">transform</span><span class="o">:</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">bins</span><span class="p">,</span> <span class="nx">timeUnits</span><span class="p">,</span> <span class="p">[{</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="nx">aggregate</span><span class="p">,</span> <span class="nx">groupby</span><span class="o">:</span> <span class="nx">groupby</span> <span class="p">}],</span> <span class="nx">postAggregateCalculates</span><span class="p">),</span>
          <span class="nx">continuousAxisChannelDef</span><span class="o">:</span> <span class="nx">continuousAxisChannelDef</span><span class="p">,</span>
          <span class="nx">continuousAxis</span><span class="o">:</span> <span class="nx">continuousAxis</span><span class="p">,</span>
          <span class="nx">encodingWithoutContinuousAxis</span><span class="o">:</span> <span class="nx">encodingWithoutContinuousAxis</span>
      <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">ERRORBAR</span> <span class="o">=</span> <span class="s1">&#39;error-bar&#39;</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">normalizeErrorBar</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// TODO: use selection</span>
      <span class="kd">var</span> <span class="nx">_m</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">_sel</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">selection</span><span class="p">,</span> <span class="nx">_p</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">outerSpec</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="s2">&quot;selection&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">_s</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">encodingWithoutSize</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">_x2</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">_y2</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">,</span> <span class="nx">encodingWithoutX2Y2</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="s2">&quot;y2&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">encodingWithoutX_X2_Y_Y2</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">encodingWithoutX2Y2</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Neither x2 or y2 provided&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">outerSpec</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layer</span><span class="o">:</span> <span class="p">[</span>
              <span class="p">{</span>
                  <span class="nx">mark</span><span class="o">:</span> <span class="s1">&#39;rule&#39;</span><span class="p">,</span>
                  <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encodingWithoutSize</span>
              <span class="p">},</span> <span class="p">{</span>
                  <span class="nx">mark</span><span class="o">:</span> <span class="s1">&#39;tick&#39;</span><span class="p">,</span>
                  <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encodingWithoutX2Y2</span>
              <span class="p">},</span> <span class="p">{</span>
                  <span class="nx">mark</span><span class="o">:</span> <span class="s1">&#39;tick&#39;</span><span class="p">,</span>
                  <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span> <span class="o">?</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span> <span class="p">},</span> <span class="nx">encodingWithoutX_X2_Y_Y2</span><span class="p">)</span> <span class="o">:</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span> <span class="p">},</span> <span class="nx">encodingWithoutX_X2_Y_Y2</span><span class="p">)</span>
              <span class="p">}</span>
          <span class="p">]</span> <span class="p">});</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Registry index for all composite mark&#39;s normalizer</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">normalizerRegistry</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">normalizer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">normalizerRegistry</span><span class="p">[</span><span class="nx">mark</span><span class="p">]</span> <span class="o">=</span> <span class="nx">normalizer</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="nx">normalizerRegistry</span><span class="p">[</span><span class="nx">mark</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">COMPOSITE_MARK_STYLES</span> <span class="o">=</span> <span class="nx">BOXPLOT_STYLES</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">VL_ONLY_COMPOSITE_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">VL_ONLY_BOXPLOT_CONFIG_PROPERTY_INDEX</span><span class="p">);</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">BOXPLOT</span><span class="p">,</span> <span class="nx">normalizeBoxPlot</span><span class="p">);</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">ERRORBAR</span><span class="p">,</span> <span class="nx">normalizeErrorBar</span><span class="p">);</span>
  <span class="cm">/**</span>
<span class="cm">   * Transform a unit spec with composite mark into a normal layer spec.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">normalize$1</span><span class="p">(</span>
  <span class="c1">// This GenericUnitSpec has any as Encoding because unit specs with composite mark can have additional encoding channels.</span>
  <span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">normalizer</span> <span class="o">=</span> <span class="nx">normalizerRegistry</span><span class="p">[</span><span class="nx">mark</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">normalizer</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizer</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Invalid mark type \&quot;&quot;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s2">&quot;\&quot;&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">add</span><span class="o">:</span> <span class="nx">add</span><span class="p">,</span>
    <span class="nx">remove</span><span class="o">:</span> <span class="nx">remove</span><span class="p">,</span>
    <span class="nx">COMPOSITE_MARK_STYLES</span><span class="o">:</span> <span class="nx">COMPOSITE_MARK_STYLES</span><span class="p">,</span>
    <span class="nx">VL_ONLY_COMPOSITE_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="o">:</span> <span class="nx">VL_ONLY_COMPOSITE_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="p">,</span>
    <span class="nx">normalize</span><span class="o">:</span> <span class="nx">normalize$1</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">VL_ONLY_GUIDE_CONFIG</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;shortTimeLabels&#39;</span><span class="p">];</span>

  <span class="kd">var</span> <span class="nx">defaultLegendConfig</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">var</span> <span class="nx">COMMON_LEGEND_PROPERTY_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">entryPadding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">format</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">offset</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">orient</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">padding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">tickCount</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">title</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">type</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">values</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">zindex</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">VG_LEGEND_PROPERTY_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">COMMON_LEGEND_PROPERTY_INDEX</span><span class="p">,</span> <span class="p">{</span> 
      <span class="c1">// channel scales</span>
      <span class="nx">opacity</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">shape</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">stroke</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">fill</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">size</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> 
      <span class="c1">// encode</span>
      <span class="nx">encode</span><span class="o">:</span> <span class="mi">1</span> <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">LEGEND_PROPERTIES</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">COMMON_LEGEND_PROPERTY_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">VG_LEGEND_PROPERTIES</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">VG_LEGEND_PROPERTY_INDEX</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">legend</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">defaultLegendConfig</span><span class="o">:</span> <span class="nx">defaultLegendConfig</span><span class="p">,</span>
    <span class="nx">LEGEND_PROPERTIES</span><span class="o">:</span> <span class="nx">LEGEND_PROPERTIES</span><span class="p">,</span>
    <span class="nx">VG_LEGEND_PROPERTIES</span><span class="o">:</span> <span class="nx">VG_LEGEND_PROPERTIES</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">ScaleType</span><span class="p">;</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">ScaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Continuous - Quantitative</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LINEAR</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BIN_LINEAR</span> <span class="o">=</span> <span class="s1">&#39;bin-linear&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LOG</span> <span class="o">=</span> <span class="s1">&#39;log&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">POW</span> <span class="o">=</span> <span class="s1">&#39;pow&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">SQRT</span> <span class="o">=</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">;</span>
      <span class="c1">// Continuous - Time</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">TIME</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span> <span class="o">=</span> <span class="s1">&#39;utc&#39;</span><span class="p">;</span>
      <span class="c1">// sequential</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">SEQUENTIAL</span> <span class="o">=</span> <span class="s1">&#39;sequential&#39;</span><span class="p">;</span>
      <span class="c1">// Quantile, Quantize, threshold</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">QUANTILE</span> <span class="o">=</span> <span class="s1">&#39;quantile&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">QUANTIZE</span> <span class="o">=</span> <span class="s1">&#39;quantize&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">THRESHOLD</span> <span class="o">=</span> <span class="s1">&#39;threshold&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">ORDINAL</span> <span class="o">=</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BIN_ORDINAL</span> <span class="o">=</span> <span class="s1">&#39;bin-ordinal&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">POINT</span> <span class="o">=</span> <span class="s1">&#39;point&#39;</span><span class="p">;</span>
      <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span> <span class="o">=</span> <span class="s1">&#39;band&#39;</span><span class="p">;</span>
  <span class="p">})(</span><span class="nx">ScaleType</span> <span class="o">||</span> <span class="p">(</span><span class="nx">ScaleType</span> <span class="o">=</span> <span class="p">{}));</span>
  <span class="cm">/**</span>
<span class="cm">   * Index for scale categories -- only scale of the same categories can be merged together.</span>
<span class="cm">   * Current implementation is trying to be conservative and avoid merging scale type that might not work together</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">SCALE_CATEGORY_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">linear</span><span class="o">:</span> <span class="s1">&#39;numeric&#39;</span><span class="p">,</span>
      <span class="nx">log</span><span class="o">:</span> <span class="s1">&#39;numeric&#39;</span><span class="p">,</span>
      <span class="nx">pow</span><span class="o">:</span> <span class="s1">&#39;numeric&#39;</span><span class="p">,</span>
      <span class="nx">sqrt</span><span class="o">:</span> <span class="s1">&#39;numeric&#39;</span><span class="p">,</span>
      <span class="s1">&#39;bin-linear&#39;</span><span class="o">:</span> <span class="s1">&#39;bin-linear&#39;</span><span class="p">,</span>
      <span class="nx">time</span><span class="o">:</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
      <span class="nx">utc</span><span class="o">:</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
      <span class="nx">sequential</span><span class="o">:</span> <span class="s1">&#39;sequential&#39;</span><span class="p">,</span>
      <span class="nx">ordinal</span><span class="o">:</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">,</span>
      <span class="s1">&#39;bin-ordinal&#39;</span><span class="o">:</span> <span class="s1">&#39;bin-ordinal&#39;</span><span class="p">,</span>
      <span class="nx">point</span><span class="o">:</span> <span class="s1">&#39;ordinal-position&#39;</span><span class="p">,</span>
      <span class="nx">band</span><span class="o">:</span> <span class="s1">&#39;ordinal-position&#39;</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">SCALE_TYPES</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">SCALE_CATEGORY_INDEX</span><span class="p">);</span>
  <span class="cm">/**</span>
<span class="cm">   * Whether the two given scale types can be merged together.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">scaleCompatible</span><span class="p">(</span><span class="nx">scaleType1</span><span class="p">,</span> <span class="nx">scaleType2</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleCategory1</span> <span class="o">=</span> <span class="nx">SCALE_CATEGORY_INDEX</span><span class="p">[</span><span class="nx">scaleType1</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">scaleCategory2</span> <span class="o">=</span> <span class="nx">SCALE_CATEGORY_INDEX</span><span class="p">[</span><span class="nx">scaleType2</span><span class="p">];</span>
      <span class="k">return</span> <span class="nx">scaleCategory1</span> <span class="o">===</span> <span class="nx">scaleCategory2</span> <span class="o">||</span>
          <span class="p">(</span><span class="nx">scaleCategory1</span> <span class="o">===</span> <span class="s1">&#39;ordinal-position&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleCategory2</span> <span class="o">===</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">||</span>
          <span class="p">(</span><span class="nx">scaleCategory2</span> <span class="o">===</span> <span class="s1">&#39;ordinal-position&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleCategory1</span> <span class="o">===</span> <span class="s1">&#39;time&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Index for scale precedence -- high score = higher priority for merging.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">SCALE_PRECEDENCE_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// numeric</span>
      <span class="nx">linear</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">log</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">pow</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">sqrt</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="c1">// time</span>
      <span class="nx">time</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">utc</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="c1">// ordinal-position -- these have higher precedence than continuous scales as they support more types of data</span>
      <span class="nx">point</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
      <span class="nx">band</span><span class="o">:</span> <span class="mi">11</span><span class="p">,</span>
      <span class="c1">// non grouped types</span>
      <span class="s1">&#39;bin-linear&#39;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">sequential</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">ordinal</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s1">&#39;bin-ordinal&#39;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="cm">/**</span>
<span class="cm">   * Return scale categories -- only scale of the same categories can be merged together.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">scaleTypePrecedence</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">SCALE_PRECEDENCE_INDEX</span><span class="p">[</span><span class="nx">scaleType</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">CONTINUOUS_TO_CONTINUOUS_SCALES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;bin-linear&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;pow&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;utc&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">CONTINUOUS_TO_CONTINUOUS_INDEX</span> <span class="o">=</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">CONTINUOUS_TO_CONTINUOUS_SCALES</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">CONTINUOUS_DOMAIN_SCALES</span> <span class="o">=</span> <span class="nx">CONTINUOUS_TO_CONTINUOUS_SCALES</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="s1">&#39;sequential&#39;</span> <span class="cm">/* TODO add &#39;quantile&#39;, &#39;quantize&#39;, &#39;threshold&#39;*/</span><span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">CONTINUOUS_DOMAIN_INDEX</span> <span class="o">=</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">CONTINUOUS_DOMAIN_SCALES</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">DISCRETE_DOMAIN_SCALES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ordinal&#39;</span><span class="p">,</span> <span class="s1">&#39;bin-ordinal&#39;</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="s1">&#39;band&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">DISCRETE_DOMAIN_INDEX</span> <span class="o">=</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">DISCRETE_DOMAIN_SCALES</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">BIN_SCALES_INDEX</span> <span class="o">=</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;bin-linear&#39;</span><span class="p">,</span> <span class="s1">&#39;bin-ordinal&#39;</span><span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">TIME_SCALE_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;utc&#39;</span><span class="p">];</span>
  <span class="kd">function</span> <span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">type</span> <span class="k">in</span> <span class="nx">DISCRETE_DOMAIN_INDEX</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isBinScale</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">type</span> <span class="k">in</span> <span class="nx">BIN_SCALES_INDEX</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">type</span> <span class="k">in</span> <span class="nx">CONTINUOUS_DOMAIN_INDEX</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">type</span> <span class="k">in</span> <span class="nx">CONTINUOUS_TO_CONTINUOUS_INDEX</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">defaultScaleConfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">textXRangeStep</span><span class="o">:</span> <span class="mi">90</span><span class="p">,</span>
      <span class="nx">rangeStep</span><span class="o">:</span> <span class="mi">21</span><span class="p">,</span>
      <span class="nx">pointPadding</span><span class="o">:</span> <span class="mf">0.5</span><span class="p">,</span>
      <span class="nx">bandPaddingInner</span><span class="o">:</span> <span class="mf">0.1</span><span class="p">,</span>
      <span class="nx">facetSpacing</span><span class="o">:</span> <span class="mi">16</span><span class="p">,</span>
      <span class="nx">minBandSize</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nx">minFontSize</span><span class="o">:</span> <span class="mi">8</span><span class="p">,</span>
      <span class="nx">maxFontSize</span><span class="o">:</span> <span class="mi">40</span><span class="p">,</span>
      <span class="nx">minOpacity</span><span class="o">:</span> <span class="mf">0.3</span><span class="p">,</span>
      <span class="nx">maxOpacity</span><span class="o">:</span> <span class="mf">0.8</span><span class="p">,</span>
      <span class="c1">// FIXME: revise if these *can* become ratios of rangeStep</span>
      <span class="nx">minSize</span><span class="o">:</span> <span class="mi">9</span><span class="p">,</span>
      <span class="nx">minStrokeWidth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">maxStrokeWidth</span><span class="o">:</span> <span class="mi">4</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">isExtendedScheme</span><span class="p">(</span><span class="nx">scheme</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">scheme</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">scheme</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isSelectionDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">domain</span> <span class="o">&amp;&amp;</span> <span class="nx">domain</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">SCALE_PROPERTY_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">domain</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">range</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">rangeStep</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">scheme</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="c1">// Other properties</span>
      <span class="nx">reverse</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">round</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="c1">// quantitative / time</span>
      <span class="nx">clamp</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">nice</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="c1">// quantitative</span>
      <span class="nx">base</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">exponent</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">interpolate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">zero</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="c1">// band/point</span>
      <span class="nx">padding</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">paddingInner</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">paddingOuter</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">SCALE_PROPERTIES</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">SCALE_PROPERTY_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">SCALE_PROPERTY_INDEX</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">,</span> <span class="s2">&quot;range&quot;</span><span class="p">,</span> <span class="s2">&quot;rangeStep&quot;</span><span class="p">,</span> <span class="s2">&quot;scheme&quot;</span><span class="p">]);</span>
  <span class="kd">var</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">SCALE_TYPE_INDEX</span> <span class="o">=</span> <span class="nx">generateScaleTypeIndex</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nx">scaleTypeSupportProperty</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">propName</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">propName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;type&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;domain&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;reverse&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;range&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;scheme&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;sequential&#39;</span><span class="p">,</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">,</span> <span class="s1">&#39;bin-ordinal&#39;</span><span class="p">,</span> <span class="s1">&#39;quantile&#39;</span><span class="p">,</span> <span class="s1">&#39;quantize&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;interpolate&#39;</span><span class="o">:</span>
              <span class="c1">// FIXME(https://github.com/vega/vega-lite/issues/2902) how about ordinal?</span>
              <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;bin-linear&#39;</span><span class="p">,</span> <span class="s1">&#39;pow&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;utc&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;round&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;band&#39;</span> <span class="o">||</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;point&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;padding&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="s1">&#39;band&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;paddingOuter&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;rangeStep&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="s1">&#39;band&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;paddingInner&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;band&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;clamp&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;sequential&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;nice&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;sequential&#39;</span> <span class="o">||</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;quantize&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;exponent&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;pow&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;base&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;log&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;zero&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">contains</span><span class="p">([</span>
                  <span class="s1">&#39;log&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;utc&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;bin-linear&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;threshold&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;quantile&#39;</span> <span class="c1">// quantile depends on distribution so zero does not matter</span>
              <span class="p">],</span> <span class="nx">scaleType</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach here*/</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Invalid scale property &quot;</span> <span class="o">+</span> <span class="nx">propName</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns undefined if the input channel supports the input scale property name</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">channelScalePropertyIncompatability</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">propName</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">propName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;interpolate&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;scheme&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isColorChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">message</span><span class="p">.</span><span class="nx">cannotUseScalePropertyWithNonColor</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;type&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;domain&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;range&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;base&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;exponent&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;nice&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;padding&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;paddingInner&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;paddingOuter&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;rangeStep&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;reverse&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;round&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;clamp&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;zero&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// GOOD!</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: it should never reach here */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Invalid scale property \&quot;&quot;</span> <span class="o">+</span> <span class="nx">propName</span> <span class="o">+</span> <span class="s2">&quot;\&quot;.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">scaleTypeSupportDataType</span><span class="p">(</span><span class="nx">specifiedType</span><span class="p">,</span> <span class="nx">fieldDefType</span><span class="p">,</span> <span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">Type</span><span class="p">.</span><span class="nx">ORDINAL</span><span class="p">,</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">NOMINAL</span><span class="p">],</span> <span class="nx">fieldDefType</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">specifiedType</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">specifiedType</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDefType</span> <span class="o">===</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">TEMPORAL</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">ScaleType</span><span class="p">.</span><span class="nx">TIME</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">SEQUENTIAL</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">],</span> <span class="nx">specifiedType</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDefType</span> <span class="o">===</span> <span class="nx">Type</span><span class="p">.</span><span class="nx">QUANTITATIVE</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BIN_LINEAR</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BIN_ORDINAL</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">],</span> <span class="nx">specifiedType</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LOG</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">POW</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">SQRT</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">QUANTILE</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">QUANTIZE</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">SEQUENTIAL</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">],</span> <span class="nx">specifiedType</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">channelSupportScaleType</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">X</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">Y</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">SIZE</span><span class="o">:</span> <span class="c1">// TODO: size and opacity can support ordinal with more modification</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">OPACITY</span><span class="o">:</span>
              <span class="c1">// Although it generally doesn&#39;t make sense to use band with size and opacity,</span>
              <span class="c1">// it can also work since we use band: 0.5 to get midpoint.</span>
              <span class="k">return</span> <span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;band&#39;</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">);</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">COLOR</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">FILL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">STROKE</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">scaleType</span> <span class="o">!==</span> <span class="s1">&#39;band&#39;</span><span class="p">;</span> <span class="c1">// band does not make sense with color</span>
          <span class="k">case</span> <span class="nx">Channel</span><span class="p">.</span><span class="nx">SHAPE</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span> <span class="c1">// shape = lookup only</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: it should never reach here */</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getSupportedScaleType</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDefType</span><span class="p">,</span> <span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">SCALE_TYPE_INDEX</span><span class="p">[</span><span class="nx">generateScaleTypeIndexKey</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDefType</span><span class="p">,</span> <span class="nx">bin</span><span class="p">)];</span>
  <span class="p">}</span>
  <span class="c1">// generates ScaleTypeIndex where keys are encoding channels and values are list of valid ScaleTypes</span>
  <span class="kd">function</span> <span class="nx">generateScaleTypeIndex</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">CHANNELS_1</span> <span class="o">=</span> <span class="nx">CHANNELS</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">CHANNELS_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">CHANNELS_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">TYPE_INDEX</span><span class="p">);</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDefType</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">SCALE_TYPES_1</span> <span class="o">=</span> <span class="nx">SCALE_TYPES</span><span class="p">;</span> <span class="nx">_c</span> <span class="o">&lt;</span> <span class="nx">SCALE_TYPES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">SCALE_TYPES_1</span><span class="p">[</span><span class="nx">_c</span><span class="p">];</span>
                  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_e</span> <span class="o">=</span> <span class="p">[</span><span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span> <span class="nx">_d</span> <span class="o">&lt;</span> <span class="nx">_e</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">bin</span> <span class="o">=</span> <span class="nx">_e</span><span class="p">[</span><span class="nx">_d</span><span class="p">];</span>
                      <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">generateScaleTypeIndexKey</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDefType</span><span class="p">,</span> <span class="nx">bin</span><span class="p">);</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">channelSupportScaleType</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleTypeSupportDataType</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">fieldDefType</span><span class="p">,</span> <span class="nx">bin</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">index</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">index</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">||</span> <span class="p">[];</span>
                          <span class="nx">index</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">);</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">index</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">generateScaleTypeIndexKey</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDefType</span><span class="p">,</span> <span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nx">fieldDefType</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">bin</span> <span class="o">?</span> <span class="nx">key$$1</span> <span class="o">+</span> <span class="s1">&#39;_bin&#39;</span> <span class="o">:</span> <span class="nx">key$$1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">get</span> <span class="nx">ScaleType</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">ScaleType</span><span class="p">;</span> <span class="p">},</span>
    <span class="nx">SCALE_TYPES</span><span class="o">:</span> <span class="nx">SCALE_TYPES</span><span class="p">,</span>
    <span class="nx">scaleCompatible</span><span class="o">:</span> <span class="nx">scaleCompatible</span><span class="p">,</span>
    <span class="nx">scaleTypePrecedence</span><span class="o">:</span> <span class="nx">scaleTypePrecedence</span><span class="p">,</span>
    <span class="nx">CONTINUOUS_TO_CONTINUOUS_SCALES</span><span class="o">:</span> <span class="nx">CONTINUOUS_TO_CONTINUOUS_SCALES</span><span class="p">,</span>
    <span class="nx">CONTINUOUS_DOMAIN_SCALES</span><span class="o">:</span> <span class="nx">CONTINUOUS_DOMAIN_SCALES</span><span class="p">,</span>
    <span class="nx">DISCRETE_DOMAIN_SCALES</span><span class="o">:</span> <span class="nx">DISCRETE_DOMAIN_SCALES</span><span class="p">,</span>
    <span class="nx">TIME_SCALE_TYPES</span><span class="o">:</span> <span class="nx">TIME_SCALE_TYPES</span><span class="p">,</span>
    <span class="nx">hasDiscreteDomain</span><span class="o">:</span> <span class="nx">hasDiscreteDomain</span><span class="p">,</span>
    <span class="nx">isBinScale</span><span class="o">:</span> <span class="nx">isBinScale</span><span class="p">,</span>
    <span class="nx">hasContinuousDomain</span><span class="o">:</span> <span class="nx">hasContinuousDomain</span><span class="p">,</span>
    <span class="nx">isContinuousToContinuous</span><span class="o">:</span> <span class="nx">isContinuousToContinuous</span><span class="p">,</span>
    <span class="nx">defaultScaleConfig</span><span class="o">:</span> <span class="nx">defaultScaleConfig</span><span class="p">,</span>
    <span class="nx">isExtendedScheme</span><span class="o">:</span> <span class="nx">isExtendedScheme</span><span class="p">,</span>
    <span class="nx">isSelectionDomain</span><span class="o">:</span> <span class="nx">isSelectionDomain</span><span class="p">,</span>
    <span class="nx">SCALE_PROPERTIES</span><span class="o">:</span> <span class="nx">SCALE_PROPERTIES</span><span class="p">,</span>
    <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES</span><span class="o">:</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES</span><span class="p">,</span>
    <span class="nx">SCALE_TYPE_INDEX</span><span class="o">:</span> <span class="nx">SCALE_TYPE_INDEX</span><span class="p">,</span>
    <span class="nx">scaleTypeSupportProperty</span><span class="o">:</span> <span class="nx">scaleTypeSupportProperty</span><span class="p">,</span>
    <span class="nx">channelScalePropertyIncompatability</span><span class="o">:</span> <span class="nx">channelScalePropertyIncompatability</span><span class="p">,</span>
    <span class="nx">scaleTypeSupportDataType</span><span class="o">:</span> <span class="nx">scaleTypeSupportDataType</span><span class="p">,</span>
    <span class="nx">channelSupportScaleType</span><span class="o">:</span> <span class="nx">channelSupportScaleType</span><span class="p">,</span>
    <span class="nx">getSupportedScaleType</span><span class="o">:</span> <span class="nx">getSupportedScaleType</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">SELECTION_ID</span> <span class="o">=</span> <span class="s1">&#39;_vgsid_&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">defaultConfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">single</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">on</span><span class="o">:</span> <span class="s1">&#39;click&#39;</span><span class="p">,</span>
          <span class="nx">fields</span><span class="o">:</span> <span class="p">[</span><span class="nx">SELECTION_ID</span><span class="p">],</span>
          <span class="nx">resolve</span><span class="o">:</span> <span class="s1">&#39;global&#39;</span><span class="p">,</span>
          <span class="nx">empty</span><span class="o">:</span> <span class="s1">&#39;all&#39;</span>
      <span class="p">},</span>
      <span class="nx">multi</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">on</span><span class="o">:</span> <span class="s1">&#39;click&#39;</span><span class="p">,</span>
          <span class="nx">fields</span><span class="o">:</span> <span class="p">[</span><span class="nx">SELECTION_ID</span><span class="p">],</span>
          <span class="nx">toggle</span><span class="o">:</span> <span class="s1">&#39;event.shiftKey&#39;</span><span class="p">,</span>
          <span class="nx">resolve</span><span class="o">:</span> <span class="s1">&#39;global&#39;</span><span class="p">,</span>
          <span class="nx">empty</span><span class="o">:</span> <span class="s1">&#39;all&#39;</span>
      <span class="p">},</span>
      <span class="nx">interval</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">on</span><span class="o">:</span> <span class="s1">&#39;[mousedown, window:mouseup] &gt; window:mousemove!&#39;</span><span class="p">,</span>
          <span class="nx">encodings</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
          <span class="nx">translate</span><span class="o">:</span> <span class="s1">&#39;[mousedown, window:mouseup] &gt; window:mousemove!&#39;</span><span class="p">,</span>
          <span class="nx">zoom</span><span class="o">:</span> <span class="s1">&#39;wheel!&#39;</span><span class="p">,</span>
          <span class="nx">mark</span><span class="o">:</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="s1">&#39;#333&#39;</span><span class="p">,</span> <span class="nx">fillOpacity</span><span class="o">:</span> <span class="mf">0.125</span><span class="p">,</span> <span class="nx">stroke</span><span class="o">:</span> <span class="s1">&#39;white&#39;</span> <span class="p">},</span>
          <span class="nx">resolve</span><span class="o">:</span> <span class="s1">&#39;global&#39;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">extractTitleConfig</span><span class="p">(</span><span class="nx">titleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> 
      <span class="c1">// These are non-mark title config that need to be hardcoded</span>
      <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">titleConfig</span><span class="p">.</span><span class="nx">anchor</span><span class="p">,</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">titleConfig</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">titleConfig</span><span class="p">.</span><span class="nx">orient</span><span class="p">,</span> 
      <span class="c1">// color needs to be redirect to fill</span>
      <span class="nx">color</span> <span class="o">=</span> <span class="nx">titleConfig</span><span class="p">.</span><span class="nx">color</span><span class="p">,</span> 
      <span class="c1">// The rest are mark config.</span>
      <span class="nx">titleMarkConfig</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">titleConfig</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;anchor&quot;</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="s2">&quot;orient&quot;</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">titleMarkConfig</span><span class="p">,</span> <span class="nx">color</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="nx">color</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{});</span>
      <span class="kd">var</span> <span class="nx">nonMark</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">anchor</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">anchor</span><span class="o">:</span> <span class="nx">anchor</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{},</span> <span class="nx">offset</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{},</span> <span class="nx">orient</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">orient</span><span class="o">:</span> <span class="nx">orient</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{});</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">mark</span><span class="o">:</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">nonMark</span><span class="o">:</span> <span class="nx">nonMark</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">defaultViewConfig</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">width</span><span class="o">:</span> <span class="mi">200</span><span class="p">,</span>
      <span class="nx">height</span><span class="o">:</span> <span class="mi">200</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">defaultConfig$1</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">padding</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
      <span class="nx">timeFormat</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
      <span class="nx">countTitle</span><span class="o">:</span> <span class="s1">&#39;Number of Records&#39;</span><span class="p">,</span>
      <span class="nx">invalidValues</span><span class="o">:</span> <span class="s1">&#39;filter&#39;</span><span class="p">,</span>
      <span class="nx">view</span><span class="o">:</span> <span class="nx">defaultViewConfig</span><span class="p">,</span>
      <span class="nx">mark</span><span class="o">:</span> <span class="nx">defaultMarkConfig</span><span class="p">,</span>
      <span class="nx">area</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">bar</span><span class="o">:</span> <span class="nx">defaultBarConfig</span><span class="p">,</span>
      <span class="nx">circle</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">geoshape</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">line</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">point</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">rect</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">rule</span><span class="o">:</span> <span class="p">{</span> <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;black&#39;</span> <span class="p">},</span>
      <span class="nx">square</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">text</span><span class="o">:</span> <span class="p">{</span> <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;black&#39;</span> <span class="p">},</span>
      <span class="nx">tick</span><span class="o">:</span> <span class="nx">defaultTickConfig</span><span class="p">,</span>
      <span class="nx">trail</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">box</span><span class="o">:</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="mi">14</span><span class="p">,</span> <span class="nx">extent</span><span class="o">:</span> <span class="mf">1.5</span> <span class="p">},</span>
      <span class="nx">boxWhisker</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">boxMid</span><span class="o">:</span> <span class="p">{</span> <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;white&#39;</span> <span class="p">},</span>
      <span class="nx">scale</span><span class="o">:</span> <span class="nx">defaultScaleConfig</span><span class="p">,</span>
      <span class="nx">projection</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axis</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axisX</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axisY</span><span class="o">:</span> <span class="p">{</span> <span class="nx">minExtent</span><span class="o">:</span> <span class="mi">30</span> <span class="p">},</span>
      <span class="nx">axisLeft</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axisRight</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axisTop</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axisBottom</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">axisBand</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">legend</span><span class="o">:</span> <span class="nx">defaultLegendConfig</span><span class="p">,</span>
      <span class="nx">selection</span><span class="o">:</span> <span class="nx">defaultConfig</span><span class="p">,</span>
      <span class="nx">style</span><span class="o">:</span> <span class="p">{},</span>
      <span class="nx">title</span><span class="o">:</span> <span class="p">{},</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">initConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mergeDeep</span><span class="p">(</span><span class="nx">duplicate</span><span class="p">(</span><span class="nx">defaultConfig$1</span><span class="p">),</span> <span class="nx">config</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">MARK_STYLES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;view&#39;</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">PRIMITIVE_MARKS</span><span class="p">,</span> <span class="nx">COMPOSITE_MARK_STYLES</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">VL_ONLY_CONFIG_PROPERTIES</span> <span class="o">=</span> <span class="p">[</span>
      <span class="s1">&#39;padding&#39;</span><span class="p">,</span> <span class="s1">&#39;numberFormat&#39;</span><span class="p">,</span> <span class="s1">&#39;timeFormat&#39;</span><span class="p">,</span> <span class="s1">&#39;countTitle&#39;</span><span class="p">,</span>
      <span class="s1">&#39;stack&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="s1">&#39;invalidValues&#39;</span><span class="p">,</span>
      <span class="s1">&#39;overlay&#39;</span> <span class="c1">// FIXME: Redesign and unhide this</span>
  <span class="p">];</span>
  <span class="kd">var</span> <span class="nx">VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">view</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="p">},</span> <span class="nx">VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="p">,</span> <span class="nx">VL_ONLY_COMPOSITE_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">stripAndRedirectConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">config</span> <span class="o">=</span> <span class="nx">duplicate</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VL_ONLY_CONFIG_PROPERTIES_1</span> <span class="o">=</span> <span class="nx">VL_ONLY_CONFIG_PROPERTIES</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">VL_ONLY_CONFIG_PROPERTIES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VL_ONLY_CONFIG_PROPERTIES_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">delete</span> <span class="nx">config</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="c1">// Remove Vega-Lite only axis/legend config</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">axis</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VL_ONLY_GUIDE_CONFIG_1</span> <span class="o">=</span> <span class="nx">VL_ONLY_GUIDE_CONFIG</span><span class="p">;</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">VL_ONLY_GUIDE_CONFIG_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VL_ONLY_GUIDE_CONFIG_1</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
              <span class="k">delete</span> <span class="nx">config</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">legend</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VL_ONLY_GUIDE_CONFIG_2</span> <span class="o">=</span> <span class="nx">VL_ONLY_GUIDE_CONFIG</span><span class="p">;</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">VL_ONLY_GUIDE_CONFIG_2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VL_ONLY_GUIDE_CONFIG_2</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
              <span class="k">delete</span> <span class="nx">config</span><span class="p">.</span><span class="nx">legend</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// Remove Vega-Lite only generic mark config</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES_1</span> <span class="o">=</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES</span><span class="p">;</span> <span class="nx">_c</span> <span class="o">&lt;</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES_1</span><span class="p">[</span><span class="nx">_c</span><span class="p">];</span>
              <span class="k">delete</span> <span class="nx">config</span><span class="p">.</span><span class="nx">mark</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">MARK_STYLES_1</span> <span class="o">=</span> <span class="nx">MARK_STYLES</span><span class="p">;</span> <span class="nx">_d</span> <span class="o">&lt;</span> <span class="nx">MARK_STYLES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">markType</span> <span class="o">=</span> <span class="nx">MARK_STYLES_1</span><span class="p">[</span><span class="nx">_d</span><span class="p">];</span>
          <span class="c1">// Remove Vega-Lite-only mark config</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES_2</span> <span class="o">=</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES</span><span class="p">;</span> <span class="nx">_e</span> <span class="o">&lt;</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES_2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VL_ONLY_MARK_CONFIG_PROPERTIES_2</span><span class="p">[</span><span class="nx">_e</span><span class="p">];</span>
              <span class="k">delete</span> <span class="nx">config</span><span class="p">[</span><span class="nx">markType</span><span class="p">][</span><span class="nx">prop</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="c1">// Remove Vega-Lite only mark-specific config</span>
          <span class="kd">var</span> <span class="nx">vlOnlyMarkSpecificConfigs</span> <span class="o">=</span> <span class="nx">VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX</span><span class="p">[</span><span class="nx">markType</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">vlOnlyMarkSpecificConfigs</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">vlOnlyMarkSpecificConfigs_1</span> <span class="o">=</span> <span class="nx">vlOnlyMarkSpecificConfigs</span><span class="p">;</span> <span class="nx">_f</span> <span class="o">&lt;</span> <span class="nx">vlOnlyMarkSpecificConfigs_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">vlOnlyMarkSpecificConfigs_1</span><span class="p">[</span><span class="nx">_f</span><span class="p">];</span>
                  <span class="k">delete</span> <span class="nx">config</span><span class="p">[</span><span class="nx">markType</span><span class="p">][</span><span class="nx">prop</span><span class="p">];</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="c1">// Redirect mark config to config.style so that mark config only affect its own mark type</span>
          <span class="c1">// without affecting other marks that share the same underlying Vega marks.</span>
          <span class="c1">// For example, config.rect should not affect bar marks.</span>
          <span class="nx">redirectConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span> <span class="nx">markType</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Redirect config.title -- so that title config do not</span>
      <span class="c1">// affect header labels, which also uses `title` directive to implement.</span>
      <span class="nx">redirectConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;group-title&#39;</span><span class="p">);</span>
      <span class="c1">// Remove empty config objects</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">config</span><span class="p">[</span><span class="nx">prop</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">config</span><span class="p">[</span><span class="nx">prop</span><span class="p">]).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">delete</span> <span class="nx">config</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">config</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">config</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">redirectConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="nx">toProp</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">propConfig</span> <span class="o">=</span> <span class="nx">prop</span> <span class="o">===</span> <span class="s1">&#39;title&#39;</span> <span class="o">?</span> <span class="nx">extractTitleConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">title</span><span class="p">).</span><span class="nx">mark</span> <span class="o">:</span> <span class="nx">config</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">prop</span> <span class="o">===</span> <span class="s1">&#39;view&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">toProp</span> <span class="o">=</span> <span class="s1">&#39;cell&#39;</span><span class="p">;</span> <span class="c1">// View&#39;s default style is &quot;cell&quot;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">style</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">propConfig</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">style</span><span class="p">[</span><span class="nx">prop</span><span class="p">]);</span>
      <span class="c1">// set config.style if it is not an empty object</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">style</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">config</span><span class="p">.</span><span class="nx">style</span><span class="p">[</span><span class="nx">toProp</span> <span class="o">||</span> <span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">style</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">delete</span> <span class="nx">config</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">defaultViewConfig</span><span class="o">:</span> <span class="nx">defaultViewConfig</span><span class="p">,</span>
    <span class="nx">defaultConfig</span><span class="o">:</span> <span class="nx">defaultConfig$1</span><span class="p">,</span>
    <span class="nx">initConfig</span><span class="o">:</span> <span class="nx">initConfig</span><span class="p">,</span>
    <span class="nx">stripAndRedirectConfig</span><span class="o">:</span> <span class="nx">stripAndRedirectConfig</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">STACK_OFFSET_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">zero</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">center</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">normalize</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">isStackOffset</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">STACK_OFFSET_INDEX</span><span class="p">[</span><span class="nx">s</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">STACKABLE_MARKS</span> <span class="o">=</span> <span class="p">[</span><span class="nx">BAR</span><span class="p">,</span> <span class="nx">AREA</span><span class="p">,</span> <span class="nx">RULE</span><span class="p">,</span> <span class="nx">POINT</span><span class="p">,</span> <span class="nx">CIRCLE</span><span class="p">,</span> <span class="nx">SQUARE</span><span class="p">,</span> <span class="nx">LINE</span><span class="p">,</span> <span class="nx">TEXT$1</span><span class="p">,</span> <span class="nx">TICK</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">STACK_BY_DEFAULT_MARKS</span> <span class="o">=</span> <span class="p">[</span><span class="nx">BAR</span><span class="p">,</span> <span class="nx">AREA</span><span class="p">];</span>
  <span class="kd">function</span> <span class="nx">potentialStackedChannel</span><span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">xDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">yDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">xDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">yDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">yDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">yDef</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="c1">// if there is no explicit stacking, only apply stack if there is only one aggregate for x or y</span>
              <span class="k">if</span> <span class="p">((</span><span class="o">!!</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="o">!==</span> <span class="p">(</span><span class="o">!!</span><span class="nx">yDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">xDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">yDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">xDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">xDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">yDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">yDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Note: CompassQL uses this method and only pass in required properties of each argument object.</span>
  <span class="c1">// If required properties change, make sure to update CompassQL.</span>
  <span class="kd">function</span> <span class="nx">stack</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">stackConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="o">?</span> <span class="nx">m</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">m</span><span class="p">;</span>
      <span class="c1">// Should have stackable mark</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">contains</span><span class="p">(</span><span class="nx">STACKABLE_MARKS</span><span class="p">,</span> <span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">fieldChannel</span> <span class="o">=</span> <span class="nx">potentialStackedChannel</span><span class="p">(</span><span class="nx">encoding</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fieldChannel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">stackedFieldDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">fieldChannel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">stackedField</span> <span class="o">=</span> <span class="nx">isStringFieldDef</span><span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">,</span> <span class="p">{})</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">dimensionChannel</span> <span class="o">=</span> <span class="nx">fieldChannel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;y&#39;</span> <span class="o">:</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">dimensionDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">dimensionChannel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">dimensionField</span> <span class="o">=</span> <span class="nx">isStringFieldDef</span><span class="p">(</span><span class="nx">dimensionDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionDef</span><span class="p">,</span> <span class="p">{})</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="c1">// Should have grouping level of detail that is different from the dimension field</span>
      <span class="kd">var</span> <span class="nx">stackBy</span> <span class="o">=</span> <span class="nx">NONPOSITION_CHANNELS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span> <span class="o">:</span> <span class="p">[</span><span class="nx">channelDef</span><span class="p">]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">cDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">cDef</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// Check whether the channel&#39;s field is identical to x/y&#39;s field or if the channel is a repeat</span>
                  <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">isStringFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{})</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span>
                  <span class="c1">// if fielddef is a repeat, just include it in the stack by</span>
                  <span class="o">!</span><span class="nx">f</span> <span class="o">||</span>
                      <span class="c1">// otherwise, the field must be different from x and y fields.</span>
                      <span class="p">(</span><span class="nx">f</span> <span class="o">!==</span> <span class="nx">dimensionField</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span> <span class="o">!==</span> <span class="nx">stackedField</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">sc</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">channel</span><span class="o">:</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="o">:</span> <span class="nx">fieldDef</span> <span class="p">});</span>
                  <span class="p">}</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">sc</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">[]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">stackBy</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Automatically determine offset</span>
      <span class="kd">var</span> <span class="nx">offset</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">stack</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">offset</span> <span class="o">=</span> <span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">(</span><span class="nx">STACK_BY_DEFAULT_MARKS</span><span class="p">,</span> <span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// Bar and Area with sum ops are automatically stacked by default</span>
          <span class="nx">offset</span> <span class="o">=</span> <span class="nx">stackConfig</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="s1">&#39;zero&#39;</span> <span class="o">:</span> <span class="nx">stackConfig</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">offset</span> <span class="o">=</span> <span class="nx">stackConfig</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">offset</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isStackOffset</span><span class="p">(</span><span class="nx">offset</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// warn when stacking non-linear</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">scale</span> <span class="o">&amp;&amp;</span> <span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">type</span> <span class="o">&amp;&amp;</span> <span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LINEAR</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">cannotStackNonLinearScale</span><span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">type</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="c1">// Check if it is a ranged mark</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">fieldChannel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">?</span> <span class="nx">X2</span> <span class="o">:</span> <span class="nx">Y2</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">cannotStackRangedMark</span><span class="p">(</span><span class="nx">fieldChannel</span><span class="p">));</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Warn if stacking summative aggregate</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">contains</span><span class="p">(</span><span class="nx">SUM_OPS</span><span class="p">,</span> <span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">stackNonSummativeAggregate</span><span class="p">(</span><span class="nx">stackedFieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">groupbyChannel</span><span class="o">:</span> <span class="nx">dimensionDef</span> <span class="o">?</span> <span class="nx">dimensionChannel</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
          <span class="nx">fieldChannel</span><span class="o">:</span> <span class="nx">fieldChannel</span><span class="p">,</span>
          <span class="nx">impute</span><span class="o">:</span> <span class="nx">isPathMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">),</span>
          <span class="nx">stackBy</span><span class="o">:</span> <span class="nx">stackBy</span><span class="p">,</span>
          <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span>
      <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">stack$1</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isStackOffset</span><span class="o">:</span> <span class="nx">isStackOffset</span><span class="p">,</span>
    <span class="nx">STACKABLE_MARKS</span><span class="o">:</span> <span class="nx">STACKABLE_MARKS</span><span class="p">,</span>
    <span class="nx">STACK_BY_DEFAULT_MARKS</span><span class="o">:</span> <span class="nx">STACK_BY_DEFAULT_MARKS</span><span class="p">,</span>
    <span class="nx">stack</span><span class="o">:</span> <span class="nx">stack</span>
  <span class="p">});</span>

  <span class="cm">/* Custom type guards */</span>
  <span class="kd">function</span> <span class="nx">isFacetSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">spec</span><span class="p">[</span><span class="s1">&#39;facet&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isUnitSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">spec</span><span class="p">[</span><span class="s1">&#39;mark&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">spec</span><span class="p">[</span><span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isRepeatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">spec</span><span class="p">[</span><span class="s1">&#39;repeat&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isVConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isHConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isVConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">spec</span><span class="p">[</span><span class="s1">&#39;vconcat&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isHConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">spec</span><span class="p">[</span><span class="s1">&#39;hconcat&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Decompose extended unit specs into composition of pure unit specs.</span>
<span class="cm">   */</span>
  <span class="c1">// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize</span>
  <span class="kd">function</span> <span class="nx">normalize$2</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizeFacet</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizeLayer</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isRepeatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizeRepeat</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isVConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizeVConcat</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isHConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalizeHConcat</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">hasRow</span> <span class="o">=</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">ROW</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">hasColumn</span> <span class="o">=</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">COLUMN</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasRow</span> <span class="o">||</span> <span class="nx">hasColumn</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">normalizeFacetedUnit</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">normalizeNonFacetUnit</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">INVALID_SPEC</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeFacet</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">subspec</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">]);</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">rest</span><span class="p">,</span> <span class="p">{</span> 
          <span class="c1">// TODO: remove &quot;any&quot; once we support all facet listed in https://github.com/vega/vega-lite/issues/2760</span>
          <span class="nx">spec</span><span class="o">:</span> <span class="nx">normalize$2</span><span class="p">(</span><span class="nx">subspec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeEncoding</span><span class="p">(</span><span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">parentEncoding</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">parentEncoding</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parentEncoding</span> <span class="o">&amp;&amp;</span> <span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">overriden</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">parentEncoding</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">key$$1</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">])</span> <span class="p">{</span>
                  <span class="nx">o</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">key$$1</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">[]);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">overriden</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">encodingOverridden</span><span class="p">(</span><span class="nx">overriden</span><span class="p">));</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">merged</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">parentEncoding</span> <span class="o">||</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">encoding</span> <span class="o">||</span> <span class="p">{}));</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">merged</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">merged</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeProjection</span><span class="p">(</span><span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">parentProjection</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">parentProjection</span><span class="p">,</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">projection</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parentProjection</span> <span class="o">&amp;&amp;</span> <span class="nx">projection</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">projectionOverridden</span><span class="p">({</span> <span class="nx">parentProjection</span><span class="o">:</span> <span class="nx">parentProjection</span><span class="p">,</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">projection</span> <span class="p">}));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">projection</span> <span class="o">||</span> <span class="nx">parentProjection</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeLayer</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">parentEncoding</span><span class="p">,</span> <span class="nx">parentProjection</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">layer</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;layer&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">mergedEncoding</span> <span class="o">=</span> <span class="nx">mergeEncoding</span><span class="p">({</span> <span class="nx">parentEncoding</span><span class="o">:</span> <span class="nx">parentEncoding</span><span class="p">,</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encoding</span> <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">mergedProjection</span> <span class="o">=</span> <span class="nx">mergeProjection</span><span class="p">({</span> <span class="nx">parentProjection</span><span class="o">:</span> <span class="nx">parentProjection</span><span class="p">,</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">projection</span> <span class="p">});</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">rest</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layer</span><span class="o">:</span> <span class="nx">layer</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">subspec</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">subspec</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">normalizeLayer</span><span class="p">(</span><span class="nx">subspec</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">mergedEncoding</span><span class="p">,</span> <span class="nx">mergedProjection</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">normalizeNonFacetUnit</span><span class="p">(</span><span class="nx">subspec</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">mergedEncoding</span><span class="p">,</span> <span class="nx">mergedProjection</span><span class="p">);</span>
          <span class="p">})</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeRepeat</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">subspec</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;spec&quot;</span><span class="p">]);</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">rest</span><span class="p">,</span> <span class="p">{</span> <span class="nx">spec</span><span class="o">:</span> <span class="nx">normalize$2</span><span class="p">(</span><span class="nx">subspec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeVConcat</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">vconcat</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">vconcat</span><span class="p">,</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;vconcat&quot;</span><span class="p">]);</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">rest</span><span class="p">,</span> <span class="p">{</span> <span class="nx">vconcat</span><span class="o">:</span> <span class="nx">vconcat</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">subspec</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">normalize$2</span><span class="p">(</span><span class="nx">subspec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">})</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeHConcat</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">hconcat</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">hconcat</span><span class="p">,</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;hconcat&quot;</span><span class="p">]);</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">rest</span><span class="p">,</span> <span class="p">{</span> <span class="nx">hconcat</span><span class="o">:</span> <span class="nx">hconcat</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">subspec</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">normalize$2</span><span class="p">(</span><span class="nx">subspec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">})</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeFacetedUnit</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// New encoding in the inside spec should not contain row / column</span>
      <span class="c1">// as row/column should be moved to facet</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">row</span><span class="p">,</span> <span class="nx">column</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">column</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">_a</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">]);</span>
      <span class="c1">// Mark and encoding should be moved into the inner spec</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">selection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">selection</span><span class="p">,</span> <span class="nx">_</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">outerSpec</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;selection&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">]);</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">outerSpec</span><span class="p">,</span> <span class="p">{</span> <span class="nx">facet</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">row</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">row</span><span class="o">:</span> <span class="nx">row</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">column</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">column</span><span class="o">:</span> <span class="nx">column</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{})),</span> <span class="nx">spec</span><span class="o">:</span> <span class="nx">normalizeNonFacetUnit</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">projection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">projection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">mark</span><span class="o">:</span> <span class="nx">mark</span> <span class="p">},</span> <span class="p">(</span><span class="nx">width</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">width</span><span class="o">:</span> <span class="nx">width</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">height</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">height</span><span class="o">:</span> <span class="nx">height</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encoding</span> <span class="p">},</span> <span class="p">(</span><span class="nx">selection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">selection</span><span class="o">:</span> <span class="nx">selection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{})),</span> <span class="nx">config</span><span class="p">)</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isNonFacetUnitSpecWithPrimitiveMark</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isPrimitiveMark</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getPointOverlay</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">markConfig</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">point</span> <span class="o">===</span> <span class="s1">&#39;transparent&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">opacity</span><span class="o">:</span> <span class="mi">0</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// truthy : true or object</span>
          <span class="k">return</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">point</span><span class="p">)</span> <span class="o">?</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">point</span> <span class="o">:</span> <span class="p">{};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">point</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// false or null</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// undefined (not disabled)</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">markConfig</span><span class="p">.</span><span class="nx">point</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">shape</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// enable point overlay if config[mark].point is truthy or if encoding.shape is provided</span>
              <span class="k">return</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">markConfig</span><span class="p">.</span><span class="nx">point</span><span class="p">)</span> <span class="o">?</span> <span class="nx">markConfig</span><span class="p">.</span><span class="nx">point</span> <span class="o">:</span> <span class="p">{};</span>
          <span class="p">}</span>
          <span class="c1">// markDef.point is defined as falsy</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getLineOverlay</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">markConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">line</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// true or object</span>
          <span class="k">return</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">line</span> <span class="o">===</span> <span class="kc">true</span> <span class="o">?</span> <span class="p">{}</span> <span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">line</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">line</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// false or null</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// undefined (not disabled)</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">markConfig</span><span class="p">.</span><span class="nx">line</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// enable line overlay if config[mark].line is truthy</span>
              <span class="k">return</span> <span class="nx">markConfig</span><span class="p">.</span><span class="nx">line</span> <span class="o">===</span> <span class="kc">true</span> <span class="o">?</span> <span class="p">{}</span> <span class="o">:</span> <span class="nx">markConfig</span><span class="p">.</span><span class="nx">line</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// markDef.point is defined as falsy</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeNonFacetUnit</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">parentEncoding</span><span class="p">,</span> <span class="nx">parentProjection</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
      <span class="c1">// merge parent encoding / projection first</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parentEncoding</span> <span class="o">||</span> <span class="nx">parentProjection</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">mergedProjection</span> <span class="o">=</span> <span class="nx">mergeProjection</span><span class="p">({</span> <span class="nx">parentProjection</span><span class="o">:</span> <span class="nx">parentProjection</span><span class="p">,</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">projection</span> <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">mergedEncoding</span> <span class="o">=</span> <span class="nx">mergeEncoding</span><span class="p">({</span> <span class="nx">parentEncoding</span><span class="o">:</span> <span class="nx">parentEncoding</span><span class="p">,</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encoding</span> <span class="p">});</span>
          <span class="k">return</span> <span class="nx">normalizeNonFacetUnit</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({},</span> <span class="nx">spec</span><span class="p">,</span> <span class="p">(</span><span class="nx">mergedProjection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">mergedProjection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">mergedEncoding</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">mergedEncoding</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{})),</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isNonFacetUnitSpecWithPrimitiveMark</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// TODO: thoroughly test</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isRanged</span><span class="p">(</span><span class="nx">encoding</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">normalizeRangedUnit</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;line&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">lineWithRange</span><span class="p">(</span><span class="o">!!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">,</span> <span class="o">!!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">));</span>
              <span class="k">return</span> <span class="nx">normalizeNonFacetUnit</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">mark</span><span class="o">:</span> <span class="s1">&#39;rule&#39;</span> <span class="p">},</span> <span class="nx">spec</span><span class="p">),</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">parentEncoding</span><span class="p">,</span> <span class="nx">parentProjection</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isPathMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">normalizePathOverlay</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">spec</span><span class="p">;</span> <span class="c1">// Nothing to normalize</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">normalize$1</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeRangedUnit</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">hasX</span> <span class="o">=</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">X</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">hasY</span> <span class="o">=</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">Y</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">hasX2</span> <span class="o">=</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">X2</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">hasY2</span> <span class="o">=</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">Y2</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="nx">hasX2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasX</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">hasY2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasY</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">normalizedSpec</span> <span class="o">=</span> <span class="nx">duplicate</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasX2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasX</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">normalizedSpec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">normalizedSpec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">;</span>
              <span class="k">delete</span> <span class="nx">normalizedSpec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasY2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasY</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">normalizedSpec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">normalizedSpec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">;</span>
              <span class="k">delete</span> <span class="nx">normalizedSpec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">normalizedSpec</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">spec</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">dropLineAndPoint</span><span class="p">(</span><span class="nx">markDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_point</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">point</span><span class="p">,</span> <span class="nx">_line</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">line</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;point&quot;</span><span class="p">,</span> <span class="s2">&quot;line&quot;</span><span class="p">]);</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">mark</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="nx">mark</span> <span class="o">:</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizePathOverlay</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">config</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
      <span class="c1">// _ is used to denote a dropped property of the unit spec</span>
      <span class="c1">// which should not be carried over to the layer spec</span>
      <span class="kd">var</span> <span class="nx">selection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">selection</span><span class="p">,</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">outerSpec</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;selection&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">,</span> <span class="s2">&quot;encoding&quot;</span><span class="p">,</span> <span class="s2">&quot;mark&quot;</span><span class="p">]);</span>
      <span class="kd">var</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">mark</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">mark</span> <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">pointOverlay</span> <span class="o">=</span> <span class="nx">getPointOverlay</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">[</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">],</span> <span class="nx">encoding</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">lineOverlay</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;area&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">getLineOverlay</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">[</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">pointOverlay</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">lineOverlay</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">spec</span><span class="p">,</span> <span class="p">{</span> 
              <span class="c1">// Do not include point / line overlay in the normalize spec</span>
              <span class="nx">mark</span><span class="o">:</span> <span class="nx">dropLineAndPoint</span><span class="p">(</span><span class="nx">markDef</span><span class="p">)</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="p">[</span><span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">selection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">selection</span><span class="o">:</span> <span class="nx">selection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> 
              <span class="c1">// Do not include point / line overlay in the normalize spec</span>
              <span class="nx">mark</span><span class="o">:</span> <span class="nx">dropLineAndPoint</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({},</span> <span class="nx">markDef</span><span class="p">,</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;area&#39;</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">opacity</span><span class="o">:</span> <span class="mf">0.7</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}))),</span> 
              <span class="c1">// drop shape from encoding as this might be used to trigger point overlay</span>
              <span class="nx">encoding</span><span class="o">:</span> <span class="nx">omit</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="p">})];</span>
      <span class="c1">// FIXME: disable tooltip for the line layer if tooltip is not group-by field.</span>
      <span class="c1">// FIXME: determine rules for applying selections.</span>
      <span class="c1">// Need to copy stack config to overlayed layer</span>
      <span class="kd">var</span> <span class="nx">stackProps</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span> <span class="o">?</span> <span class="nx">config</span><span class="p">.</span><span class="nx">stack</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">overlayEncoding</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">stackProps</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">stackFieldChannel</span> <span class="o">=</span> <span class="nx">stackProps</span><span class="p">.</span><span class="nx">fieldChannel</span><span class="p">,</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">stackProps</span><span class="p">.</span><span class="nx">offset</span><span class="p">;</span>
          <span class="nx">overlayEncoding</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">encoding</span><span class="p">,</span> <span class="p">(</span><span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">stackFieldChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">stackFieldChannel</span><span class="p">],</span> <span class="p">(</span><span class="nx">offset</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">stack</span><span class="o">:</span> <span class="nx">offset</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{})),</span> <span class="nx">_a</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">lineOverlay</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">layer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">projection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">projection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">mark</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;line&#39;</span> <span class="p">},</span> <span class="nx">lineOverlay</span><span class="p">),</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">overlayEncoding</span> <span class="p">}));</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">pointOverlay</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">layer</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">projection</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">projection</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">mark</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="nx">opacity</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">filled</span><span class="o">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="nx">pointOverlay</span><span class="p">),</span> <span class="nx">encoding</span><span class="o">:</span> <span class="nx">overlayEncoding</span> <span class="p">}));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">outerSpec</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layer</span><span class="o">:</span> <span class="nx">layer</span> <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// TODO: add vl.spec.validate &amp; move stuff from vl.validate to here</span>
  <span class="cm">/* Accumulate non-duplicate fieldDefs in a dictionary */</span>
  <span class="kd">function</span> <span class="nx">accumulate</span><span class="p">(</span><span class="nx">dict</span><span class="p">,</span> <span class="nx">defs</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">defs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Consider only pure fieldDef properties (ignoring scale, axis, legend)</span>
          <span class="kd">var</span> <span class="nx">pureFieldDef</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;timeUnit&#39;</span><span class="p">,</span> <span class="s1">&#39;bin&#39;</span><span class="p">,</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">].</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">key$$1</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">f</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">];</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
          <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">hash</span><span class="p">(</span><span class="nx">pureFieldDef</span><span class="p">);</span>
          <span class="nx">dict</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dict</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">||</span> <span class="nx">fieldDef</span><span class="p">;</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">dict</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */</span>
  <span class="kd">function</span> <span class="nx">fieldDefIndex</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">dict</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dict</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">dict</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
      <span class="c1">// FIXME(https://github.com/vega/vega-lite/issues/2207): Support fieldDefIndex for repeat</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">spec</span><span class="p">.</span><span class="nx">layer</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">layer</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitSpec</span><span class="p">(</span><span class="nx">layer</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">accumulate</span><span class="p">(</span><span class="nx">dict</span><span class="p">,</span> <span class="nx">fieldDefs</span><span class="p">(</span><span class="nx">layer</span><span class="p">.</span><span class="nx">encoding</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">fieldDefIndex</span><span class="p">(</span><span class="nx">layer</span><span class="p">,</span> <span class="nx">dict</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">accumulate</span><span class="p">(</span><span class="nx">dict</span><span class="p">,</span> <span class="nx">fieldDefs</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">facet</span><span class="p">));</span>
          <span class="nx">fieldDefIndex</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">dict</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isRepeatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">fieldDefIndex</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">dict</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">childSpec</span> <span class="o">=</span> <span class="nx">isVConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="o">?</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">vconcat</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">hconcat</span><span class="p">;</span>
          <span class="nx">childSpec</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fieldDefIndex</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">dict</span><span class="p">);</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// Unit Spec</span>
          <span class="nx">accumulate</span><span class="p">(</span><span class="nx">dict</span><span class="p">,</span> <span class="nx">fieldDefs</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">dict</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/* Returns all non-duplicate fieldDefs in a spec in a flat array */</span>
  <span class="kd">function</span> <span class="nx">fieldDefs$1</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">vals</span><span class="p">(</span><span class="nx">fieldDefIndex</span><span class="p">(</span><span class="nx">spec</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isStacked</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">config</span> <span class="o">=</span> <span class="nx">config</span> <span class="o">||</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isPrimitiveMark</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">stack</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span> <span class="o">?</span> <span class="nx">config</span><span class="p">.</span><span class="nx">stack</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">)</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">spec</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isFacetSpec</span><span class="o">:</span> <span class="nx">isFacetSpec</span><span class="p">,</span>
    <span class="nx">isUnitSpec</span><span class="o">:</span> <span class="nx">isUnitSpec</span><span class="p">,</span>
    <span class="nx">isLayerSpec</span><span class="o">:</span> <span class="nx">isLayerSpec</span><span class="p">,</span>
    <span class="nx">isRepeatSpec</span><span class="o">:</span> <span class="nx">isRepeatSpec</span><span class="p">,</span>
    <span class="nx">isConcatSpec</span><span class="o">:</span> <span class="nx">isConcatSpec</span><span class="p">,</span>
    <span class="nx">isVConcatSpec</span><span class="o">:</span> <span class="nx">isVConcatSpec</span><span class="p">,</span>
    <span class="nx">isHConcatSpec</span><span class="o">:</span> <span class="nx">isHConcatSpec</span><span class="p">,</span>
    <span class="nx">normalize</span><span class="o">:</span> <span class="nx">normalize$2</span><span class="p">,</span>
    <span class="nx">fieldDefs</span><span class="o">:</span> <span class="nx">fieldDefs$1</span><span class="p">,</span>
    <span class="nx">isStacked</span><span class="o">:</span> <span class="nx">isStacked</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">_normalizeAutoSize</span><span class="p">(</span><span class="nx">autosize</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">autosize</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">autosize</span> <span class="p">}</span> <span class="o">:</span> <span class="nx">autosize</span> <span class="o">||</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeAutoSize</span><span class="p">(</span><span class="nx">topLevelAutosize</span><span class="p">,</span> <span class="nx">configAutosize</span><span class="p">,</span> <span class="nx">isUnitOrLayer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitOrLayer</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">isUnitOrLayer</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">autosize</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;pad&#39;</span> <span class="p">},</span> <span class="nx">_normalizeAutoSize</span><span class="p">(</span><span class="nx">configAutosize</span><span class="p">),</span> <span class="nx">_normalizeAutoSize</span><span class="p">(</span><span class="nx">topLevelAutosize</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">autosize</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;fit&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isUnitOrLayer</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">FIT_NON_SINGLE</span><span class="p">);</span>
              <span class="nx">autosize</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;pad&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">autosize</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">TOP_LEVEL_PROPERTIES</span> <span class="o">=</span> <span class="p">[</span>
      <span class="s1">&#39;background&#39;</span><span class="p">,</span> <span class="s1">&#39;padding&#39;</span><span class="p">,</span> <span class="s1">&#39;datasets&#39;</span>
      <span class="c1">// We do not include &quot;autosize&quot; here as it is supported by only unit and layer specs and thus need to be normalized</span>
  <span class="p">];</span>
  <span class="kd">function</span> <span class="nx">extractTopLevelProperties</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">TOP_LEVEL_PROPERTIES</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">t</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">o</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isUrlData</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">data</span><span class="p">[</span><span class="s1">&#39;url&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isInlineData</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">data</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isNamedData</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isUrlData</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isInlineData</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">MAIN</span> <span class="o">=</span> <span class="s1">&#39;main&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">RAW</span> <span class="o">=</span> <span class="s1">&#39;raw&#39;</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isUrlData</span><span class="o">:</span> <span class="nx">isUrlData</span><span class="p">,</span>
    <span class="nx">isInlineData</span><span class="o">:</span> <span class="nx">isInlineData</span><span class="p">,</span>
    <span class="nx">isNamedData</span><span class="o">:</span> <span class="nx">isNamedData</span><span class="p">,</span>
    <span class="nx">MAIN</span><span class="o">:</span> <span class="nx">MAIN</span><span class="p">,</span>
    <span class="nx">RAW</span><span class="o">:</span> <span class="nx">RAW</span>
  <span class="p">});</span>

  <span class="cm">/**</span>
<span class="cm">   * Parse an event selector string.</span>
<span class="cm">   * Returns an array of event stream definitions.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">parseSelector</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">marks</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">DEFAULT_SOURCE</span> <span class="o">=</span> <span class="nx">source</span> <span class="o">||</span> <span class="nx">VIEW</span><span class="p">;</span>
    <span class="nx">MARKS</span> <span class="o">=</span> <span class="nx">marks</span> <span class="o">||</span> <span class="nx">DEFAULT_MARKS</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">parseMerge</span><span class="p">(</span><span class="nx">selector</span><span class="p">.</span><span class="nx">trim</span><span class="p">()).</span><span class="nx">map</span><span class="p">(</span><span class="nx">parseSelector$1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">VIEW</span>    <span class="o">=</span> <span class="s1">&#39;view&#39;</span><span class="p">,</span>
      <span class="nx">LBRACK</span>  <span class="o">=</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span>
      <span class="nx">RBRACK</span>  <span class="o">=</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span>
      <span class="nx">LBRACE</span>  <span class="o">=</span> <span class="s1">&#39;{&#39;</span><span class="p">,</span>
      <span class="nx">RBRACE</span>  <span class="o">=</span> <span class="s1">&#39;}&#39;</span><span class="p">,</span>
      <span class="nx">COLON</span>   <span class="o">=</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span>
      <span class="nx">COMMA</span>   <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="p">,</span>
      <span class="nx">NAME</span>    <span class="o">=</span> <span class="s1">&#39;@&#39;</span><span class="p">,</span>
      <span class="nx">GT</span>      <span class="o">=</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
      <span class="nx">ILLEGAL</span> <span class="o">=</span> <span class="sr">/[[\]{}]/</span><span class="p">,</span>
      <span class="nx">DEFAULT_SOURCE</span><span class="p">,</span>
      <span class="nx">MARKS</span><span class="p">,</span>
      <span class="nx">DEFAULT_MARKS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;*&#39;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">arc</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">area</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">group</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">image</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">line</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">path</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">rect</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">rule</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">shape</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">symbol</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">text</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">trail</span><span class="o">:</span> <span class="mi">1</span>
      <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">isMarkType</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MARKS</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">type</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">endChar</span><span class="p">,</span> <span class="nx">pushChar</span><span class="p">,</span> <span class="nx">popChar</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">c</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">n</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">c</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">count</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">===</span> <span class="nx">endChar</span><span class="p">)</span> <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">popChar</span> <span class="o">&amp;&amp;</span> <span class="nx">popChar</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">--</span><span class="nx">count</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">pushChar</span> <span class="o">&amp;&amp;</span> <span class="nx">pushChar</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">++</span><span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseMerge</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">COMMA</span><span class="p">,</span> <span class="nx">LBRACK</span> <span class="o">+</span> <span class="nx">LBRACE</span><span class="p">,</span> <span class="nx">RBRACK</span> <span class="o">+</span> <span class="nx">RBRACE</span><span class="p">);</span>
      <span class="nx">output</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">trim</span><span class="p">());</span>
      <span class="nx">start</span> <span class="o">=</span> <span class="o">++</span><span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">output</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="s1">&#39;Empty event selector: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">output</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseSelector$1</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;[&#39;</span>
      <span class="o">?</span> <span class="nx">parseBetween</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
      <span class="o">:</span> <span class="nx">parseStream</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseBetween</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">b</span><span class="p">,</span> <span class="nx">stream</span><span class="p">;</span>

    <span class="nx">i</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">RBRACK</span><span class="p">,</span> <span class="nx">LBRACK</span><span class="p">,</span> <span class="nx">RBRACK</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="s1">&#39;Empty between selector: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">b</span> <span class="o">=</span> <span class="nx">parseMerge</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">i</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="s1">&#39;Between selector must have two elements: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">trim</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">GT</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="s1">&#39;Expected \&#39;&gt;\&#39; after between selector: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">parseSelector$1</span><span class="p">);</span>

    <span class="nx">stream</span> <span class="o">=</span> <span class="nx">parseSelector$1</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">trim</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">stream</span><span class="p">.</span><span class="nx">between</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">between</span><span class="o">:</span> <span class="nx">b</span><span class="p">,</span>
        <span class="nx">stream</span><span class="o">:</span> <span class="nx">stream</span>
      <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">stream</span><span class="p">.</span><span class="nx">between</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">stream</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseStream</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">stream</span> <span class="o">=</span> <span class="p">{</span><span class="nx">source</span><span class="o">:</span> <span class="nx">DEFAULT_SOURCE</span><span class="p">},</span>
        <span class="nx">source</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="nx">throttle</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="nx">markname</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span>
        <span class="nx">filter</span><span class="p">;</span>

    <span class="c1">// extract throttle from end</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="nx">RBRACE</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="nx">LBRACE</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="nx">throttle</span> <span class="o">=</span> <span class="nx">parseThrottle</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="s1">&#39;Invalid throttle specification: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">trim</span><span class="p">();</span>
        <span class="nx">n</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="s1">&#39;Unmatched right brace: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">n</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">s</span><span class="p">;</span>

    <span class="c1">// set name flag based on first char</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nx">NAME</span><span class="p">)</span> <span class="nx">markname</span> <span class="o">=</span> <span class="o">++</span><span class="nx">i</span><span class="p">;</span>

    <span class="c1">// extract first part of multi-part stream selector</span>
    <span class="nx">j</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">COLON</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">source</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">j</span><span class="p">).</span><span class="nx">trim</span><span class="p">());</span>
      <span class="nx">start</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">=</span> <span class="o">++</span><span class="nx">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// extract remaining part of stream selector</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">LBRACK</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">source</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">n</span><span class="p">).</span><span class="nx">trim</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">source</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">trim</span><span class="p">());</span>
      <span class="nx">filter</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="nx">start</span> <span class="o">=</span> <span class="o">++</span><span class="nx">i</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="k">throw</span> <span class="s1">&#39;Unmatched left bracket: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// extract filters</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">RBRACK</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="k">throw</span> <span class="s1">&#39;Unmatched left bracket: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
      <span class="nx">filter</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">trim</span><span class="p">());</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="o">++</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">LBRACK</span><span class="p">)</span> <span class="k">throw</span> <span class="s1">&#39;Expected left bracket: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
      <span class="nx">start</span> <span class="o">=</span> <span class="o">++</span><span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// marshall event stream specification</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">source</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">||</span> <span class="nx">ILLEGAL</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">source</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="s1">&#39;Invalid event selector: &#39;</span> <span class="o">+</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">stream</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">source</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markname</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nx">markname</span> <span class="o">=</span> <span class="nx">source</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isMarkType</span><span class="p">(</span><span class="nx">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nx">marktype</span> <span class="o">=</span> <span class="nx">source</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nx">source</span> <span class="o">=</span> <span class="nx">source</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">stream</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">source</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">stream</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;!&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">stream</span><span class="p">.</span><span class="nx">consume</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">stream</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">type</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">filter</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">filter</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">throttle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">throttle</span> <span class="o">=</span> <span class="nx">throttle</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">throttle</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">debounce</span> <span class="o">=</span> <span class="nx">throttle</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="k">return</span> <span class="nx">stream</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseThrottle</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="nx">COMMA</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">+</span><span class="nx">_</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">s</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isVgSignalRef</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">o</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">range</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">range</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isDataRefUnionedDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;fields&#39;</span> <span class="k">in</span> <span class="nx">domain</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="s1">&#39;data&#39;</span> <span class="k">in</span> <span class="nx">domain</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldRefUnionDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;fields&#39;</span> <span class="k">in</span> <span class="nx">domain</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;data&#39;</span> <span class="k">in</span> <span class="nx">domain</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;field&#39;</span> <span class="k">in</span> <span class="nx">domain</span> <span class="o">&amp;&amp;</span> <span class="s1">&#39;data&#39;</span> <span class="k">in</span> <span class="nx">domain</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">VG_MARK_CONFIG_INDEX</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">opacity</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">fill</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">fillOpacity</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">stroke</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">strokeCap</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">strokeWidth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">strokeOpacity</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">strokeDash</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">strokeDashOffset</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">size</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">shape</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">interpolate</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">tension</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">orient</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">align</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">baseline</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">text</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">limit</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">dx</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">dy</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">radius</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">theta</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">angle</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">font</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">fontSize</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">fontWeight</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">fontStyle</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">cursor</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">href</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">VG_MARK_CONFIGS</span> <span class="o">=</span> <span class="nx">flagKeys</span><span class="p">(</span><span class="nx">VG_MARK_CONFIG_INDEX</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nx">assembleTitle</span><span class="p">(</span><span class="nx">title$$1</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">title$$1</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">title$$1</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">title</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">title$$1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleAxis</span><span class="p">(</span><span class="nx">axisCmpt</span><span class="p">,</span> <span class="nx">kind</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">header</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">axisCmpt</span><span class="p">.</span><span class="nx">combine</span><span class="p">(),</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">orient</span><span class="p">,</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">scale</span><span class="p">,</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span> <span class="nx">zindex</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">zindex</span><span class="p">,</span> <span class="nx">axis</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">_a</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;orient&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="s2">&quot;zindex&quot;</span><span class="p">]);</span>
      <span class="c1">// Remove properties that are not valid for this kind of axis</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">axis</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">key$$1</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">propType</span> <span class="o">=</span> <span class="nx">AXIS_PROPERTY_TYPE</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">propType</span> <span class="o">&amp;&amp;</span> <span class="nx">propType</span> <span class="o">!==</span> <span class="nx">kind</span> <span class="o">&amp;&amp;</span> <span class="nx">propType</span> <span class="o">!==</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">delete</span> <span class="nx">axis</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">kind</span> <span class="o">===</span> <span class="s1">&#39;grid&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">axis</span><span class="p">.</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Remove unnecessary encode block</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Only need to keep encode block for grid</span>
              <span class="kd">var</span> <span class="nx">grid</span> <span class="o">=</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">.</span><span class="nx">grid</span><span class="p">;</span>
              <span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">grid</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">grid</span><span class="o">:</span> <span class="nx">grid</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">delete</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">scale</span><span class="o">:</span> <span class="nx">scale</span><span class="p">,</span>
              <span class="nx">orient</span><span class="o">:</span> <span class="nx">orient</span> <span class="p">},</span> <span class="nx">axis</span><span class="p">,</span> <span class="p">{</span> <span class="nx">domain</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">labels</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> 
              <span class="c1">// Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`</span>
              <span class="c1">// would not affect gridAxis</span>
              <span class="nx">maxExtent</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">minExtent</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ticks</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">zindex</span><span class="o">:</span> <span class="nx">zindex</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">zindex</span> <span class="o">:</span> <span class="mi">0</span> <span class="c1">// put grid behind marks by default</span>
           <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// kind === &#39;main&#39;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">opt</span><span class="p">.</span><span class="nx">header</span> <span class="o">&amp;&amp;</span> <span class="nx">axisCmpt</span><span class="p">.</span><span class="nx">mainExtracted</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// if mainExtracted has been extracted to a separate facet</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Remove unnecessary encode block</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">AXIS_PARTS_1</span> <span class="o">=</span> <span class="nx">AXIS_PARTS</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">AXIS_PARTS_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">part</span> <span class="o">=</span> <span class="nx">AXIS_PARTS_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">axisCmpt</span><span class="p">.</span><span class="nx">hasAxisPart</span><span class="p">(</span><span class="nx">part</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">delete</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">[</span><span class="nx">part</span><span class="p">];</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">delete</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">encode</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">titleString</span> <span class="o">=</span> <span class="nx">assembleTitle</span><span class="p">(</span><span class="nx">title$$1</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">scale</span><span class="o">:</span> <span class="nx">scale</span><span class="p">,</span>
              <span class="nx">orient</span><span class="o">:</span> <span class="nx">orient</span><span class="p">,</span> <span class="nx">grid</span><span class="o">:</span> <span class="kc">false</span> <span class="p">},</span> <span class="p">(</span><span class="nx">titleString</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="nx">titleString</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">axis</span><span class="p">,</span> <span class="p">{</span> <span class="nx">zindex</span><span class="o">:</span> <span class="nx">zindex</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">zindex</span> <span class="o">:</span> <span class="mi">1</span> <span class="c1">// put axis line above marks by default</span>
           <span class="p">});</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleAxes</span><span class="p">(</span><span class="nx">axisComponents</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">axisComponents</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">_a</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="nx">_a</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">axisComponents</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">_b</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="nx">_b</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">assembleAxis</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">}).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">assembleAxis</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">}),</span> <span class="nx">y</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">assembleAxis</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">}),</span> <span class="nx">y</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">assembleAxis</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span> <span class="p">})).</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// filter undefined</span>
  <span class="p">}</span>

  <span class="c1">// TODO: we need to find a way to refactor these so that scaleName is a part of scale</span>
  <span class="c1">// but that&#39;s complicated.  For now, this is a huge step moving forward.</span>
  <span class="cm">/**</span>
<span class="cm">   * @return Vega ValueRef for stackable x or y</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">stackable</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">fieldChannel</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// x or y use stack_end so that stacked line&#39;s point mark use stack_end too.</span>
          <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">suffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">midPoint</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * @return Vega ValueRef for stackable x2 or y2</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">stackable2</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">aFieldDef</span><span class="p">,</span> <span class="nx">a2fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">aFieldDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span> <span class="o">&amp;&amp;</span>
          <span class="c1">// If fieldChannel is X and channel is X2 (or Y and Y2)</span>
          <span class="nx">channel</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">fieldChannel</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">aFieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">suffix</span><span class="o">:</span> <span class="s1">&#39;start&#39;</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">midPoint</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">a2fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getOffset</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">offsetChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s1">&#39;Offset&#39;</span><span class="p">;</span>
      <span class="c1">// TODO: in the future read from encoding channel too</span>
      <span class="kd">var</span> <span class="nx">markDefOffsetValue</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">[</span><span class="nx">offsetChannel</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markDefOffsetValue</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">markDefOffsetValue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Value Ref for binned fields</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">bin$1</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">side</span><span class="p">,</span> <span class="nx">offset</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">binSuffix</span> <span class="o">=</span> <span class="nx">side</span> <span class="o">===</span> <span class="s1">&#39;start&#39;</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="s1">&#39;end&#39;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="nx">binSuffix</span> <span class="p">},</span> <span class="nx">offset</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">opt</span><span class="p">,</span> <span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">scaleName</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">scale</span><span class="o">:</span> <span class="nx">scaleName</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">mixins</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">ref</span><span class="p">,</span> <span class="nx">mixins</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">ref</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">bandRef</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">band</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">band</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">band</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">scale</span><span class="o">:</span> <span class="nx">scaleName</span><span class="p">,</span>
          <span class="nx">band</span><span class="o">:</span> <span class="nx">band</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Signal that returns the middle of a bin. Should only be used with x and y.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">binMidSignal</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span>
              <span class="p">(</span><span class="s2">&quot;scale(\&quot;&quot;</span> <span class="o">+</span> <span class="nx">scaleName</span> <span class="o">+</span> <span class="s2">&quot;\&quot;, &quot;</span> <span class="o">+</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">})</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="o">+</span>
              <span class="s2">&quot; + &quot;</span> <span class="o">+</span>
              <span class="p">(</span><span class="s2">&quot;scale(\&quot;&quot;</span> <span class="o">+</span> <span class="nx">scaleName</span> <span class="o">+</span> <span class="s2">&quot;\&quot;, &quot;</span> <span class="o">+</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">})</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="o">+</span>
              <span class="s2">&quot;)/2&quot;</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">midPoint</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// TODO: datum support</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="cm">/* istanbul ignore else */</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Use middle only for x an y to place marks in the center between start and end of the bin range.</span>
                  <span class="c1">// We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">],</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">QUANTITATIVE</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">stack</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">impute</span><span class="p">)</span> <span class="p">{</span>
                          <span class="c1">// For stack, we computed bin_mid so we can impute.</span>
                          <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;mid&#39;</span> <span class="p">});</span>
                      <span class="p">}</span>
                      <span class="c1">// For non-stack, we can just calculate bin mid on the fly using signal.</span>
                      <span class="k">return</span> <span class="nx">binMidSignal</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">binRequiresRange</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{});</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scale</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;band&#39;</span><span class="p">)</span> <span class="p">{</span>
                          <span class="c1">// For band, to get mid point, need to offset by half of the band</span>
                          <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">band</span><span class="o">:</span> <span class="mf">0.5</span> <span class="p">});</span>
                      <span class="p">}</span>
                      <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">});</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{});</span> <span class="c1">// no need for bin suffix</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">],</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;width&#39;</span> <span class="p">}</span> <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span><span class="p">],</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;height&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;height&#39;</span> <span class="p">}</span> <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="c1">// If channelDef is neither field def or value def, it&#39;s a condition-only def.</span>
          <span class="c1">// In such case, we will use default ref.</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">defaultRef</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">text$1</span><span class="p">(</span><span class="nx">textDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// text</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">textDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">textDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">formatSignalRef</span><span class="p">(</span><span class="nx">textDef</span><span class="p">,</span> <span class="nx">textDef</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="s1">&#39;datum&#39;</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isValueDef</span><span class="p">(</span><span class="nx">textDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">textDef</span><span class="p">.</span><span class="nx">value</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">sizeRef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">sizeRef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">mult</span><span class="o">:</span> <span class="mf">0.5</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Whether the scale definitely includes zero in the domain</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">domainDefinitelyIncludeZero</span><span class="p">(</span><span class="nx">scale</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span> <span class="o">!==</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">domains</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">domains</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">domains</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">some</span><span class="p">(</span><span class="nx">domains</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getDefaultRef</span><span class="p">(</span><span class="nx">defaultRef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">defaultRef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleName</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">ScaleType</span><span class="p">.</span><span class="nx">LOG</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">TIME</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// Log scales cannot have zero.</span>
                  <span class="c1">// Zero in time scale is arbitrary, and does not affect ratio.</span>
                  <span class="c1">// (Time is an interval level of measurement, not ratio).</span>
                  <span class="c1">// See https://en.wikipedia.org/wiki/Level_of_measurement for more info.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;bar&#39;</span> <span class="o">||</span> <span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;area&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">nonZeroScaleUsedWithLengthMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">scaleType</span><span class="o">:</span> <span class="nx">scaleType</span> <span class="p">}));</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">domainDefinitelyIncludeZero</span><span class="p">(</span><span class="nx">scale</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="p">{</span>
                          <span class="nx">scale</span><span class="o">:</span> <span class="nx">scaleName</span><span class="p">,</span>
                          <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span>
                      <span class="p">};</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;bar&#39;</span> <span class="o">||</span> <span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;area&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">nonZeroScaleUsedWithLengthMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">zeroFalse</span><span class="o">:</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">zero</span> <span class="o">===</span> <span class="kc">false</span> <span class="p">}));</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">defaultRef</span> <span class="o">===</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;height&#39;</span> <span class="p">}</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span> <span class="c1">// zeroOrMax</span>
              <span class="k">return</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;width&#39;</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">defaultRef</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">color</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">valueOnly</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">filled</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">filled</span><span class="p">,</span> <span class="nx">markType</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">configValue</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">fill</span><span class="o">:</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">),</span>
          <span class="nx">stroke</span><span class="o">:</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">),</span>
          <span class="nx">color</span><span class="o">:</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
      <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">transparentIfNeeded</span> <span class="o">=</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="s1">&#39;circle&#39;</span><span class="p">,</span> <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;geoshape&#39;</span><span class="p">],</span> <span class="nx">markType</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;transparent&#39;</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">defaultValue</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">fill</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="nx">configValue</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span>
              <span class="c1">// If there is no fill, always fill symbols, bar, geoshape</span>
              <span class="c1">// with transparent fills https://github.com/vega/vega-lite/issues/1316</span>
              <span class="nx">transparentIfNeeded</span><span class="p">,</span>
          <span class="nx">stroke</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">stroke</span> <span class="o">||</span> <span class="nx">configValue</span><span class="p">.</span><span class="nx">stroke</span>
      <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">colorVgChannel</span> <span class="o">=</span> <span class="nx">filled</span> <span class="o">?</span> <span class="s1">&#39;fill&#39;</span> <span class="o">:</span> <span class="s1">&#39;stroke&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">fillStrokeMarkDefAndConfig</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">defaultValue</span><span class="p">.</span><span class="nx">fill</span> <span class="o">?</span> <span class="p">{</span>
          <span class="nx">fill</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">defaultValue</span><span class="p">.</span><span class="nx">fill</span> <span class="p">}</span>
      <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">defaultValue</span><span class="p">.</span><span class="nx">stroke</span> <span class="o">?</span> <span class="p">{</span>
          <span class="nx">stroke</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">defaultValue</span><span class="p">.</span><span class="nx">stroke</span> <span class="p">}</span>
      <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">stroke</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// ignore encoding.color, markDef.color, config.color</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// warn for markDef.color  (no need to warn encoding.color as it will be dropped in normalized already)</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">droppingColor</span><span class="p">(</span><span class="s1">&#39;property&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="s1">&#39;fill&#39;</span> <span class="k">in</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">stroke</span><span class="o">:</span> <span class="s1">&#39;stroke&#39;</span> <span class="k">in</span> <span class="nx">encoding</span> <span class="p">}));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">defaultValue</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="nx">transparentIfNeeded</span> <span class="p">}),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">defaultValue</span><span class="p">.</span><span class="nx">stroke</span> <span class="p">}));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fillStrokeMarkDefAndConfig</span><span class="p">,</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">vgChannel</span><span class="o">:</span> <span class="nx">colorVgChannel</span><span class="p">,</span>
              <span class="c1">// apply default fill/stroke first, then color config, then transparent if needed.</span>
              <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">[</span><span class="nx">colorVgChannel</span><span class="p">]</span> <span class="o">||</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span> <span class="o">||</span> <span class="nx">configValue</span><span class="p">[</span><span class="nx">colorVgChannel</span><span class="p">]</span> <span class="o">||</span> <span class="nx">configValue</span><span class="p">.</span><span class="nx">color</span> <span class="o">||</span> <span class="p">(</span><span class="nx">filled</span> <span class="o">?</span> <span class="nx">transparentIfNeeded</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">)</span>
          <span class="p">}));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">stroke</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Ignore markDef.color, config.color</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">droppingColor</span><span class="p">(</span><span class="s1">&#39;property&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="s1">&#39;fill&#39;</span> <span class="k">in</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">stroke</span><span class="o">:</span> <span class="s1">&#39;stroke&#39;</span> <span class="k">in</span> <span class="nx">markDef</span> <span class="p">}));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">fillStrokeMarkDefAndConfig</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fillStrokeMarkDefAndConfig</span><span class="p">,</span> <span class="p">(</span><span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">colorVgChannel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span> <span class="p">},</span> <span class="nx">_a</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">configValue</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="nx">configValue</span><span class="p">.</span><span class="nx">stroke</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// ignore config.color</span>
          <span class="k">return</span> <span class="nx">fillStrokeMarkDefAndConfig</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">configValue</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">transparentIfNeeded</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;transparent&#39;</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">colorVgChannel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">configValue</span><span class="p">.</span><span class="nx">color</span> <span class="p">},</span> <span class="nx">_b</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">,</span> <span class="nx">_b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">ignore</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">markDefProperties</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">ignore</span><span class="p">),</span> <span class="nx">color</span><span class="p">(</span><span class="nx">model</span><span class="p">),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;opacity&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">),</span> <span class="nx">tooltip</span><span class="p">(</span><span class="nx">model</span><span class="p">),</span> <span class="nx">text$2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;href&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">markDefProperties</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">ignore</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">VG_MARK_CONFIGS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">ignore</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">!==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">m</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">mark</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">m</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">valueIfDefined</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">},</span> <span class="nx">_a</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">validPredicate</span><span class="p">(</span><span class="nx">vgRef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">vgRef</span> <span class="o">+</span> <span class="s2">&quot; !== null &amp;&amp; !isNaN(&quot;</span> <span class="o">+</span> <span class="nx">vgRef</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defined</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">invalidValues</span> <span class="o">===</span> <span class="s1">&#39;filter&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleComponent</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                  <span class="c1">// Discrete domain scales can handle invalid values, but continuous scales can&#39;t.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">});</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">})</span>
              <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="nx">field$$1</span><span class="p">;</span> <span class="p">})</span>
              <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">validPredicate</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fields</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">defined</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">fields</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">)</span> <span class="p">}</span>
              <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return mixins for non-positional channels with scales.  (Text doesn&#39;t have scale.)</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">defaultValue</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">defaultValue</span><span class="p">,</span> <span class="nx">vgChannel</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">vgChannel</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">defaultRef</span> <span class="o">=</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">defaultRef</span> <span class="o">||</span> <span class="p">(</span><span class="nx">defaultValue</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">defaultValue</span> <span class="p">}</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="k">return</span> <span class="nx">wrapCondition</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">vgChannel</span> <span class="o">||</span> <span class="nx">channel</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">cDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">midPoint</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">cDef</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span> <span class="kc">null</span><span class="p">,</span> <span class="c1">// No need to provide stack for non-position as it does not affect mid point</span>
          <span class="nx">defaultRef</span><span class="p">);</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.</span>
<span class="cm">   * or a simple mixin if channel def has no condition.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">wrapCondition</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">vgChannel</span><span class="p">,</span> <span class="nx">refFn</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">condition</span> <span class="o">=</span> <span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">valueRef</span> <span class="o">=</span> <span class="nx">refFn</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">condition</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">conditions</span> <span class="o">=</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">condition</span><span class="p">)</span> <span class="o">?</span> <span class="nx">condition</span> <span class="o">:</span> <span class="p">[</span><span class="nx">condition</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">vgConditions</span> <span class="o">=</span> <span class="nx">conditions</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">conditionValueRef</span> <span class="o">=</span> <span class="nx">refFn</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">test</span> <span class="o">=</span> <span class="nx">isConditionalSelection</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">?</span> <span class="nx">selectionPredicate</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">selection</span><span class="p">)</span> <span class="o">:</span> <span class="nx">expression</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">test</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">test</span><span class="o">:</span> <span class="nx">test</span> <span class="p">},</span> <span class="nx">conditionValueRef</span><span class="p">);</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span>
              <span class="nx">_a</span><span class="p">[</span><span class="nx">vgChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vgConditions</span><span class="p">.</span><span class="nx">concat</span><span class="p">((</span><span class="nx">valueRef</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="p">[</span><span class="nx">valueRef</span><span class="p">]</span> <span class="o">:</span> <span class="p">[])),</span>
              <span class="nx">_a</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">valueRef</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="p">(</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">vgChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">valueRef</span><span class="p">,</span> <span class="nx">_b</span><span class="p">)</span> <span class="o">:</span> <span class="p">{};</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">,</span> <span class="nx">_b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">tooltip</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="s1">&#39;tooltip&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">keyValues</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">});</span>
              <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">text$1</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">).</span><span class="nx">signal</span><span class="p">;</span>
              <span class="k">return</span> <span class="s2">&quot;\&quot;&quot;</span> <span class="o">+</span> <span class="nx">key$$1</span> <span class="o">+</span> <span class="s2">&quot;\&quot;: &quot;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">tooltip</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="nx">keyValues</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="p">}</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// if not an array, behave just like text</span>
          <span class="k">return</span> <span class="nx">textCommon</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">text$2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">channel</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span><span class="p">;</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="k">return</span> <span class="nx">textCommon</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">textCommon</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">wrapCondition</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">cDef</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">text$1</span><span class="p">(</span><span class="nx">cDef</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">bandPosition</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">sizeChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">size</span> <span class="o">||</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">centeredBandPositionMixins</span> <span class="o">=</span> <span class="p">(</span><span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span>
                  <span class="c1">// Use xc/yc and place the mark at the middle of the band</span>
                  <span class="c1">// This way we never have to deal with size&#39;s condition for x/y position.</span>
                  <span class="nx">_a</span><span class="p">[</span><span class="nx">channel</span> <span class="o">+</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span> <span class="nx">band</span><span class="o">:</span> <span class="mf">0.5</span> <span class="p">}),</span>
                  <span class="nx">_a</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">size</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">centeredBandPositionMixins</span><span class="p">,</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">vgChannel</span><span class="o">:</span> <span class="nx">sizeChannel</span> <span class="p">}));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isValueDef</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">size</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">centeredBandPositionMixins</span><span class="p">,</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">vgChannel</span><span class="o">:</span> <span class="nx">sizeChannel</span> <span class="p">}));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">centeredBandPositionMixins</span><span class="p">,</span> <span class="p">(</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">sizeChannel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="p">},</span> <span class="nx">_b</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">cannotApplySizeToNonOrientedMark</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">));</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">_c</span> <span class="o">=</span> <span class="p">{},</span>
          <span class="nx">_c</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fieldRef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">}),</span>
          <span class="nx">_c</span><span class="p">[</span><span class="nx">sizeChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bandRef</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">),</span>
          <span class="nx">_c</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">,</span> <span class="nx">_b</span><span class="p">,</span> <span class="nx">_c</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">centeredBandPosition</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">defaultPosRef</span><span class="p">,</span> <span class="nx">defaultSizeRef</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">centerChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;xc&#39;</span> <span class="o">:</span> <span class="s1">&#39;yc&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">sizeChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">defaultPosRef</span><span class="p">,</span> <span class="nx">centerChannel</span><span class="p">),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">defaultRef</span><span class="o">:</span> <span class="nx">defaultSizeRef</span><span class="p">,</span> <span class="nx">vgChannel</span><span class="o">:</span> <span class="nx">sizeChannel</span> <span class="p">}));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">binnedPosition</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">spacing</span><span class="p">,</span> <span class="nx">reverse</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">x2</span><span class="o">:</span> <span class="nx">bin$1</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="nx">reverse</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">spacing</span><span class="p">),</span>
              <span class="nx">x</span><span class="o">:</span> <span class="nx">bin$1</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="nx">reverse</span> <span class="o">?</span> <span class="nx">spacing</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">y2</span><span class="o">:</span> <span class="nx">bin$1</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="nx">reverse</span> <span class="o">?</span> <span class="nx">spacing</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
              <span class="nx">y</span><span class="o">:</span> <span class="nx">bin$1</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="nx">reverse</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">spacing</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return mixins for point (non-band) position channels.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">,</span> <span class="nx">vgChannel</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">scaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">getOffset</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">valueRef</span> <span class="o">=</span> <span class="o">!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">latitude</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">longitude</span><span class="p">)</span> <span class="o">?</span>
          <span class="c1">// use geopoint output if there are lat/long and there is no point position overriding lat/long.</span>
          <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">}</span> <span class="o">:</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">stackable</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">],</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">getDefaultRef</span><span class="p">(</span><span class="nx">defaultRef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">mark</span><span class="p">)),</span> <span class="p">(</span><span class="nx">offset</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="k">return</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span>
          <span class="nx">_a</span><span class="p">[</span><span class="nx">vgChannel</span> <span class="o">||</span> <span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">valueRef</span><span class="p">,</span>
          <span class="nx">_a</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return mixins for x2, y2.</span>
<span class="cm">   * If channel is not specified, return one channel based on orientation.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">defaultRef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">baseChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x2&#39;</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">baseChannel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">scaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">baseChannel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">baseChannel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">getOffset</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">valueRef</span> <span class="o">=</span> <span class="o">!</span><span class="nx">channelDef</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">latitude</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">longitude</span><span class="p">)</span> <span class="o">?</span>
          <span class="c1">// use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.</span>
          <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">}</span> <span class="o">:</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">stackable2</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">],</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">stack</span><span class="p">,</span> <span class="nx">getDefaultRef</span><span class="p">(</span><span class="nx">defaultRef</span><span class="p">,</span> <span class="nx">baseChannel</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">mark</span><span class="p">)),</span> <span class="p">(</span><span class="nx">offset</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="k">return</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">valueRef</span><span class="p">,</span> <span class="nx">_a</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">applyMarkConfig</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">propsList</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">propsList_2</span> <span class="o">=</span> <span class="nx">propsList</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">propsList_2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">property</span> <span class="o">=</span> <span class="nx">propsList_2</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">e</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">e</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getStyles</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">style</span> <span class="o">||</span> <span class="p">[]);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return property value from style or mark specific config property if exists.</span>
<span class="cm">   * Otherwise, return general mark specific config.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// By default, read from mark config first!</span>
      <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">mark</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="c1">// Then read mark specific config, which has higher precedence</span>
      <span class="kd">var</span> <span class="nx">markSpecificConfig</span> <span class="o">=</span> <span class="nx">config</span><span class="p">[</span><span class="nx">mark</span><span class="p">.</span><span class="nx">type</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markSpecificConfig</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">markSpecificConfig</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="c1">// Then read style config, which has even higher precedence.</span>
      <span class="kd">var</span> <span class="nx">styles</span> <span class="o">=</span> <span class="nx">getStyles</span><span class="p">(</span><span class="nx">mark</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">styles_1</span> <span class="o">=</span> <span class="nx">styles</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">styles_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">style</span> <span class="o">=</span> <span class="nx">styles_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">styleConfig</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">style</span><span class="p">[</span><span class="nx">style</span><span class="p">];</span>
          <span class="c1">// MarkConfig extends VgMarkConfig so a prop may not be a valid property for style</span>
          <span class="c1">// However here we also check if it is defined, so it is okay to cast here</span>
          <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">prop</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">styleConfig</span> <span class="o">&amp;&amp;</span> <span class="nx">styleConfig</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">value</span> <span class="o">=</span> <span class="nx">styleConfig</span><span class="p">[</span><span class="nx">p</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">formatSignalRef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedFormat</span><span class="p">,</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">format</span> <span class="o">=</span> <span class="nx">numberFormat</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedFormat</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">startField</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">endField</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">});</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="o">:</span> <span class="nx">binFormatExpression</span><span class="p">(</span><span class="nx">startField</span><span class="p">,</span> <span class="nx">endField</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">formatExpr</span><span class="p">(</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">}),</span> <span class="nx">format</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isTimeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">isUTCScale</span> <span class="o">=</span> <span class="nx">isScaleFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">].</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span><span class="p">;</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="o">:</span> <span class="nx">timeFormatExpression</span><span class="p">(</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">}),</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">specifiedFormat</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">text</span><span class="p">.</span><span class="nx">shortTimeLabels</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">timeFormat</span><span class="p">,</span> <span class="nx">isUTCScale</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;&#39;&#39;+&quot;</span> <span class="o">+</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">})</span>
          <span class="p">};</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedValue</span><span class="p">,</span> <span class="nx">defaultValue</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">specifiedValue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">defaultValue</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns number format for a fieldDef</span>
<span class="cm">   *</span>
<span class="cm">   * @param format explicitly specified format</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">numberFormat</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedFormat</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">QUANTITATIVE</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// add number format for quantitative type only</span>
          <span class="c1">// Specified format in axis/legend has higher precedence than fieldDef.format</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedFormat</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">specifiedFormat</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// TODO: need to make this work correctly for numeric ordinal / nominal type</span>
          <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">numberFormat</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">formatExpr</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">format</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s2">&quot;format(&quot;</span> <span class="o">+</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot;, \&quot;&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">format</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;\&quot;)&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">numberFormatExpr</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">specifiedFormat</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">formatExpr</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">specifiedFormat</span> <span class="o">||</span> <span class="nx">config</span><span class="p">.</span><span class="nx">numberFormat</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">binFormatExpression</span><span class="p">(</span><span class="nx">startField</span><span class="p">,</span> <span class="nx">endField</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">startField</span> <span class="o">+</span> <span class="s2">&quot; === null || isNaN(&quot;</span> <span class="o">+</span> <span class="nx">startField</span> <span class="o">+</span> <span class="s2">&quot;) ? \&quot;null\&quot; : &quot;</span> <span class="o">+</span> <span class="nx">numberFormatExpr</span><span class="p">(</span><span class="nx">startField</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; + \&quot; - \&quot; + &quot;</span> <span class="o">+</span> <span class="nx">numberFormatExpr</span><span class="p">(</span><span class="nx">endField</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns the time expression used for axis/legend labels or text mark for a temporal field</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">timeFormatExpression</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">shortTimeLabels</span><span class="p">,</span> <span class="nx">timeFormatConfig</span><span class="p">,</span> <span class="nx">isUTCScale</span><span class="p">,</span> <span class="nx">alwaysReturn</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">alwaysReturn</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">alwaysReturn</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">timeUnit</span> <span class="o">||</span> <span class="nx">format</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If there is not time unit, or if user explicitly specify format for axis/legend/text.</span>
          <span class="nx">format</span> <span class="o">=</span> <span class="nx">format</span> <span class="o">||</span> <span class="nx">timeFormatConfig</span><span class="p">;</span> <span class="c1">// only use config.timeFormat if there is no timeUnit.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">format</span> <span class="o">||</span> <span class="nx">alwaysReturn</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">(</span><span class="nx">isUTCScale</span> <span class="o">?</span> <span class="s1">&#39;utc&#39;</span> <span class="o">:</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;Format(&quot;</span> <span class="o">+</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s2">&quot;, &#39;&quot;</span> <span class="o">+</span> <span class="nx">format</span> <span class="o">+</span> <span class="s2">&quot;&#39;)&quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">formatExpression</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">field$$1</span><span class="p">,</span> <span class="nx">shortTimeLabels</span><span class="p">,</span> <span class="nx">isUTCScale</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return Vega sort parameters (tuple of field and order).</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">sortParams</span><span class="p">(</span><span class="nx">orderDef</span><span class="p">,</span> <span class="nx">fieldRefOption</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">orderDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">orderDef</span> <span class="o">:</span> <span class="p">[</span><span class="nx">orderDef</span><span class="p">]).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">orderChannelDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">s</span><span class="p">.</span><span class="nx">field</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">orderChannelDef</span><span class="p">,</span> <span class="nx">fieldRefOption</span><span class="p">));</span>
          <span class="nx">s</span><span class="p">.</span><span class="nx">order</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">orderChannelDef</span><span class="p">.</span><span class="nx">sort</span> <span class="o">||</span> <span class="s1">&#39;ascending&#39;</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">[],</span> <span class="nx">order</span><span class="o">:</span> <span class="p">[]</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeTitleFieldDefs</span><span class="p">(</span><span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">merged</span> <span class="o">=</span> <span class="nx">f1</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
      <span class="nx">f2</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fdToMerge</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">merged_1</span> <span class="o">=</span> <span class="nx">merged</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">merged_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef1</span> <span class="o">=</span> <span class="nx">merged_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="c1">// If already exists, no need to append to merged array</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">stringify$2</span><span class="p">(</span><span class="nx">fieldDef1</span><span class="p">)</span> <span class="o">===</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">fdToMerge</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">merged</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fdToMerge</span><span class="p">);</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">merged</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeTitle</span><span class="p">(</span><span class="nx">title1</span><span class="p">,</span> <span class="nx">title2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">title1</span> <span class="o">===</span> <span class="nx">title2</span> <span class="o">?</span>
          <span class="nx">title1</span> <span class="o">:</span> <span class="c1">// if title is the same just use one of them</span>
          <span class="nx">title1</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nx">title2</span><span class="p">;</span> <span class="c1">// join title with comma if different</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeTitleComponent</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">explicit</span><span class="o">:</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">explicit</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="nx">mergeTitleFieldDefs</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">explicit</span><span class="o">:</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">explicit</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="nx">mergeTitle</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: Condition should not happen -- only for warning in development. */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;It should never reach here&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Checks whether a fieldDef for a particular channel requires a computed bin range.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">binRequiresRange</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Only use this method with binned field defs&#39;</span><span class="p">);</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.</span>
      <span class="c1">// We could check whether the axis or legend exists (not disabled) but that seems overkill.</span>
      <span class="k">return</span> <span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;ordinal&#39;</span><span class="p">,</span> <span class="s1">&#39;nominal&#39;</span><span class="p">],</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">guideEncodeEntry</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">encoding</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">encode</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">valueDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">encode</span><span class="p">,</span> <span class="nx">wrapCondition</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">valueDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">({</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">x</span><span class="p">.</span><span class="nx">value</span> <span class="p">});</span> <span class="p">}));</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">HEADER_CHANNELS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">HEADER_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">,</span> <span class="s1">&#39;footer&#39;</span><span class="p">];</span>
  <span class="kd">function</span> <span class="nx">getHeaderType</span><span class="p">(</span><span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">||</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;header&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="s1">&#39;footer&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getTitleGroup</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">title</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">textOrient</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">align</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;center&#39;</span> <span class="p">},</span> <span class="nx">text</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">title$$1</span> <span class="p">}</span> <span class="p">},</span> <span class="p">(</span><span class="nx">textOrient</span> <span class="o">===</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">angle</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">270</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">name</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;_title&quot;</span><span class="p">),</span>
          <span class="nx">role</span><span class="o">:</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;-title&quot;</span><span class="p">,</span>
          <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span>
          <span class="nx">marks</span><span class="o">:</span> <span class="p">[</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="nx">role</span><span class="o">:</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;-title-text&quot;</span><span class="p">,</span> <span class="nx">style</span><span class="o">:</span> <span class="s1">&#39;guide-title&#39;</span> <span class="p">},</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">update</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">update</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}))]</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getHeaderGroups</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">layoutHeader</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">groups</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">HEADER_TYPES_1</span> <span class="o">=</span> <span class="nx">HEADER_TYPES</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">HEADER_TYPES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">headerType</span> <span class="o">=</span> <span class="nx">HEADER_TYPES_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">layoutHeader</span><span class="p">[</span><span class="nx">headerType</span><span class="p">])</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">layoutHeader</span><span class="p">[</span><span class="nx">headerType</span><span class="p">];</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">headerCmpt</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
                  <span class="nx">groups</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getHeaderGroup</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">headerType</span><span class="p">,</span> <span class="nx">layoutHeader</span><span class="p">,</span> <span class="nx">headerCmpt</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">groups</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 0, (0,90), 90, (90, 180), 180, (180, 270), 270, (270, 0)</span>
  <span class="kd">function</span> <span class="nx">labelAlign</span><span class="p">(</span><span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// to keep angle in [0, 360)</span>
      <span class="nx">angle</span> <span class="o">=</span> <span class="p">((</span><span class="nx">angle</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="nx">angle</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for 90 and 270</span>
          <span class="k">return</span> <span class="p">{};</span> <span class="c1">// default center</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="o">||</span> <span class="mi">270</span> <span class="o">&lt;</span> <span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">align</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;right&#39;</span> <span class="p">}</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">135</span> <span class="o">&lt;=</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;</span> <span class="mi">225</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">align</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;left&#39;</span> <span class="p">}</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labelBaseline</span><span class="p">(</span><span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// to keep angle in [0, 360)</span>
      <span class="nx">angle</span> <span class="o">=</span> <span class="p">((</span><span class="nx">angle</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="mi">45</span> <span class="o">&lt;=</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;=</span> <span class="mi">135</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">baseline</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;top&#39;</span> <span class="p">}</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getHeaderGroup</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">headerType</span><span class="p">,</span> <span class="nx">layoutHeader</span><span class="p">,</span> <span class="nx">headerCmpt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">headerCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">facetFieldDef</span> <span class="o">=</span> <span class="nx">layoutHeader</span><span class="p">.</span><span class="nx">facetFieldDef</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">facetFieldDef</span> <span class="o">&amp;&amp;</span> <span class="nx">headerCmpt</span><span class="p">.</span><span class="nx">labels</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">facetFieldDef</span><span class="p">.</span><span class="nx">header</span><span class="p">,</span> <span class="nx">header</span> <span class="o">=</span> <span class="nx">_a</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">{}</span> <span class="o">:</span> <span class="nx">_a</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">format</span> <span class="o">=</span> <span class="nx">header</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">labelAngle</span> <span class="o">=</span> <span class="nx">header</span><span class="p">.</span><span class="nx">labelAngle</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">labelAngle</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">angle</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">labelAngle</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">labelAlign</span><span class="p">(</span><span class="nx">labelAngle</span><span class="p">),</span> <span class="nx">labelBaseline</span><span class="p">(</span><span class="nx">labelAngle</span><span class="p">));</span>
              <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">text</span><span class="o">:</span> <span class="nx">formatSignalRef</span><span class="p">(</span><span class="nx">facetFieldDef</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">),</span> <span class="nx">offset</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="s1">&#39;left&#39;</span> <span class="o">:</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="nx">style</span><span class="o">:</span> <span class="s1">&#39;guide-label&#39;</span> <span class="p">},</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">update</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">update</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">axes</span> <span class="o">=</span> <span class="nx">headerCmpt</span><span class="p">.</span><span class="nx">axes</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">hasAxes</span> <span class="o">=</span> <span class="nx">axes</span> <span class="o">&amp;&amp;</span> <span class="nx">axes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">title$$1</span> <span class="o">||</span> <span class="nx">hasAxes</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">sizeChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="s1">&#39;height&#39;</span> <span class="o">:</span> <span class="s1">&#39;width&#39;</span><span class="p">;</span>
              <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">headerType</span><span class="p">),</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="nx">role</span><span class="o">:</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nx">headerType</span> <span class="p">},</span> <span class="p">(</span><span class="nx">layoutHeader</span><span class="p">.</span><span class="nx">facetFieldDef</span> <span class="o">?</span> <span class="p">{</span>
                  <span class="nx">from</span><span class="o">:</span> <span class="p">{</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">channel</span> <span class="o">+</span> <span class="s1">&#39;_domain&#39;</span><span class="p">)</span> <span class="p">},</span>
                  <span class="nx">sort</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">facetFieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">}),</span>
                      <span class="nx">order</span><span class="o">:</span> <span class="nx">facetFieldDef</span><span class="p">.</span><span class="nx">sort</span> <span class="o">||</span> <span class="s1">&#39;ascending&#39;</span>
                  <span class="p">}</span>
              <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">title$$1</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="nx">title$$1</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">headerCmpt</span><span class="p">.</span><span class="nx">sizeSignal</span> <span class="o">?</span> <span class="p">{</span>
                  <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="p">(</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span>
                          <span class="nx">_b</span><span class="p">[</span><span class="nx">sizeChannel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">headerCmpt</span><span class="p">.</span><span class="nx">sizeSignal</span><span class="p">,</span>
                          <span class="nx">_b</span><span class="p">)</span>
                  <span class="p">}</span>
              <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">hasAxes</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">axes</span><span class="o">:</span> <span class="nx">axes</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">assembleLayoutSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">sizeSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">),</span> <span class="nx">sizeSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">sizeSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">sizeType</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">sizeType</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">size</span> <span class="o">||</span> <span class="nx">size</span> <span class="o">===</span> <span class="s1">&#39;merged&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[];</span>
      <span class="p">}</span>
      <span class="c1">// Read size signal name from name map, just in case it is the top-level size signal that got renamed.</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">).</span><span class="nx">signal</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">size</span> <span class="o">===</span> <span class="s1">&#39;range-step&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleComponent</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">range</span><span class="p">))</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">scaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">))</span> <span class="p">{</span>
                      <span class="c1">// If parent is facet and this is an independent scale, return only signal signal</span>
                      <span class="c1">// as the width/height will be calculated using the cardinality from</span>
                      <span class="c1">// facet&#39;s aggregate rather than reading from scale domain</span>
                      <span class="kd">var</span> <span class="nx">parentResolve</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">resolve</span><span class="p">;</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">parentResolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;independent&#39;</span><span class="p">)</span> <span class="p">{</span>
                          <span class="k">return</span> <span class="p">[</span><span class="nx">stepSignal</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">range</span><span class="p">)];</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="p">[</span>
                      <span class="nx">stepSignal</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">range</span><span class="p">),</span>
                      <span class="p">{</span>
                          <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span>
                          <span class="nx">update</span><span class="o">:</span> <span class="nx">sizeExpr</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scaleComponent</span><span class="p">,</span> <span class="s2">&quot;domain(&#39;&quot;</span> <span class="o">+</span> <span class="nx">scaleName</span> <span class="o">+</span> <span class="s2">&quot;&#39;).length&quot;</span><span class="p">)</span>
                      <span class="p">}</span>
                  <span class="p">];</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="cm">/* istanbul ignore next: Condition should not happen -- only for warning in development. */</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;layout size is range step although there is no rangeStep.&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span>
                  <span class="nx">value</span><span class="o">:</span> <span class="nx">size</span>
              <span class="p">}];</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">stepSignal</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">range</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">name</span><span class="o">:</span> <span class="nx">scaleName</span> <span class="o">+</span> <span class="s1">&#39;_step&#39;</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="nx">range</span><span class="p">.</span><span class="nx">step</span><span class="p">,</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">sizeExpr</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scaleComponent</span><span class="p">,</span> <span class="nx">cardinality</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">padding</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;padding&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">paddingOuter</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;paddingOuter&#39;</span><span class="p">);</span>
      <span class="nx">paddingOuter</span> <span class="o">=</span> <span class="nx">paddingOuter</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">paddingOuter</span> <span class="o">:</span> <span class="nx">padding</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">paddingInner</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;paddingInner&#39;</span><span class="p">);</span>
      <span class="nx">paddingInner</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;band&#39;</span> <span class="o">?</span>
          <span class="c1">// only band has real paddingInner</span>
          <span class="p">(</span><span class="nx">paddingInner</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">paddingInner</span> <span class="o">:</span> <span class="nx">padding</span><span class="p">)</span> <span class="o">:</span>
          <span class="c1">// For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,</span>
          <span class="c1">// it&#39;s equivalent to have paddingInner = 1 since there is only n-1 steps between n points.</span>
          <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span> <span class="s2">&quot;bandspace(&quot;</span> <span class="o">+</span> <span class="nx">cardinality</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">paddingInner</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">paddingOuter</span> <span class="o">+</span> <span class="s2">&quot;) * &quot;</span> <span class="o">+</span> <span class="nx">scaleName</span> <span class="o">+</span> <span class="s2">&quot;_step&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">defaultScaleResolve</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;shared&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isConcatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isRepeatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">POSITION_SCALE_CHANNELS</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;independent&#39;</span> <span class="o">:</span> <span class="s1">&#39;shared&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach here. */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;invalid model type for resolve&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseGuideResolve</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channelScaleResolve</span> <span class="o">=</span> <span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">guide</span> <span class="o">=</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">POSITION_SCALE_CHANNELS</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;axis&#39;</span> <span class="o">:</span> <span class="s1">&#39;legend&#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channelScaleResolve</span> <span class="o">===</span> <span class="s1">&#39;independent&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">[</span><span class="nx">guide</span><span class="p">][</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">independentScaleMeansIndependentGuide</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="s1">&#39;independent&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">resolve</span><span class="p">[</span><span class="nx">guide</span><span class="p">][</span><span class="nx">channel</span><span class="p">]</span> <span class="o">||</span> <span class="s1">&#39;shared&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Generic class for storing properties that are explicitly specified</span>
<span class="cm">   * and implicitly determined by the compiler.</span>
<span class="cm">   * This is important for scale/axis/legend merging as</span>
<span class="cm">   * we want to prioritize properties that users explicitly specified.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">Split</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">Split</span><span class="p">(</span><span class="nx">explicit</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">explicit</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">explicit</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">implicit</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">implicit</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">=</span> <span class="nx">explicit</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">implicit</span> <span class="o">=</span> <span class="nx">implicit</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">Split</span><span class="p">(</span><span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">),</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">implicit</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">combine</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// FIXME remove &quot;as any&quot;.</span>
          <span class="c1">// Add &quot;as any&quot; to avoid an error &quot;Spread types may only be created from object types&quot;.</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">implicit</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Explicit has higher precedence</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">implicit</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getWithExplicit</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Explicit has higher precedence</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">explicit</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">implicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">explicit</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">implicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">explicit</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span> <span class="p">};</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setWithExplicit</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">value</span><span class="p">.</span><span class="nx">explicit</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">set</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">delete</span> <span class="k">this</span><span class="p">[</span><span class="nx">explicit</span> <span class="o">?</span> <span class="s1">&#39;implicit&#39;</span> <span class="o">:</span> <span class="s1">&#39;explicit&#39;</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
          <span class="k">this</span><span class="p">[</span><span class="nx">explicit</span> <span class="o">?</span> <span class="s1">&#39;explicit&#39;</span> <span class="o">:</span> <span class="s1">&#39;implicit&#39;</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">copyKeyFromSplit</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Explicit has higher precedence</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">explicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">explicit</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="kc">true</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">implicit</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">implicit</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="kc">false</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">copyKeyFromObject</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Explicit has higher precedence</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="kc">true</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Merge split object into this split object. Properties from the other split</span>
<span class="cm">       * overwrite properties from this split.</span>
<span class="cm">       */</span>
      <span class="nx">Split</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">copyAll</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">combine</span><span class="p">());</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">Split</span><span class="p">;</span>
  <span class="p">}());</span>
  <span class="kd">function</span> <span class="nx">makeExplicit</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">explicit</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">makeImplicit</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">explicit</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">tieBreakByComparing</span><span class="p">(</span><span class="nx">compare</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">compare</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">v1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">v2</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">defaultTieBreaker</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">);</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defaultTieBreaker</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">explicit</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">mergeConflictingProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="c1">// If equal score, prefer v1.</span>
      <span class="k">return</span> <span class="nx">v1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeValuesWithExplicit</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">,</span> <span class="nx">tieBreaker</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tieBreaker</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">tieBreaker</span> <span class="o">=</span> <span class="nx">defaultTieBreaker</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">v1</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// For first run</span>
          <span class="k">return</span> <span class="nx">v2</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">v2</span><span class="p">.</span><span class="nx">explicit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">v1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">v2</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">v1</span><span class="p">.</span><span class="nx">explicit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">v2</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">stringify$2</span><span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">===</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">v2</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">v1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">tieBreaker</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">propertyOf</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">LegendComponent</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">LegendComponent</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">LegendComponent</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">_super</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">LegendComponent</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Split</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">symbols</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">symbolsSpec</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;gradient&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">applyMarkConfig</span><span class="p">({},</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">FILL_STROKE_CONFIG</span><span class="p">),</span> <span class="nx">color</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">BAR</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">TICK</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">TEXT$1</span><span class="o">:</span>
              <span class="nx">out</span><span class="p">.</span><span class="nx">shape</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;square&#39;</span> <span class="p">};</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="nx">CIRCLE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SQUARE</span><span class="o">:</span>
              <span class="nx">out</span><span class="p">.</span><span class="nx">shape</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span> <span class="p">};</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="nx">POINT</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">LINE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">GEOSHAPE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">AREA</span><span class="o">:</span>
              <span class="c1">// use default circle</span>
              <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">filled</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">filled</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">fill</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// for fill legend, we don&#39;t want any fill in symbol</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;fill&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="nx">filled</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="nx">COLOR</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">delete</span> <span class="nx">out</span><span class="p">.</span><span class="nx">fill</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">fill</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">])</span> <span class="p">{</span>
                  <span class="c1">// For others, remove fill field</span>
                  <span class="k">delete</span> <span class="nx">out</span><span class="p">.</span><span class="nx">fill</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">fill</span><span class="p">))</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">fill</span> <span class="o">=</span> <span class="nx">getFirstConditionValue</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="o">||</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">fill</span> <span class="o">||</span> <span class="p">(</span><span class="nx">filled</span> <span class="o">&amp;&amp;</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">fill</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">out</span><span class="p">.</span><span class="nx">fill</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">fill</span> <span class="p">};</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;stroke&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">filled</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="nx">COLOR</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">delete</span> <span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">])</span> <span class="p">{</span>
                  <span class="c1">// For others, remove stroke field</span>
                  <span class="k">delete</span> <span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span><span class="p">))</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">stroke</span> <span class="o">=</span> <span class="nx">getFirstConditionValue</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">stroke</span> <span class="o">||</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="o">||</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">stroke</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">filled</span> <span class="o">&amp;&amp;</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">stroke</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">stroke</span> <span class="p">};</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">fill</span> <span class="o">&amp;&amp;</span> <span class="nx">out</span><span class="p">.</span><span class="nx">fill</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="s1">&#39;transparent&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// for non color channel&#39;s legend, we need to override symbol stroke config from Vega config</span>
          <span class="nx">out</span><span class="p">.</span><span class="nx">stroke</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;transparent&#39;</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">!==</span> <span class="nx">SHAPE</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">shape</span> <span class="o">=</span> <span class="nx">getFirstConditionValue</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">shape</span><span class="p">)</span> <span class="o">||</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">shape</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">shape</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">out</span><span class="p">.</span><span class="nx">shape</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">shape</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">!==</span> <span class="nx">OPACITY</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">opacity</span> <span class="o">=</span> <span class="nx">getMaxValue</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">opacity</span><span class="p">)</span> <span class="o">||</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">opacity</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">opacity</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// only apply opacity if it is neither zero or undefined</span>
              <span class="nx">out</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">opacity</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">out</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">symbolsSpec</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">out</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">out</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">gradient</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">gradientSpec</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;gradient&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">opacity</span> <span class="o">=</span> <span class="nx">getMaxValue</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">opacity</span><span class="p">)</span> <span class="o">||</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">opacity</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">opacity</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// only apply opacity if it is neither zero or undefined</span>
              <span class="nx">out</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">opacity</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">out</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">gradientSpec</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">out</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">out</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labels</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">labelsSpec</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">legend</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">legend</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isTimeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">isUTCScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="nx">timeFormatExpression</span><span class="p">(</span><span class="s1">&#39;datum.value&#39;</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">legend</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">legend</span><span class="p">.</span><span class="nx">shortTimeLabels</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">timeFormat</span><span class="p">,</span> <span class="nx">isUTCScale</span><span class="p">);</span>
          <span class="nx">labelsSpec</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">expr</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">text</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">labelsSpec</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">out</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">labelsSpec</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">out</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">out</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getMaxValue</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">getConditionValue</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">conditionalDef</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">conditionalDef</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getFirstConditionValue</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">getConditionValue</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">conditionalDef</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">v</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">v</span> <span class="o">:</span> <span class="nx">conditionalDef</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getConditionValue</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">reducer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span> <span class="o">:</span> <span class="p">[</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">])</span>
              <span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isValueDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">encode</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">symbols</span><span class="o">:</span> <span class="nx">symbols</span><span class="p">,</span>
    <span class="nx">gradient</span><span class="o">:</span> <span class="nx">gradient</span><span class="p">,</span>
    <span class="nx">labels</span><span class="o">:</span> <span class="nx">labels</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">values</span><span class="p">(</span><span class="nx">legend</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">vals$$1</span> <span class="o">=</span> <span class="nx">legend</span><span class="p">.</span><span class="nx">values</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">vals$$1</span> <span class="o">&amp;&amp;</span> <span class="nx">isDateTime</span><span class="p">(</span><span class="nx">vals$$1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">vals$$1</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">dt</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// normalize = true as end user won&#39;t put 0 = January</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">dt</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="p">};</span>
          <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">vals$$1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">type$2</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isColorChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="nx">t</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isBinScale</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="o">||</span>
          <span class="p">(</span><span class="nx">t</span> <span class="o">===</span> <span class="s1">&#39;temporal&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;utc&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">))))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;gradient&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseLegend</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span> <span class="o">=</span> <span class="nx">parseUnitLegend</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span> <span class="o">=</span> <span class="nx">parseNonUnitLegend</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseUnitLegend</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">COLOR</span><span class="p">,</span> <span class="nx">FILL</span><span class="p">,</span> <span class="nx">STROKE</span><span class="p">,</span> <span class="nx">SIZE</span><span class="p">,</span> <span class="nx">SHAPE</span><span class="p">,</span> <span class="nx">OPACITY</span><span class="p">].</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">legendComponent</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">def</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">legend</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">def</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">SHAPE</span> <span class="o">&amp;&amp;</span> <span class="nx">def</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">GEOJSON</span><span class="p">)))</span> <span class="p">{</span>
              <span class="nx">legendComponent</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parseLegendForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">legendComponent</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getLegendDefWithScale</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// For binned field with continuous scale, use a special scale so we can overrride the mark props and labels</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">COLOR</span><span class="o">:</span>
              <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">COLOR</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">filled</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">fill</span><span class="o">:</span> <span class="nx">scale</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">stroke</span><span class="o">:</span> <span class="nx">scale</span> <span class="p">};</span>
          <span class="k">case</span> <span class="nx">FILL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">STROKE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SIZE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SHAPE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">OPACITY</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span> <span class="nx">_a</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseLegendForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">legend</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">legend</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">legendCmpt</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LegendComponent</span><span class="p">({},</span> <span class="nx">getLegendDefWithScale</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
      <span class="nx">LEGEND_PROPERTIES</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">getProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">legend</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">explicit</span> <span class="o">=</span> 
              <span class="c1">// specified legend.values is already respected, but may get transformed.</span>
              <span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;values&#39;</span> <span class="o">?</span> <span class="o">!!</span><span class="nx">legend</span><span class="p">.</span><span class="nx">values</span> <span class="o">:</span>
                  <span class="c1">// title can be explicit if fieldDef.title is set</span>
                  <span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;title&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">===</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">title</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span>
                      <span class="c1">// Otherwise, things are explicit if the returned value matches the specified property</span>
                      <span class="nx">value</span> <span class="o">===</span> <span class="nx">legend</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">explicit</span> <span class="o">||</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">legend</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">legendCmpt</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="c1">// 2) Add mark property definition groups</span>
      <span class="kd">var</span> <span class="nx">legendEncoding</span> <span class="o">=</span> <span class="nx">legend</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">||</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">legendEncode</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="s1">&#39;legend&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;symbols&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">].</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">legendEncodingPart</span> <span class="o">=</span> <span class="nx">guideEncodeEntry</span><span class="p">(</span><span class="nx">legendEncoding</span><span class="p">[</span><span class="nx">part</span><span class="p">]</span> <span class="o">||</span> <span class="p">{},</span> <span class="nx">model</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">encode</span><span class="p">[</span><span class="nx">part</span><span class="p">]</span> <span class="o">?</span>
              <span class="c1">// TODO: replace legendCmpt with type is sufficient</span>
              <span class="nx">encode</span><span class="p">[</span><span class="nx">part</span><span class="p">](</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">legendEncodingPart</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">legendCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">))</span> <span class="o">:</span> <span class="c1">// apply rule</span>
              <span class="nx">legendEncodingPart</span><span class="p">;</span> <span class="c1">// no rule -- just default values</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">value</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">e</span><span class="p">[</span><span class="nx">part</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">e</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">legendEncode</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">legendCmpt</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;encode&#39;</span><span class="p">,</span> <span class="nx">legendEncode</span><span class="p">,</span> <span class="o">!!</span><span class="nx">legend</span><span class="p">.</span><span class="nx">encoding</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">legendCmpt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">specifiedLegend</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;format&#39;</span><span class="o">:</span>
              <span class="c1">// We don&#39;t include temporal field here as we apply format in encode block</span>
              <span class="k">return</span> <span class="nx">numberFormat</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedLegend</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;title&#39;</span><span class="o">:</span>
              <span class="c1">// For falsy value, keep undefined so we use default,</span>
              <span class="c1">// but use null for &#39;&#39;, null, and false to hide the title</span>
              <span class="kd">var</span> <span class="nx">specifiedTitle</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">:</span>
                  <span class="nx">specifiedLegend</span><span class="p">.</span><span class="nx">title</span> <span class="o">||</span> <span class="p">(</span><span class="nx">specifiedLegend</span><span class="p">.</span><span class="nx">title</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="kc">null</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedTitle</span><span class="p">,</span> <span class="nx">title</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">))</span> <span class="o">||</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// make falsy value undefined so output Vega spec is shorter</span>
          <span class="k">case</span> <span class="s1">&#39;values&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">values</span><span class="p">(</span><span class="nx">specifiedLegend</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;type&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedLegend</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">type$2</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)));</span>
      <span class="p">}</span>
      <span class="c1">// Otherwise, return specified property.</span>
      <span class="k">return</span> <span class="nx">specifiedLegend</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseNonUnitLegend</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">,</span> <span class="nx">legends</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">legends</span><span class="p">,</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">resolve</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">parseLegend</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
          <span class="nx">keys</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">resolve</span><span class="p">.</span><span class="nx">legend</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parseGuideResolve</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">legend</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// If the resolve says shared (and has not been overridden)</span>
                  <span class="c1">// We will try to merge and see if there is a conflict</span>
                  <span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">mergeLegendComponent</span><span class="p">(</span><span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">],</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="p">{</span>
                      <span class="c1">// If merge returns nothing, there is a conflict so we cannot make the legend shared.</span>
                      <span class="c1">// Thus, mark legend as independent and remove the legend component.</span>
                      <span class="nx">resolve</span><span class="p">.</span><span class="nx">legend</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;independent&#39;</span><span class="p">;</span>
                      <span class="k">delete</span> <span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">legends</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="p">{</span>
                  <span class="c1">// skip if the child does not have a particular legend</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">legend</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// After merging shared legend, make sure to remove legend from child</span>
                  <span class="k">delete</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">legends</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeLegendComponent</span><span class="p">(</span><span class="nx">mergedLegend</span><span class="p">,</span> <span class="nx">childLegend</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">mergedLegend</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">childLegend</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">mergedOrient</span> <span class="o">=</span> <span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">childOrient</span> <span class="o">=</span> <span class="nx">childLegend</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">mergedOrient</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="nx">childOrient</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="nx">mergedOrient</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="nx">childOrient</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// TODO: throw warning if resolve is explicit (We don&#39;t have info about explicit/implicit resolve yet.)</span>
          <span class="c1">// Cannot merge due to inconsistent orient</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">typeMerged</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_loop_2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">mergedValueWithExplicit</span> <span class="o">=</span> <span class="nx">mergeValuesWithExplicit</span><span class="p">(</span><span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">prop</span><span class="p">),</span> <span class="nx">childLegend</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">prop</span><span class="p">),</span> <span class="nx">prop</span><span class="p">,</span> <span class="s1">&#39;legend&#39;</span><span class="p">,</span> 
          <span class="c1">// Tie breaker function</span>
          <span class="kd">function</span> <span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">switch</span> <span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">case</span> <span class="s1">&#39;title&#39;</span><span class="o">:</span>
                      <span class="k">return</span> <span class="nx">mergeTitleComponent</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">);</span>
                  <span class="k">case</span> <span class="s1">&#39;type&#39;</span><span class="o">:</span>
                      <span class="c1">// There are only two types. If we have different types, then prefer symbol over gradient.</span>
                      <span class="nx">typeMerged</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                      <span class="k">return</span> <span class="nx">makeImplicit</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">defaultTieBreaker</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="s1">&#39;legend&#39;</span><span class="p">);</span>
          <span class="p">});</span>
          <span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">mergedValueWithExplicit</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="c1">// Otherwise, let&#39;s merge</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VG_LEGEND_PROPERTIES_1</span> <span class="o">=</span> <span class="nx">VG_LEGEND_PROPERTIES</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">VG_LEGEND_PROPERTIES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VG_LEGEND_PROPERTIES_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">_loop_2</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">typeMerged</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(((</span><span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">implicit</span> <span class="o">||</span> <span class="p">{}).</span><span class="nx">encode</span> <span class="o">||</span> <span class="p">{}).</span><span class="nx">gradient</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">deleteNestedProperty</span><span class="p">(</span><span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">implicit</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;encode&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">]);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(((</span><span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">||</span> <span class="p">{}).</span><span class="nx">encode</span> <span class="o">||</span> <span class="p">{}).</span><span class="nx">gradient</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">deleteNestedProperty</span><span class="p">(</span><span class="nx">mergedLegend</span><span class="p">.</span><span class="nx">explicit</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;encode&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">]);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">mergedLegend</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">assembleLegends</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">legendComponentIndex</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">legends</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">legendByDomain</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">legendComponentIndex</span><span class="p">);</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">domainHash</span> <span class="o">=</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">domains</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">legendByDomain</span><span class="p">[</span><span class="nx">domainHash</span><span class="p">])</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">legendByDomain</span><span class="p">[</span><span class="nx">domainHash</span><span class="p">];</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">mergedLegendComponent</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
                  <span class="kd">var</span> <span class="nx">merged</span> <span class="o">=</span> <span class="nx">mergeLegendComponent</span><span class="p">(</span><span class="nx">mergedLegendComponent</span><span class="p">,</span> <span class="nx">legendComponentIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// If cannot merge, need to add this legend separately</span>
                      <span class="nx">legendByDomain</span><span class="p">[</span><span class="nx">domainHash</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">legendComponentIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">legendByDomain</span><span class="p">[</span><span class="nx">domainHash</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">legendComponentIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">clone</span><span class="p">()];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">vals</span><span class="p">(</span><span class="nx">legendByDomain</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">legendCmpt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">legendCmpt</span><span class="p">.</span><span class="nx">combine</span><span class="p">();</span> <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">assembleProjections</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isConcatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isRepeatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleProjectionsForModelAndChildren</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleProjectionForModel</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleProjectionsForModelAndChildren</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">projections</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">projections</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleProjections</span><span class="p">());</span>
      <span class="p">},</span> <span class="nx">assembleProjectionForModel</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleProjectionForModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">component</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">component</span> <span class="o">||</span> <span class="nx">component</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[];</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">combine</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">projection</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">rest</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">projection</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]);</span> <span class="c1">// we need to extract name so that it is always present in the output and pass TS type validation</span>
      <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">component</span><span class="p">.</span><span class="nx">size</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">ref</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">signal</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
      <span class="p">};</span>
      <span class="kd">var</span> <span class="nx">fit</span> <span class="o">=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sources</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">source</span> <span class="o">=</span> <span class="nx">isVgSignalRef</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">?</span> <span class="nx">data</span><span class="p">.</span><span class="nx">signal</span> <span class="o">:</span> <span class="s2">&quot;data(&#39;&quot;</span> <span class="o">+</span> <span class="nx">model</span><span class="p">.</span><span class="nx">lookupDataSource</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;)&quot;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">contains</span><span class="p">(</span><span class="nx">sources</span><span class="p">,</span> <span class="nx">source</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// build a unique list of sources</span>
              <span class="nx">sources</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">source</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">sources</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">[]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fit</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Projection&#39;s fit didn&#39;t find any data sources&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span>
              <span class="nx">size</span><span class="o">:</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">fit</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">signal</span><span class="o">:</span> <span class="nx">fit</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">fit</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="o">:</span> <span class="nx">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
              <span class="p">}</span> <span class="p">},</span> <span class="nx">rest</span><span class="p">)];</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">PROJECTION_PROPERTIES</span> <span class="o">=</span> <span class="p">[</span>
      <span class="s1">&#39;type&#39;</span><span class="p">,</span>
      <span class="s1">&#39;clipAngle&#39;</span><span class="p">,</span>
      <span class="s1">&#39;clipExtent&#39;</span><span class="p">,</span>
      <span class="s1">&#39;center&#39;</span><span class="p">,</span>
      <span class="s1">&#39;rotate&#39;</span><span class="p">,</span>
      <span class="s1">&#39;precision&#39;</span><span class="p">,</span>
      <span class="s1">&#39;coefficient&#39;</span><span class="p">,</span>
      <span class="s1">&#39;distance&#39;</span><span class="p">,</span>
      <span class="s1">&#39;fraction&#39;</span><span class="p">,</span>
      <span class="s1">&#39;lobes&#39;</span><span class="p">,</span>
      <span class="s1">&#39;parallel&#39;</span><span class="p">,</span>
      <span class="s1">&#39;radius&#39;</span><span class="p">,</span>
      <span class="s1">&#39;ratio&#39;</span><span class="p">,</span>
      <span class="s1">&#39;spacing&#39;</span><span class="p">,</span>
      <span class="s1">&#39;tilt&#39;</span>
  <span class="p">];</span>

  <span class="kd">var</span> <span class="nx">ProjectionComponent</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">ProjectionComponent</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">ProjectionComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">specifiedProjection</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">specifiedProjection</span><span class="p">),</span> <span class="c1">// all explicit properties of projection</span>
          <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="p">}</span> <span class="c1">// name as initial implicit property</span>
          <span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedProjection</span> <span class="o">=</span> <span class="nx">specifiedProjection</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="nx">size</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">merged</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">ProjectionComponent</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Split</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">parseProjection</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span> <span class="o">=</span> <span class="nx">parseUnitProjection</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// because parse happens from leaves up (unit specs before layer spec),</span>
          <span class="c1">// we can be sure that the above if statement has already occurred</span>
          <span class="c1">// and therefore we have access to child.component.projection</span>
          <span class="c1">// for each of model&#39;s children</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span> <span class="o">=</span> <span class="nx">parseNonUnitProjections</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseUnitProjection</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">specifiedProjection</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">specifiedProjection</span><span class="p">,</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">hasProjection</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">hasProjection</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasProjection</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">data_1</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="p">[[</span><span class="nx">LONGITUDE</span><span class="p">,</span> <span class="nx">LATITUDE</span><span class="p">],</span> <span class="p">[</span><span class="nx">LONGITUDE2</span><span class="p">,</span> <span class="nx">LATITUDE2</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">posssiblePair</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">posssiblePair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">posssiblePair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
                  <span class="nx">data_1</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                      <span class="nx">signal</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s2">&quot;geojson_&quot;</span> <span class="o">+</span> <span class="nx">data_1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
                  <span class="p">});</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">SHAPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">SHAPE</span><span class="p">).</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">GEOJSON</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">data_1</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                  <span class="nx">signal</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s2">&quot;geojson_&quot;</span> <span class="o">+</span> <span class="nx">data_1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">data_1</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// main source is geojson, so we can just use that</span>
              <span class="nx">data_1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">ProjectionComponent</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">projectionName</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">projection</span> <span class="o">||</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">specifiedProjection</span> <span class="o">||</span> <span class="p">{})),</span> <span class="p">[</span><span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)],</span> <span class="nx">data_1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeIfNoConflict</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">allPropertiesShared</span> <span class="o">=</span> <span class="nx">every</span><span class="p">(</span><span class="nx">PROJECTION_PROPERTIES</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// neither has the poperty</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">first</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="o">!</span><span class="nx">second</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// both have property and an equal value for property</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="nx">second</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="c1">// some properties might be signals or objects and require hashing for comparison</span>
              <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">first</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">prop</span><span class="p">))</span> <span class="o">===</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">second</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">prop</span><span class="p">)))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">first</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="o">===</span> <span class="nx">stringify$2</span><span class="p">(</span><span class="nx">second</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">allPropertiesShared</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">first</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">stringify$2</span><span class="p">(</span><span class="nx">first</span><span class="p">.</span><span class="nx">explicit</span><span class="p">)</span> <span class="o">===</span> <span class="nx">stringify$2</span><span class="p">({}))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">second</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">stringify$2</span><span class="p">(</span><span class="nx">second</span><span class="p">.</span><span class="nx">explicit</span><span class="p">)</span> <span class="o">===</span> <span class="nx">stringify$2</span><span class="p">({}))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">first</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// if all properties don&#39;t match, let each unit spec have its own projection</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseNonUnitProjections</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">nonUnitProjection</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">mergable</span> <span class="o">=</span> <span class="nx">every</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">parseProjection</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">projection</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// child layer does not use a projection</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nonUnitProjection</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// cached &#39;projection&#39; is null, cache this one</span>
              <span class="nx">nonUnitProjection</span> <span class="o">=</span> <span class="nx">projection</span><span class="p">;</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">merge</span> <span class="o">=</span> <span class="nx">mergeIfNoConflict</span><span class="p">(</span><span class="nx">nonUnitProjection</span><span class="p">,</span> <span class="nx">projection</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">merge</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">nonUnitProjection</span> <span class="o">=</span> <span class="nx">merge</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="o">!!</span><span class="nx">merge</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="c1">// it cached one and all other children share the same projection,</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">nonUnitProjection</span> <span class="o">&amp;&amp;</span> <span class="nx">mergable</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// so we can elevate it to the layer level</span>
          <span class="kd">var</span> <span class="nx">name_1</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">projectionName</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">modelProjection_1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ProjectionComponent</span><span class="p">(</span><span class="nx">name_1</span><span class="p">,</span> <span class="nx">nonUnitProjection</span><span class="p">.</span><span class="nx">specifiedProjection</span><span class="p">,</span> <span class="nx">nonUnitProjection</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="nx">nonUnitProjection</span><span class="p">.</span><span class="nx">data</span><span class="p">));</span>
          <span class="c1">// rename and assign all others as merged</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">modelProjection_1</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">modelProjection_1</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
                  <span class="nx">child</span><span class="p">.</span><span class="nx">renameProjection</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">),</span> <span class="nx">name_1</span><span class="p">);</span>
                  <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">.</span><span class="nx">merged</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">modelProjection_1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isSortField</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">sort</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">sort</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">sort</span><span class="p">[</span><span class="s1">&#39;field&#39;</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">sort</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isSortArray</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">sort</span> <span class="o">&amp;&amp;</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">sort</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isSortField</span><span class="o">:</span> <span class="nx">isSortField</span><span class="p">,</span>
    <span class="nx">isSortArray</span><span class="o">:</span> <span class="nx">isSortArray</span>
  <span class="p">});</span>

  <span class="cm">/**</span>
<span class="cm">   * A node in the dataflow tree.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">DataFlowNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">DataFlowNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">debugName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">debugName</span> <span class="o">=</span> <span class="nx">debugName</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_children</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_parent</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="cm">/**</span>
<span class="cm">       * Clone this node with a deep copy but don&#39;t clone links to children or parents.</span>
<span class="cm">       */</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Cannot clone node&#39;</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Set of fields that are being created by this node.</span>
<span class="cm">       */</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{};</span>
      <span class="p">};</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dependentFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{};</span>
      <span class="p">};</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_parent</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="cm">/**</span>
<span class="cm">           * Set the parent of the node and also add this not to the parent&#39;s children.</span>
<span class="cm">           */</span>
          <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">_parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
              <span class="nx">parent</span><span class="p">.</span><span class="nx">addChild</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">numChildren</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addChild</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">removeChild</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldChild</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">oldChild</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Remove node from the dataflow.</span>
<span class="cm">       */</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_parent</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Insert another node as a parent of this node.</span>
<span class="cm">       */</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">insertAsParentOf</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">other</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
          <span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
          <span class="nx">other</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">DataFlowNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">swapWithParent</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_parent</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">newParent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
          <span class="c1">// reconnect the children</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// remove old links</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_children</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// equivalent to removing every child link one by one</span>
          <span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="nx">parent</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span>
          <span class="c1">// swap two nodes</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">newParent</span><span class="p">;</span>
          <span class="nx">parent</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">DataFlowNode</span><span class="p">;</span>
  <span class="p">}());</span>
  <span class="kd">var</span> <span class="nx">OutputNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">OutputNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="cm">/**</span>
<span class="cm">       * @param source The name of the source. Will change in assemble.</span>
<span class="cm">       * @param type The type of the output node.</span>
<span class="cm">       * @param refCounts A global ref counter map.</span>
<span class="cm">       */</span>
      <span class="kd">function</span> <span class="nx">OutputNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">refCounts</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">source</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">refCounts</span> <span class="o">=</span> <span class="nx">refCounts</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">_source</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">source</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">_this</span><span class="p">.</span><span class="nx">refCounts</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">_this</span><span class="p">.</span><span class="nx">_name</span> <span class="k">in</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">refCounts</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">refCounts</span><span class="p">[</span><span class="nx">_this</span><span class="p">.</span><span class="nx">_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">OutputNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">cloneObj</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>
          <span class="nx">cloneObj</span><span class="p">.</span><span class="nx">debugName</span> <span class="o">=</span> <span class="s1">&#39;clone_&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">debugName</span><span class="p">;</span>
          <span class="nx">cloneObj</span><span class="p">.</span><span class="nx">_source</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">;</span>
          <span class="nx">cloneObj</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="s1">&#39;clone_&#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
          <span class="nx">cloneObj</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
          <span class="nx">cloneObj</span><span class="p">.</span><span class="nx">refCounts</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">refCounts</span><span class="p">;</span>
          <span class="nx">cloneObj</span><span class="p">.</span><span class="nx">refCounts</span><span class="p">[</span><span class="nx">cloneObj</span><span class="p">.</span><span class="nx">_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">cloneObj</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Request the datasource name and increase the ref counter.</span>
<span class="cm">       *</span>
<span class="cm">       * During the parsing phase, this will return the simple name such as &#39;main&#39; or &#39;raw&#39;.</span>
<span class="cm">       * It is crucial to request the name from an output node to mark it as a required node.</span>
<span class="cm">       * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.</span>
<span class="cm">       *</span>
<span class="cm">       * In the assemble phase, this will return the correct name.</span>
<span class="cm">       */</span>
      <span class="nx">OutputNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSource</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">refCounts</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_source</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">OutputNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">isRequired</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">!!</span><span class="k">this</span><span class="p">.</span><span class="nx">refCounts</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">OutputNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setSource</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_source</span> <span class="o">=</span> <span class="nx">source</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">OutputNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="cm">/**</span>
<span class="cm">   * We don&#39;t know what a calculate node depends on so we should never move it beyond anything that produces fields.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">CalculateNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">CalculateNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">CalculateNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">transform</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">CalculateNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">parseAllForSortIndex</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// get all the encoding with sort fields from model</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">forEachFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isScaleFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isSortArray</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">))</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">transform</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">calculate</span><span class="o">:</span> <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">calculateExpressionFromSortField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">),</span>
                      <span class="nx">as</span><span class="o">:</span> <span class="nx">sortArrayIndexField</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span>
                  <span class="p">};</span>
                  <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CalculateNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">transform</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">calculateExpressionFromSortField</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="nx">sortFields</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">expression</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">sortFields</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">expression</span> <span class="o">+=</span> <span class="s2">&quot;datum.&quot;</span> <span class="o">+</span> <span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot; === &#39;&quot;</span> <span class="o">+</span> <span class="nx">sortFields</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;&#39; ? &quot;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s2">&quot; : &quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">expression</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">expression</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">out</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;formula&#39;</span><span class="p">,</span>
              <span class="nx">expr</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">calculate</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">CalculateNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>
  <span class="kd">function</span> <span class="nx">sortArrayIndexField</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_sort_index&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">addDimension</span><span class="p">(</span><span class="nx">dims</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">dims</span><span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{})]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="nx">dims</span><span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">})]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">binRequiresRange</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">dims</span><span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">})]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">dims</span><span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">dims</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeMeasures</span><span class="p">(</span><span class="nx">parentMeasures</span><span class="p">,</span> <span class="nx">childMeasures</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">f</span> <span class="k">in</span> <span class="nx">childMeasures</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">childMeasures</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// when we merge a measure, we either have to add an aggregation operator or even a new field</span>
              <span class="kd">var</span> <span class="nx">ops</span> <span class="o">=</span> <span class="nx">childMeasures</span><span class="p">[</span><span class="nx">f</span><span class="p">];</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">op</span> <span class="k">in</span> <span class="nx">ops</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">ops</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">op</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">f</span> <span class="k">in</span> <span class="nx">parentMeasures</span><span class="p">)</span> <span class="p">{</span>
                          <span class="c1">// add operator to existing measure field</span>
                          <span class="nx">parentMeasures</span><span class="p">[</span><span class="nx">f</span><span class="p">][</span><span class="nx">op</span><span class="p">]</span> <span class="o">=</span> <span class="nx">ops</span><span class="p">[</span><span class="nx">op</span><span class="p">];</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="p">{</span>
                          <span class="nx">parentMeasures</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">op</span><span class="o">:</span> <span class="nx">ops</span><span class="p">[</span><span class="nx">op</span><span class="p">]</span> <span class="p">};</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">AggregateNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">AggregateNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="cm">/**</span>
<span class="cm">       * @param dimensions string set for dimensions</span>
<span class="cm">       * @param measures dictionary mapping field name =&gt; dict of aggregation functions and names to use</span>
<span class="cm">       */</span>
      <span class="kd">function</span> <span class="nx">AggregateNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">dimensions</span><span class="p">,</span> <span class="nx">measures</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">dimensions</span> <span class="o">=</span> <span class="nx">dimensions</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">measures</span> <span class="o">=</span> <span class="nx">measures</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">AggregateNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">dimensions</span><span class="p">),</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">isAggregate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">forEachFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fd</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">isAggregate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">meas</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">dims</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isAggregate</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// no need to create this node if the model has no aggregation</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">forEachFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">,</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">aggregate</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">meas</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">][</span><span class="nx">aggregate</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">);</span>
                      <span class="c1">// For scale channel with domain === &#39;unaggregated&#39;, add min/max so we can use their union as unaggregated domain</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleDomain</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;unaggregated&#39;</span><span class="p">)</span> <span class="p">{</span>
                          <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">][</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">({</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="s1">&#39;min&#39;</span> <span class="p">});</span>
                          <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">][</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">({</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="s1">&#39;max&#39;</span> <span class="p">});</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">addDimension</span><span class="p">(</span><span class="nx">dims</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">((</span><span class="nx">keys</span><span class="p">(</span><span class="nx">dims</span><span class="p">).</span><span class="nx">length</span> <span class="o">+</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">meas</span><span class="p">).</span><span class="nx">length</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">AggregateNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">dims</span><span class="p">,</span> <span class="nx">meas</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">makeFromTransform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">dims</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">meas</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">op</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">op</span><span class="p">,</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">as</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">as</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">op</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">meas</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">][</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">as</span> <span class="o">||</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
                      <span class="nx">meas</span><span class="p">[</span><span class="nx">field</span><span class="p">][</span><span class="nx">op</span><span class="p">]</span> <span class="o">=</span> <span class="nx">as</span> <span class="o">||</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">groupby</span> <span class="o">||</span> <span class="p">[];</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
              <span class="nx">dims</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">((</span><span class="nx">keys</span><span class="p">(</span><span class="nx">dims</span><span class="p">).</span><span class="nx">length</span> <span class="o">+</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">meas</span><span class="p">).</span><span class="nx">length</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">AggregateNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">dims</span><span class="p">,</span> <span class="nx">meas</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">differ</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dimensions</span><span class="p">,</span> <span class="nx">other</span><span class="p">.</span><span class="nx">dimensions</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">mergeMeasures</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">,</span> <span class="nx">other</span><span class="p">.</span><span class="nx">measures</span><span class="p">);</span>
              <span class="nx">other</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">debug</span><span class="p">(</span><span class="s1">&#39;different dimensions, cannot merge&#39;</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addDimensions</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fields</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">fields</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">dimensions</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dependentFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dimensions</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
          <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">out</span><span class="p">[</span><span class="nx">m</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">keys</span><span class="p">(</span><span class="nx">_this</span><span class="p">.</span><span class="nx">measures</span><span class="p">[</span><span class="nx">field</span><span class="p">]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">out</span><span class="p">[</span><span class="nx">op</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">});</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">ops</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">as</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">);</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">[</span><span class="nx">field</span><span class="p">]);</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">op</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
                  <span class="nx">as</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">measures</span><span class="p">[</span><span class="nx">field</span><span class="p">][</span><span class="nx">op</span><span class="p">]);</span>
                  <span class="nx">ops</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">op</span><span class="p">);</span>
                  <span class="nx">fields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">field</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span>
              <span class="nx">groupby</span><span class="o">:</span> <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dimensions</span><span class="p">),</span>
              <span class="nx">ops</span><span class="o">:</span> <span class="nx">ops</span><span class="p">,</span>
              <span class="nx">fields</span><span class="o">:</span> <span class="nx">fields</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="nx">as</span>
          <span class="p">};</span>
          <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">AggregateNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="cm">/**</span>
<span class="cm">   * A node that helps us track what fields we are faceting by.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">FacetNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">FacetNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="cm">/**</span>
<span class="cm">       * @param model The facet model.</span>
<span class="cm">       * @param name The name that this facet source will have.</span>
<span class="cm">       * @param data The source data for this facet data.</span>
<span class="cm">       */</span>
      <span class="kd">function</span> <span class="nx">FacetNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">column</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">columnFields</span> <span class="o">=</span> <span class="p">[</span><span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">COLUMN</span><span class="p">)];</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">columnName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;column_domain&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">COLUMN</span><span class="p">).</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">_this</span><span class="p">.</span><span class="nx">columnFields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">COLUMN</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">}));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">row</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">rowFields</span> <span class="o">=</span> <span class="p">[</span><span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">ROW</span><span class="p">)];</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">rowName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;row_domain&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">ROW</span><span class="p">).</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">_this</span><span class="p">.</span><span class="nx">rowFields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">ROW</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">}));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">childModel</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">child</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">FacetNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;fields&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">[];</span>
              <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">columnFields</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fields</span> <span class="o">=</span> <span class="nx">fields</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">columnFields</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rowFields</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fields</span> <span class="o">=</span> <span class="nx">fields</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rowFields</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">fields</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="cm">/**</span>
<span class="cm">       * The name to reference this source is its name.</span>
<span class="cm">       */</span>
      <span class="nx">FacetNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSource</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">FacetNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getChildIndependentFieldsWithStep</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">childIndependentFieldsWithStep</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">];</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">childScaleComponent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">childModel</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">childScaleComponent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">childScaleComponent</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">childScaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                  <span class="kd">var</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">childScaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">range</span><span class="p">))</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">assembleDomain</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">childModel</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
                      <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">getFieldFromDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
                          <span class="nx">childIndependentFieldsWithStep</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">field</span><span class="p">;</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="p">{</span>
                          <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Unknown field for </span><span class="cp">${</span><span class="n">channel</span><span class="cp">}</span><span class="s1">.  Cannot calculate view size.&#39;</span><span class="p">);</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">FacetNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleRowColumnData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">crossedDataName</span><span class="p">,</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">aggregateChildField</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">childChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="s1">&#39;y&#39;</span> <span class="o">:</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">childIndependentFieldsWithStep</span><span class="p">[</span><span class="nx">childChannel</span><span class="p">])</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">crossedDataName</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">aggregateChildField</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="c1">// If there is a crossed data, calculate max</span>
                      <span class="nx">fields</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;distinct_&quot;</span> <span class="o">+</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">[</span><span class="nx">childChannel</span><span class="p">]],</span>
                      <span class="nx">ops</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">],</span>
                      <span class="c1">// Although it is technically a max, just name it distinct so it&#39;s easier to refer to it</span>
                      <span class="nx">as</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;distinct_&quot;</span> <span class="o">+</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">[</span><span class="nx">childChannel</span><span class="p">]]</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">aggregateChildField</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="c1">// If there is no crossed data, just calculate distinct</span>
                      <span class="nx">fields</span><span class="o">:</span> <span class="p">[</span><span class="nx">childIndependentFieldsWithStep</span><span class="p">[</span><span class="nx">childChannel</span><span class="p">]],</span>
                      <span class="nx">ops</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;distinct&#39;</span><span class="p">]</span>
                  <span class="p">};</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">rowName</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">columnName</span><span class="p">,</span>
              <span class="c1">// Use data from the crossed one if it exist</span>
              <span class="nx">source</span><span class="o">:</span> <span class="nx">crossedDataName</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span>
              <span class="nx">transform</span><span class="o">:</span> <span class="p">[</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span> <span class="nx">groupby</span><span class="o">:</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">rowFields</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">columnFields</span> <span class="p">},</span> <span class="nx">aggregateChildField</span><span class="p">)]</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="nx">FacetNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">crossedDataName</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">childIndependentFieldsWithStep</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getChildIndependentFieldsWithStep</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">columnName</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">rowName</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">childIndependentFieldsWithStep</span><span class="p">.</span><span class="nx">x</span> <span class="o">||</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">.</span><span class="nx">y</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// Need to create a cross dataset to correctly calculate cardinality</span>
              <span class="nx">crossedDataName</span> <span class="o">=</span> <span class="s2">&quot;cross_&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">columnName</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">rowName</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">childIndependentFieldsWithStep</span><span class="p">.</span><span class="nx">x</span> <span class="o">?</span> <span class="p">[</span><span class="nx">childIndependentFieldsWithStep</span><span class="p">.</span><span class="nx">x</span><span class="p">]</span> <span class="o">:</span> <span class="p">[],</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">.</span><span class="nx">y</span> <span class="o">?</span> <span class="p">[</span><span class="nx">childIndependentFieldsWithStep</span><span class="p">.</span><span class="nx">y</span><span class="p">]</span> <span class="o">:</span> <span class="p">[]);</span>
              <span class="kd">var</span> <span class="nx">ops</span> <span class="o">=</span> <span class="nx">fields</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s1">&#39;distinct&#39;</span><span class="p">;</span> <span class="p">});</span>
              <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                  <span class="nx">name</span><span class="o">:</span> <span class="nx">crossedDataName</span><span class="p">,</span>
                  <span class="nx">source</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span>
                  <span class="nx">transform</span><span class="o">:</span> <span class="p">[{</span>
                          <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;aggregate&#39;</span><span class="p">,</span>
                          <span class="nx">groupby</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">columnFields</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rowFields</span><span class="p">),</span>
                          <span class="nx">fields</span><span class="o">:</span> <span class="nx">fields</span><span class="p">,</span>
                          <span class="nx">ops</span><span class="o">:</span> <span class="nx">ops</span>
                      <span class="p">}]</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">columnName</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">assembleRowColumnData</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="nx">crossedDataName</span><span class="p">,</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rowName</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">assembleRowColumnData</span><span class="p">(</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="nx">crossedDataName</span><span class="p">,</span> <span class="nx">childIndependentFieldsWithStep</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">FacetNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">FilterInvalidNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">FilterInvalidNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">FilterInvalidNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">fieldDefs</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">fieldDefs</span> <span class="o">=</span> <span class="nx">fieldDefs</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">FilterInvalidNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">FilterInvalidNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">fieldDefs</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">FilterInvalidNode</span><span class="p">.</span><span class="nx">make</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">invalidValues</span> <span class="o">!==</span> <span class="s1">&#39;filter&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">filter</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">reduceFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">aggregator</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleComponent</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                  <span class="c1">// While discrete domain scales can handle invalid values, continuous scales can&#39;t.</span>
                  <span class="c1">// Thus, for non-path marks, we have to filter null for scales with continuous domains.</span>
                  <span class="c1">// (For path marks, we will use &quot;defined&quot; property and skip these values instead.)</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isPathMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">aggregator</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">aggregator</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">keys</span><span class="p">(</span><span class="nx">filter</span><span class="p">).</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">FilterInvalidNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">filter</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">FilterInvalidNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;filter&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">fieldDefs</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="c1">// create the VgTransforms for each of the filtered fields</span>
      <span class="nx">FilterInvalidNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">filters</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">filter</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">vegaFilters</span><span class="p">,</span> <span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">fieldDefs</span><span class="p">[</span><span class="nx">field</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">});</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">vegaFilters</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">ref</span> <span class="o">+</span> <span class="s2">&quot; !== null&quot;</span><span class="p">);</span>
                  <span class="nx">vegaFilters</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;!isNaN(&quot;</span> <span class="o">+</span> <span class="nx">ref</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">vegaFilters</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">[]);</span>
          <span class="k">return</span> <span class="nx">filters</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span>
              <span class="p">{</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;filter&#39;</span><span class="p">,</span>
                  <span class="nx">expr</span><span class="o">:</span> <span class="nx">filters</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">)</span>
              <span class="p">}</span> <span class="o">:</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">FilterInvalidNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="cm">/**</span>
<span class="cm">   * @param field The field.</span>
<span class="cm">   * @param parse What to parse the field as.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">parseExpression</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;toNumber(&quot;</span> <span class="o">+</span> <span class="nx">f</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span> <span class="o">===</span> <span class="s1">&#39;boolean&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;toBoolean(&quot;</span> <span class="o">+</span> <span class="nx">f</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;toString(&quot;</span> <span class="o">+</span> <span class="nx">f</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span> <span class="o">===</span> <span class="s1">&#39;date&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s2">&quot;toDate(&quot;</span> <span class="o">+</span> <span class="nx">f</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span> <span class="o">===</span> <span class="s1">&#39;flatten&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;date:&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">specifier</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nx">parse</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
          <span class="k">return</span> <span class="s2">&quot;timeParse(&quot;</span> <span class="o">+</span> <span class="nx">f</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nx">specifier</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;utc:&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">specifier</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nx">parse</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
          <span class="k">return</span> <span class="s2">&quot;utcParse(&quot;</span> <span class="o">+</span> <span class="nx">f</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nx">specifier</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">unrecognizedParse</span><span class="p">(</span><span class="nx">parse</span><span class="p">));</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">ParseNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">ParseNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">ParseNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">_parse</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">ParseNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Creates a parse node from a data.format.parse and updates ancestorParse.</span>
<span class="cm">       */</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeExplicit</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Custom parse</span>
          <span class="kd">var</span> <span class="nx">explicit</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">data</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">format</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">.</span><span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">explicit</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">.</span><span class="nx">parse</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">makeWithAncestors</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">,</span> <span class="p">{},</span> <span class="nx">ancestorParse</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeImplicitFromFilterTransform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">parse</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">forEachLeaf</span><span class="p">(</span><span class="nx">transform</span><span class="p">.</span><span class="nx">filter</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">filter</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldPredicate</span><span class="p">(</span><span class="nx">filter</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// Automatically add a parse node for filters with filter objects</span>
                  <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                  <span class="c1">// For EqualFilter, just use the equal property.</span>
                  <span class="c1">// For RangeFilter and OneOfFilter, all array members should have</span>
                  <span class="c1">// the same type, so we only use the first one.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldEqualPredicate</span><span class="p">(</span><span class="nx">filter</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">val</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">.</span><span class="nx">equal</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldRangePredicate</span><span class="p">(</span><span class="nx">filter</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">val</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">.</span><span class="nx">range</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldOneOfPredicate</span><span class="p">(</span><span class="nx">filter</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">val</span> <span class="o">=</span> <span class="p">(</span><span class="nx">filter</span><span class="p">.</span><span class="nx">oneOf</span> <span class="o">||</span> <span class="nx">filter</span><span class="p">[</span><span class="s1">&#39;in&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">];</span>
                  <span class="p">}</span> <span class="c1">// else -- for filter expression, we can&#39;t infer anything</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">isDateTime</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">parse</span><span class="p">[</span><span class="nx">filter</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;date&#39;</span><span class="p">;</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">parse</span><span class="p">[</span><span class="nx">filter</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;number&#39;</span><span class="p">;</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">parse</span><span class="p">[</span><span class="nx">filter</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span><span class="p">;</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">filter</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">parse</span><span class="p">[</span><span class="nx">filter</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;date&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">parse</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">makeWithAncestors</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">{},</span> <span class="nx">parse</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Creates a parse node for implicit parsing from a model and updates ancestorParse.</span>
<span class="cm">       */</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeImplicitFromEncoding</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">implicit</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// Parse encoded fields</span>
              <span class="nx">model</span><span class="p">.</span><span class="nx">forEachFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">isTimeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">implicit</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;date&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isNumberFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isCountingAggregateOp</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">implicit</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;number&#39;</span><span class="p">;</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">accessPathDepth</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.</span>
                      <span class="c1">// (Parsing numbers / dates already flattens numeric and temporal fields.)</span>
                      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span> <span class="k">in</span> <span class="nx">implicit</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">implicit</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;flatten&#39;</span><span class="p">;</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isScaleFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isSortField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">accessPathDepth</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// Flatten fields that we sort by but that are not otherwise flattened.</span>
                      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">.</span><span class="nx">field</span> <span class="k">in</span> <span class="nx">implicit</span><span class="p">))</span> <span class="p">{</span>
                          <span class="nx">implicit</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;flatten&#39;</span><span class="p">;</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">makeWithAncestors</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">{},</span> <span class="nx">implicit</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Creates a parse node from &quot;explicit&quot; parse and &quot;implicit&quot; parse and updates ancestorParse.</span>
<span class="cm">       */</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeWithAncestors</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as &quot;derived&quot;). We also don&#39;t need to flatten a field that has already been parsed.</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">implicit</span><span class="p">);</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">parsedAs</span> <span class="o">=</span> <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">parsedAs</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">parsedAs</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">||</span> <span class="nx">parsedAs</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="nx">implicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">]</span> <span class="o">||</span> <span class="nx">parsedAs</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;derived&#39;</span> <span class="o">||</span> <span class="nx">implicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;flatten&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">delete</span> <span class="nx">implicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">];</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">differentParse</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">],</span> <span class="nx">parsedAs</span><span class="p">.</span><span class="nx">value</span><span class="p">));</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">explicit</span><span class="p">);</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">parsedAs</span> <span class="o">=</span> <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">parsedAs</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Don&#39;t parse a field again if it has been parsed with the same type already.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">parsedAs</span> <span class="o">===</span> <span class="nx">explicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">])</span> <span class="p">{</span>
                      <span class="k">delete</span> <span class="nx">explicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">];</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">differentParse</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">],</span> <span class="nx">parsedAs</span><span class="p">));</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">parse</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Split</span><span class="p">(</span><span class="nx">explicit</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">);</span>
          <span class="c1">// add the format parse from this model so that children don&#39;t parse the same field again</span>
          <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">copyAll</span><span class="p">(</span><span class="nx">parse</span><span class="p">);</span>
          <span class="c1">// copy only non-null parses</span>
          <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_e</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">parse</span><span class="p">.</span><span class="nx">combine</span><span class="p">());</span> <span class="nx">_d</span> <span class="o">&lt;</span> <span class="nx">_e</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">_e</span><span class="p">[</span><span class="nx">_d</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key$$1</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">p</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">p</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">parseNothing</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">ParseNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">p</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;parse&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_parse</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">,</span> <span class="nx">other</span><span class="p">.</span><span class="nx">parse</span><span class="p">);</span>
          <span class="nx">other</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Assemble an object for Vega&#39;s format.parse property.</span>
<span class="cm">       */</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleFormatParse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">formatParse</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">);</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">accessPathDepth</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">formatParse</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">formatParse</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="c1">// format parse depends and produces all fields in its parse</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dependentFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">toSet</span><span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleTransforms</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">onlyNested</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">onlyNested</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">onlyNested</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
          <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">)</span>
              <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">onlyNested</span> <span class="o">?</span> <span class="nx">accessPathDepth</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="kc">true</span><span class="p">;</span> <span class="p">})</span>
              <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="nx">parseExpression</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">_parse</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">]);</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="kd">var</span> <span class="nx">formula</span> <span class="o">=</span> <span class="p">{</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;formula&#39;</span><span class="p">,</span>
                  <span class="nx">expr</span><span class="o">:</span> <span class="nx">expr</span><span class="p">,</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="nx">removePathFromField</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="c1">// Vega output is always flattened</span>
              <span class="p">};</span>
              <span class="k">return</span> <span class="nx">formula</span><span class="p">;</span>
          <span class="p">}).</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">t</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">;</span> <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">ParseNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">SourceNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">SourceNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">SourceNode</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">||</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;source&#39;</span> <span class="p">};</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isInlineData</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">_data</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">values</span><span class="o">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">values</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isUrlData</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">_data</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">url</span><span class="o">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">url</span> <span class="p">};</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">data</span><span class="p">.</span><span class="nx">format</span> <span class="o">=</span> <span class="p">{};</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">data</span><span class="p">.</span><span class="nx">format</span> <span class="o">||</span> <span class="o">!</span><span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Extract extension from URL using snippet from</span>
                  <span class="c1">// http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript</span>
                  <span class="kd">var</span> <span class="nx">defaultExtension</span> <span class="o">=</span> <span class="sr">/(?:\.([^.]+))?$/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">url</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;json&#39;</span><span class="p">,</span> <span class="s1">&#39;csv&#39;</span><span class="p">,</span> <span class="s1">&#39;tsv&#39;</span><span class="p">,</span> <span class="s1">&#39;dsv&#39;</span><span class="p">,</span> <span class="s1">&#39;topojson&#39;</span><span class="p">],</span> <span class="nx">defaultExtension</span><span class="p">))</span> <span class="p">{</span>
                      <span class="nx">defaultExtension</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// defaultExtension has type string but we ensure that it is DataFormatType above</span>
                  <span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">defaultExtension</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isNamedData</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">_data</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="p">}</span>
          <span class="c1">// any dataset can be named</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">parse</span><span class="p">,</span> <span class="nx">format</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">_a</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;parse&quot;</span><span class="p">]);</span>
              <span class="nx">_this</span><span class="p">.</span><span class="nx">_data</span><span class="p">.</span><span class="nx">format</span> <span class="o">=</span> <span class="nx">format</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">!!</span><span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;dataName&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Source nodes have to be roots.&#39;</span><span class="p">);</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">remove</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Source nodes are roots and cannot be removed.&#39;</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Return a unique identifier for this data source.</span>
<span class="cm">       */</span>
      <span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hash</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isInlineData</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">_hash</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Hashing can be expensive for large inline datasets.</span>
                  <span class="k">this</span><span class="p">.</span><span class="nx">_hash</span> <span class="o">=</span> <span class="nx">hash</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_hash</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isUrlData</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">hash</span><span class="p">([</span><span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">.</span><span class="nx">format</span><span class="p">]);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">SourceNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="p">},</span> <span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">,</span> <span class="p">{</span> <span class="nx">transform</span><span class="o">:</span> <span class="p">[]</span> <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">SourceNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">TimeUnitNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">TimeUnitNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">TimeUnitNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">formula</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">formula</span> <span class="o">=</span> <span class="nx">formula</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">TimeUnitNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">formula</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">formula</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">reduceFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">timeUnitComponent</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">);</span>
                  <span class="nx">timeUnitComponent</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">as</span><span class="o">:</span> <span class="nx">f</span><span class="p">,</span>
                      <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span>
                  <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">timeUnitComponent</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">formula</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">TimeUnitNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">formula</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">makeFromTransform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">TimeUnitNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">(</span><span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span>
              <span class="nx">_a</span><span class="p">[</span><span class="nx">t</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span>
                  <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">field</span>
              <span class="p">},</span>
              <span class="nx">_a</span><span class="p">));</span>
          <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">formula</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">formula</span><span class="p">,</span> <span class="nx">other</span><span class="p">.</span><span class="nx">formula</span><span class="p">);</span>
          <span class="nx">other</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">vals</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">formula</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">.</span><span class="nx">as</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dependentFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">vals</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">formula</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">vals</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">formula</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;formula&#39;</span><span class="p">,</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="nx">c</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span>
                  <span class="nx">expr</span><span class="o">:</span> <span class="nx">fieldExpr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span>
              <span class="p">};</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">TimeUnitNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="cm">/**</span>
<span class="cm">   * Start optimization path at the leaves. Useful for merging up or removing things.</span>
<span class="cm">   *</span>
<span class="cm">   * If the callback returns true, the recursion continues.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">iterateFromLeaves</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">optimizeNextFromLeaves</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">SourceNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">optimizeNextFromLeaves</span><span class="p">(</span><span class="nx">next</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">optimizeNextFromLeaves</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Move parse nodes up to forks.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">moveParseUp</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
      <span class="c1">// move parse up by merging or swapping</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">ParseNode</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span> <span class="k">instanceof</span> <span class="nx">SourceNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// don&#39;t move parse further up but continue with parent.</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span> <span class="k">instanceof</span> <span class="nx">ParseNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">parent</span><span class="p">.</span><span class="nx">merge</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// don&#39;t swap with nodes that produce something that the parse node depends on (e.g. lookup)</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">hasIntersection</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">producedFields</span><span class="p">(),</span> <span class="nx">node</span><span class="p">.</span><span class="nx">dependentFields</span><span class="p">()))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="nx">node</span><span class="p">.</span><span class="nx">swapWithParent</span><span class="p">();</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Repeatedly remove leaf nodes that are not output or facet nodes.</span>
<span class="cm">   * The reason is that we don&#39;t need subtrees that don&#39;t have any output nodes.</span>
<span class="cm">   * Facet nodes are needed for the row or column domains.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">removeUnusedSubtrees</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span> <span class="o">||</span> <span class="nx">node</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FacetNode</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// no need to continue with parent because it is output node or will have children (there was a fork)</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">node</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Removes duplicate time unit nodes (as determined by the name of the</span>
<span class="cm">   * output field) that may be generated due to selections projected over</span>
<span class="cm">   * time units.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">removeDuplicateTimeUnits</span><span class="p">(</span><span class="nx">leaf</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">return</span> <span class="nx">iterateFromLeaves</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">TimeUnitNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">pfields</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">producedFields</span><span class="p">();</span>
              <span class="kd">var</span> <span class="nx">dupe</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">pfields</span><span class="p">).</span><span class="nx">every</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="nx">fields</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span> <span class="p">});</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">dupe</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">fields</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fields</span><span class="p">,</span> <span class="nx">pfields</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">})(</span><span class="nx">leaf</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">getStackByFields</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">stackBy</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fields</span><span class="p">,</span> <span class="nx">by</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">by</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">_field</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">_field</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">fields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">_field</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">fields</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isValidAsArray</span><span class="p">(</span><span class="nx">as</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">as</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">as</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="p">})</span> <span class="o">&amp;&amp;</span> <span class="nx">as</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">StackNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">StackNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">StackNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">stack</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">_stack</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">StackNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">makeFromTransform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">stackTransform</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">stackTransform</span><span class="p">.</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">groupby</span> <span class="o">=</span> <span class="nx">stackTransform</span><span class="p">.</span><span class="nx">groupby</span><span class="p">,</span> <span class="nx">as</span> <span class="o">=</span> <span class="nx">stackTransform</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">stackTransform</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">_a</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span> <span class="o">?</span> <span class="s1">&#39;zero&#39;</span> <span class="o">:</span> <span class="nx">_a</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">sortFields</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">sortOrder</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">stackTransform</span><span class="p">.</span><span class="nx">sort</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">stackTransform</span><span class="p">.</span><span class="nx">sort</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">sortField</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                  <span class="nx">sortFields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sortField</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
                  <span class="nx">sortOrder</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sortField</span><span class="p">.</span><span class="nx">order</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="s1">&#39;ascending&#39;</span> <span class="o">:</span> <span class="nx">sortField</span><span class="p">.</span><span class="nx">order</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">sortFields</span><span class="p">,</span>
              <span class="nx">order</span><span class="o">:</span> <span class="nx">sortOrder</span><span class="p">,</span>
          <span class="p">};</span>
          <span class="kd">var</span> <span class="nx">normalizedAs</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isValidAsArray</span><span class="p">(</span><span class="nx">as</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">normalizedAs</span> <span class="o">=</span> <span class="nx">as</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">as</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">normalizedAs</span> <span class="o">=</span> <span class="p">[</span><span class="nx">as</span><span class="p">,</span> <span class="nx">as</span> <span class="o">+</span> <span class="s1">&#39;_end&#39;</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">normalizedAs</span> <span class="o">=</span> <span class="p">[</span><span class="nx">stackTransform</span><span class="p">.</span><span class="nx">stack</span> <span class="o">+</span> <span class="s1">&#39;_start&#39;</span><span class="p">,</span> <span class="nx">stackTransform</span><span class="p">.</span><span class="nx">stack</span> <span class="o">+</span> <span class="s1">&#39;_end&#39;</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">StackNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">stackField</span><span class="o">:</span> <span class="nx">stack</span><span class="p">,</span>
              <span class="nx">groupby</span><span class="o">:</span> <span class="nx">groupby</span><span class="p">,</span>
              <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span><span class="p">,</span>
              <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span><span class="p">,</span>
              <span class="nx">facetby</span><span class="o">:</span> <span class="p">[],</span>
              <span class="nx">as</span><span class="o">:</span> <span class="nx">normalizedAs</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">stackProperties</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">stackProperties</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">dimensionFieldDef</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">stackProperties</span><span class="p">.</span><span class="nx">groupbyChannel</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">dimensionFieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">stackProperties</span><span class="p">.</span><span class="nx">groupbyChannel</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">stackby</span> <span class="o">=</span> <span class="nx">getStackByFields</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">orderDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">order</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">sort</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">orderDef</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">orderDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">sort</span> <span class="o">=</span> <span class="nx">sortParams</span><span class="p">(</span><span class="nx">orderDef</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// default = descending by stackFields</span>
              <span class="c1">// FIXME is the default here correct for binned fields?</span>
              <span class="nx">sort</span> <span class="o">=</span> <span class="nx">stackby</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">s</span><span class="p">.</span><span class="nx">field</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">);</span>
                  <span class="nx">s</span><span class="p">.</span><span class="nx">order</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;descending&#39;</span><span class="p">);</span>
                  <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
              <span class="p">},</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">[],</span> <span class="nx">order</span><span class="o">:</span> <span class="p">[]</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="c1">// Refactored to add &quot;as&quot; in the make phase so that we can get producedFields</span>
          <span class="c1">// from the as property</span>
          <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">stackProperties</span><span class="p">.</span><span class="nx">fieldChannel</span><span class="p">);</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">StackNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">dimensionFieldDef</span><span class="o">:</span> <span class="nx">dimensionFieldDef</span><span class="p">,</span>
              <span class="nx">stackField</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span>
              <span class="nx">facetby</span><span class="o">:</span> <span class="p">[],</span>
              <span class="nx">stackby</span><span class="o">:</span> <span class="nx">stackby</span><span class="p">,</span>
              <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span><span class="p">,</span>
              <span class="nx">offset</span><span class="o">:</span> <span class="nx">stackProperties</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span>
              <span class="nx">impute</span><span class="o">:</span> <span class="nx">stackProperties</span><span class="p">.</span><span class="nx">impute</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="p">[</span><span class="nx">field$$1</span> <span class="o">+</span> <span class="s1">&#39;_start&#39;</span><span class="p">,</span> <span class="nx">field$$1</span> <span class="o">+</span> <span class="s1">&#39;_end&#39;</span><span class="p">]</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addDimensions</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fields</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">.</span><span class="nx">facetby</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">.</span><span class="nx">facetby</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">fields</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dependentFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">out</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">.</span><span class="nx">stackField</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">getGroupbyFields</span><span class="p">().</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">.</span><span class="nx">facetby</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">.</span><span class="nx">sort</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
          <span class="nx">isArray</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="o">?</span> <span class="nx">field$$1</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">})</span> <span class="o">:</span> <span class="nx">out</span><span class="p">[</span><span class="nx">field$$1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">.</span><span class="nx">as</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">result</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
      <span class="p">};</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getGroupbyFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">,</span> <span class="nx">dimensionFieldDef</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="nx">impute</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">impute</span><span class="p">,</span> <span class="nx">groupby</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">groupby</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">impute</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// For binned group by field with impute, we calculate bin_mid</span>
                      <span class="c1">// as we cannot impute two fields simultaneously</span>
                      <span class="k">return</span> <span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;mid&#39;</span> <span class="p">})];</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="p">[</span>
                      <span class="c1">// For binned group by field without impute, we need both bin (start) and bin_end</span>
                      <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="p">{}),</span>
                      <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">})</span>
                  <span class="p">];</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">)];</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">groupby</span> <span class="o">||</span> <span class="p">[];</span>
      <span class="p">};</span>
      <span class="nx">StackNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">transform</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_stack</span><span class="p">,</span> <span class="nx">facetby</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">facetby</span><span class="p">,</span> <span class="nx">dimensionFieldDef</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">stackField</span><span class="p">,</span> <span class="nx">stackby</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">stackby</span><span class="p">,</span> <span class="nx">sort</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">sort</span><span class="p">,</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">impute</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">impute</span><span class="p">,</span> <span class="nx">as</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">as</span><span class="p">;</span>
          <span class="c1">// Impute</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">impute</span> <span class="o">&amp;&amp;</span> <span class="nx">dimensionFieldDef</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">dimensionField</span> <span class="o">=</span> <span class="nx">dimensionFieldDef</span> <span class="o">?</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;mid&#39;</span> <span class="p">})</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// As we can only impute one field at a time, we need to calculate</span>
                  <span class="c1">// mid point for a binned field</span>
                  <span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;formula&#39;</span><span class="p">,</span>
                      <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span>
                          <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">})</span> <span class="o">+</span>
                          <span class="s1">&#39;+&#39;</span> <span class="o">+</span>
                          <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionFieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span><span class="p">,</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">})</span> <span class="o">+</span>
                          <span class="s1">&#39;)/2&#39;</span><span class="p">,</span>
                      <span class="nx">as</span><span class="o">:</span> <span class="nx">dimensionField</span>
                  <span class="p">});</span>
              <span class="p">}</span>
              <span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;impute&#39;</span><span class="p">,</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span>
                  <span class="nx">groupby</span><span class="o">:</span> <span class="nx">stackby</span><span class="p">,</span>
                  <span class="nx">key</span><span class="o">:</span> <span class="nx">dimensionField</span><span class="p">,</span>
                  <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span>
                  <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="c1">// Stack</span>
          <span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;stack&#39;</span><span class="p">,</span>
              <span class="nx">groupby</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getGroupbyFields</span><span class="p">().</span><span class="nx">concat</span><span class="p">(</span><span class="nx">facetby</span><span class="p">),</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span>
              <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="nx">as</span><span class="p">,</span>
              <span class="nx">offset</span><span class="o">:</span> <span class="nx">offset</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">transform</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">StackNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">FACET_SCALE_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;scale_&#39;</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Clones the subtree and ignores output nodes except for the leafs, which are renamed.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">cloneSubtree</span><span class="p">(</span><span class="nx">facet</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">clone</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FacetNode</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">copy_1</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">copy_1</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">newName</span> <span class="o">=</span> <span class="nx">FACET_SCALE_PREFIX</span> <span class="o">+</span> <span class="nx">copy_1</span><span class="p">.</span><span class="nx">getSource</span><span class="p">();</span>
                  <span class="nx">copy_1</span><span class="p">.</span><span class="nx">setSource</span><span class="p">(</span><span class="nx">newName</span><span class="p">);</span>
                  <span class="nx">facet</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodes</span><span class="p">[</span><span class="nx">newName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">copy_1</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">copy_1</span> <span class="k">instanceof</span> <span class="nx">AggregateNode</span> <span class="o">||</span> <span class="nx">copy_1</span> <span class="k">instanceof</span> <span class="nx">StackNode</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">copy_1</span><span class="p">.</span><span class="nx">addDimensions</span><span class="p">(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">fields</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="nx">flatten</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">clone</span><span class="p">)).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">copy_1</span><span class="p">;</span> <span class="p">});</span>
              <span class="k">return</span> <span class="p">[</span><span class="nx">copy_1</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">clone</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.</span>
<span class="cm">   * After moving down the facet node, make a copy of the subtree and make it a child of the main output.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">moveFacetDown</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FacetNode</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// move down until we hit a fork or output node</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">child</span> <span class="k">instanceof</span> <span class="nx">AggregateNode</span> <span class="o">||</span> <span class="nx">child</span> <span class="k">instanceof</span> <span class="nx">StackNode</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">child</span><span class="p">.</span><span class="nx">addDimensions</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">fields</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">swapWithParent</span><span class="p">();</span>
              <span class="nx">moveFacetDown</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// move main to facet</span>
              <span class="nx">moveMainDownToFacet</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">main</span><span class="p">);</span>
              <span class="c1">// replicate the subtree and place it before the facet&#39;s main node</span>
              <span class="kd">var</span> <span class="nx">copy</span> <span class="o">=</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">cloneSubtree</span><span class="p">(</span><span class="nx">node</span><span class="p">)));</span>
              <span class="nx">copy</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">main</span><span class="p">;</span> <span class="p">});</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">moveFacetDown</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">moveMainDownToFacet</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">MAIN</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">child</span> <span class="k">instanceof</span> <span class="nx">FacetNode</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">child</span><span class="p">.</span><span class="nx">swapWithParent</span><span class="p">();</span>
                  <span class="nx">moveMainDownToFacet</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Remove nodes that are not required starting from a root.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">removeUnnecessaryNodes</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// remove empty null filter nodes</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FilterInvalidNode</span> <span class="o">&amp;&amp;</span> <span class="nx">every</span><span class="p">(</span><span class="nx">vals</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">filter</span><span class="p">),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">f</span> <span class="o">===</span> <span class="kc">null</span><span class="p">;</span> <span class="p">}))</span> <span class="p">{</span>
          <span class="nx">node</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="c1">// remove output nodes that are not required</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">isRequired</span><span class="p">())</span> <span class="p">{</span>
          <span class="nx">node</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">removeUnnecessaryNodes</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return all leaf nodes.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getLeaves</span><span class="p">(</span><span class="nx">roots</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">leaves</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">function</span> <span class="nx">append</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">leaves</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">append</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">roots</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">append</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">leaves</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Optimizes the dataflow of the passed in data component.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">optimizeDataflow</span><span class="p">(</span><span class="nx">dataComponent</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">roots</span> <span class="o">=</span> <span class="nx">vals</span><span class="p">(</span><span class="nx">dataComponent</span><span class="p">.</span><span class="nx">sources</span><span class="p">);</span>
      <span class="nx">roots</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">removeUnnecessaryNodes</span><span class="p">);</span>
      <span class="c1">// remove source nodes that don&#39;t have any children because they also don&#39;t have output nodes</span>
      <span class="nx">roots</span> <span class="o">=</span> <span class="nx">roots</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
      <span class="nx">getLeaves</span><span class="p">(</span><span class="nx">roots</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">iterateFromLeaves</span><span class="p">(</span><span class="nx">removeUnusedSubtrees</span><span class="p">));</span>
      <span class="nx">roots</span> <span class="o">=</span> <span class="nx">roots</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
      <span class="nx">getLeaves</span><span class="p">(</span><span class="nx">roots</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">iterateFromLeaves</span><span class="p">(</span><span class="nx">moveParseUp</span><span class="p">));</span>
      <span class="nx">getLeaves</span><span class="p">(</span><span class="nx">roots</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">removeDuplicateTimeUnits</span><span class="p">);</span>
      <span class="nx">roots</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">moveFacetDown</span><span class="p">);</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">dataComponent</span><span class="p">.</span><span class="nx">sources</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">dataComponent</span><span class="p">.</span><span class="nx">sources</span><span class="p">[</span><span class="nx">s</span><span class="p">].</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">delete</span> <span class="nx">dataComponent</span><span class="p">.</span><span class="nx">sources</span><span class="p">[</span><span class="nx">s</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">parseUnitScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">parseNonUnitScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseUnitScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scales</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">specifiedScales</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">localScaleComponents</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">;</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">localScaleComponents</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">specifiedDomain</span> <span class="o">=</span> <span class="nx">specifiedScale</span> <span class="o">?</span> <span class="nx">specifiedScale</span><span class="p">.</span><span class="nx">domain</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">domains</span> <span class="o">=</span> <span class="nx">parseDomainForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">localScaleCmpt</span> <span class="o">=</span> <span class="nx">localScaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="nx">localScaleCmpt</span><span class="p">.</span><span class="nx">domains</span> <span class="o">=</span> <span class="nx">domains</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isSelectionDomain</span><span class="p">(</span><span class="nx">specifiedDomain</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// As scale parsing occurs before selection parsing, we use a temporary</span>
              <span class="c1">// signal here and append the scale.domain definition. This is replaced</span>
              <span class="c1">// with the correct domainRaw signal during scale assembly.</span>
              <span class="c1">// For more information, see isRawSelectionDomain in selection.ts.</span>
              <span class="c1">// FIXME: replace this with a special property in the scaleComponent</span>
              <span class="nx">localScaleCmpt</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">,</span> <span class="p">{</span>
                  <span class="nx">signal</span><span class="o">:</span> <span class="nx">SELECTION_DOMAIN</span> <span class="o">+</span> <span class="nx">hash</span><span class="p">(</span><span class="nx">specifiedDomain</span><span class="p">)</span>
              <span class="p">},</span> <span class="kc">true</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">isFaceted</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not</span>
              <span class="kd">var</span> <span class="nx">facetParent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>
              <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">facetParent</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">facetParent</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">facetParent</span> <span class="o">=</span> <span class="nx">facetParent</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="kd">var</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">facetParent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">domains_1</span> <span class="o">=</span> <span class="nx">domains</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">domains_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">domains_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                      <span class="c1">// Replace the scale domain with data output from a cloned subtree after the facet.</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
                          <span class="c1">// use data from cloned subtree (which is the same as data but with a prefix added once)</span>
                          <span class="nx">domain</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">FACET_SCALE_PREFIX</span> <span class="o">+</span> <span class="nx">domain</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">FACET_SCALE_PREFIX</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseNonUnitScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">parseScaleDomain</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">localScaleComponents</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">;</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">localScaleComponents</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">domains</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">domainRaw</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">childComponent</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">childComponent</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">domains</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">domains</span> <span class="o">=</span> <span class="nx">childComponent</span><span class="p">.</span><span class="nx">domains</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">domains</span> <span class="o">=</span> <span class="nx">domains</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">childComponent</span><span class="p">.</span><span class="nx">domains</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="kd">var</span> <span class="nx">dr</span> <span class="o">=</span> <span class="nx">childComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">domainRaw</span> <span class="o">&amp;&amp;</span> <span class="nx">dr</span> <span class="o">&amp;&amp;</span> <span class="nx">domainRaw</span><span class="p">.</span><span class="nx">signal</span> <span class="o">!==</span> <span class="nx">dr</span><span class="p">.</span><span class="nx">signal</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;The same selection must be used to override scale domains in a layered view.&#39;</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="nx">domainRaw</span> <span class="o">=</span> <span class="nx">dr</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">localScaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">domains</span> <span class="o">=</span> <span class="nx">domains</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">domainRaw</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">localScaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">,</span> <span class="nx">domainRaw</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Remove unaggregated domain if it is not applicable</span>
<span class="cm">   * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">normalizeUnaggregatedDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span> <span class="o">===</span> <span class="s1">&#39;unaggregated&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">canUseUnaggregatedDomain</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">),</span> <span class="nx">valid</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">valid</span><span class="p">,</span> <span class="nx">reason</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">reason</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">valid</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">useUnaggregatedDomain</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Apply config if domain is not specified.</span>
          <span class="kd">var</span> <span class="nx">valid</span> <span class="o">=</span> <span class="nx">canUseUnaggregatedDomain</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">).</span><span class="nx">valid</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">valid</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;unaggregated&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">domain</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseDomainForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">normalizeUnaggregatedDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">scaleDomain</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span> <span class="o">!==</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleDomain</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">specifiedScales</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">model</span><span class="p">.</span><span class="nx">specifiedScales</span><span class="p">[</span><span class="nx">channel</span><span class="p">],</span> <span class="p">{</span> <span class="nx">domain</span><span class="o">:</span> <span class="nx">domain</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="c1">// If channel is either X or Y then union them with X2 &amp; Y2 if they exist</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;y2&#39;</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseSingleChannelDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span> <span class="o">&amp;&amp;</span> <span class="nx">domain</span> <span class="o">!==</span> <span class="s1">&#39;unaggregated&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isSelectionDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// explicit value</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isDateTime</span><span class="p">(</span><span class="nx">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">domain</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">dt</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;{data: &quot;</span> <span class="o">+</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">dt</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="p">};</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">[</span><span class="nx">domain</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">stack</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">fieldChannel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">offset</span> <span class="o">===</span> <span class="s1">&#39;normalize&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]];</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">);</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">suffix</span><span class="o">:</span> <span class="s1">&#39;start&#39;</span> <span class="p">})</span>
              <span class="p">},</span> <span class="p">{</span>
                  <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">suffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">})</span>
              <span class="p">}];</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="nx">domainSort</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span> <span class="o">===</span> <span class="s1">&#39;unaggregated&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">({</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="s1">&#39;min&#39;</span> <span class="p">})</span>
              <span class="p">},</span> <span class="p">{</span>
                  <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">({</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span><span class="p">,</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="s1">&#39;max&#39;</span> <span class="p">})</span>
              <span class="p">}];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bin</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isBinScale</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">binToString</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;_bins&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="p">[{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;sequence(&quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.start, &quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.stop + &quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.step, &quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.step)&quot;</span> <span class="p">}];</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// ordinal bin scale takes domain from bin_range, ordered by bin start</span>
              <span class="c1">// This is useful for both axis-based scale (x/y) and legend-based scale (other channels).</span>
              <span class="k">return</span> <span class="p">[{</span>
                      <span class="c1">// If sort by aggregation of a specified sort field, we need to use RAW table,</span>
                      <span class="c1">// so we can aggregate values for the scale independently from the main aggregation.</span>
                      <span class="nx">data</span><span class="o">:</span> <span class="nx">isBoolean$1</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">)</span> <span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">RAW</span><span class="p">),</span>
                      <span class="c1">// Use range if we added it and the scale does not support computing a range as a signal.</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">binRequiresRange</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span>
                      <span class="c1">// we have to use a sort object if sort = true to make the sort correct by bin start</span>
                      <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span> <span class="o">===</span> <span class="kc">true</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isSortField</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span>
                          <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{}),</span>
                          <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;min&#39;</span> <span class="c1">// min or max doesn&#39;t matter since we sort by the start of the bin range</span>
                      <span class="p">}</span> <span class="o">:</span> <span class="nx">sort</span>
                  <span class="p">}];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span> <span class="c1">// continuous scales</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">||</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">isBinParams</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">.</span><span class="nx">extent</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">.</span><span class="nx">extent</span><span class="p">];</span>
                  <span class="p">}</span>
                  <span class="c1">// X/Y position have to include start and end for non-ordinal scale</span>
                  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">);</span>
                  <span class="k">return</span> <span class="p">[{</span>
                          <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                          <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{})</span>
                      <span class="p">},</span> <span class="p">{</span>
                          <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span><span class="p">,</span>
                          <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">})</span>
                      <span class="p">}];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="c1">// TODO: use bin_mid</span>
                  <span class="k">return</span> <span class="p">[{</span>
                          <span class="nx">data</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">),</span>
                          <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{})</span>
                      <span class="p">}];</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="c1">// If sort by aggregation of a specified sort field, we need to use RAW table,</span>
                  <span class="c1">// so we can aggregate values for the scale independently from the main aggregation.</span>
                  <span class="nx">data</span><span class="o">:</span> <span class="nx">isBoolean$1</span><span class="p">(</span><span class="nx">sort</span><span class="p">)</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">)</span> <span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">RAW</span><span class="p">),</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span>
                  <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span>
              <span class="p">}];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="nx">data</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">),</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span>
              <span class="p">}];</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">domainSort</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">;</span>
      <span class="c1">// if the sort is specified with array, use the derived sort index field</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isSortArray</span><span class="p">(</span><span class="nx">sort</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">sortArrayIndexField</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">),</span>
              <span class="nx">order</span><span class="o">:</span> <span class="s1">&#39;ascending&#39;</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="c1">// Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isSortField</span><span class="p">(</span><span class="nx">sort</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// flatten nested fields</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">sort</span><span class="p">,</span> <span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">field</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">replacePathInField</span><span class="p">(</span><span class="nx">sort</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">sort</span> <span class="o">===</span> <span class="s1">&#39;descending&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">op</span><span class="o">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span>
              <span class="nx">order</span><span class="o">:</span> <span class="s1">&#39;descending&#39;</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;ascending&#39;</span><span class="p">,</span> <span class="kc">undefined</span> <span class="cm">/* default =ascending*/</span><span class="p">],</span> <span class="nx">sort</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// sort == null</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Determine if a scale can use unaggregated domain.</span>
<span class="cm">   * @return {Boolean} Returns true if all of the following conditons applies:</span>
<span class="cm">   * 1. `scale.domain` is `unaggregated`</span>
<span class="cm">   * 2. Aggregation function is not `count` or `sum`</span>
<span class="cm">   * 3. The scale is quantitative or time scale.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">canUseUnaggregatedDomain</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">valid</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
              <span class="nx">reason</span><span class="o">:</span> <span class="nx">message</span><span class="p">.</span><span class="nx">unaggregateDomainHasNoEffectForRawField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">SHARED_DOMAIN_OP_INDEX</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">])</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">valid</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
              <span class="nx">reason</span><span class="o">:</span> <span class="nx">message</span><span class="p">.</span><span class="nx">unaggregateDomainWithNonSharedDomainOp</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;log&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">valid</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                  <span class="nx">reason</span><span class="o">:</span> <span class="nx">message</span><span class="p">.</span><span class="nx">unaggregatedDomainWithLogScale</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span>
              <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">valid</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Converts an array of domains to a single Vega scale domain.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">mergeDomains</span><span class="p">(</span><span class="nx">domains</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">uniqueDomains</span> <span class="o">=</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">domains</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// ignore sort property when computing the unique domains</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">_s</span> <span class="o">=</span> <span class="nx">domain</span><span class="p">.</span><span class="nx">sort</span><span class="p">,</span> <span class="nx">domainWithoutSort</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">domain</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;sort&quot;</span><span class="p">]);</span>
              <span class="k">return</span> <span class="nx">domainWithoutSort</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">domain</span><span class="p">;</span>
      <span class="p">}),</span> <span class="nx">hash</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">sorts</span> <span class="o">=</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">domains</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">sort</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isBoolean$1</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">op</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// let&#39;s make sure that if op is count, we don&#39;t use a field</span>
                      <span class="k">delete</span> <span class="nx">s</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">order</span> <span class="o">===</span> <span class="s1">&#39;ascending&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// drop order: ascending as it is the default</span>
                      <span class="k">delete</span> <span class="nx">s</span><span class="p">.</span><span class="nx">order</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}).</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="p">}),</span> <span class="nx">hash</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">uniqueDomains</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">domains</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">sorts</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">sort_1</span> <span class="o">=</span> <span class="nx">sorts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">sorts</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">MORE_THAN_ONE_SORT</span><span class="p">);</span>
                  <span class="nx">sort_1</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">domain</span><span class="p">,</span> <span class="p">{</span> <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort_1</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">domain</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// only keep simple sort properties that work with unioned domains</span>
      <span class="kd">var</span> <span class="nx">simpleSorts</span> <span class="o">=</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">sorts</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">op</span> <span class="o">===</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">domainSortDropped</span><span class="p">(</span><span class="nx">s</span><span class="p">));</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}),</span> <span class="nx">hash</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">simpleSorts</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">sort</span> <span class="o">=</span> <span class="nx">simpleSorts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">simpleSorts</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">MORE_THAN_ONE_SORT</span><span class="p">);</span>
          <span class="nx">sort</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">allData</span> <span class="o">=</span> <span class="nx">unique</span><span class="p">(</span><span class="nx">domains</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">allData</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">allData</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// create a union domain of different fields with a single data source</span>
          <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">allData</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">fields</span><span class="o">:</span> <span class="nx">uniqueDomains</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span> <span class="p">})</span> <span class="p">},</span> <span class="p">(</span><span class="nx">sort</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
          <span class="k">return</span> <span class="nx">domain</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">fields</span><span class="o">:</span> <span class="nx">uniqueDomains</span> <span class="p">},</span> <span class="p">(</span><span class="nx">sort</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return a field if a scale single field.</span>
<span class="cm">   * Return `undefined` otherwise.</span>
<span class="cm">   *</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getFieldFromDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">domain</span><span class="p">.</span><span class="nx">field</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">domain</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefUnionedDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="k">void</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">domain</span><span class="p">.</span><span class="nx">fields</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">nonUnionDomain</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">nonUnionDomain</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">nonUnionDomain</span><span class="p">.</span><span class="nx">field</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">nonUnionDomain</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">field$$1</span> <span class="o">!==</span> <span class="nx">nonUnionDomain</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Detected faceted independent scales that union domain of multiple fields from different data sources.  We will use the first field.  The result view size may be incorrect.&#39;</span><span class="p">);</span>
                      <span class="k">return</span> <span class="nx">field$$1</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Detected faceted independent scales that union domain of identical fields from different source detected.  We will assume that this is the same field from a different fork of the same data source.  However, if this is not case, the result view size maybe incorrect.&#39;</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">field$$1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldRefUnionDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Detected faceted independent scales that union domain of multiple fields from the same data source.  We will use the first field.  The result view size may be incorrect.&#39;</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">domain</span><span class="p">.</span><span class="nx">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="k">return</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="o">?</span> <span class="nx">field$$1</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">domains</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">domains</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Correct references to data as the original domain&#39;s data was determined</span>
          <span class="c1">// in parseScale, which happens before parseData. Thus the original data</span>
          <span class="c1">// reference can be incorrect.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isDataRefDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">domain</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">lookupDataSource</span><span class="p">(</span><span class="nx">domain</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">domain</span><span class="p">;</span>
      <span class="p">});</span>
      <span class="c1">// domains is an array that has to be merged into a single vega domain</span>
      <span class="k">return</span> <span class="nx">mergeDomains</span><span class="p">(</span><span class="nx">domains</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">assembleScales</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isConcatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isRepeatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// For concat / layer / repeat, include scales of children too</span>
          <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">scales</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">scales</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">assembleScales</span><span class="p">(</span><span class="nx">child</span><span class="p">));</span>
          <span class="p">},</span> <span class="nx">assembleScalesForModel</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// For facet, child scales would not be included in the parent&#39;s scope.</span>
          <span class="c1">// For unit, there is no child.</span>
          <span class="k">return</span> <span class="nx">assembleScalesForModel</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleScalesForModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">scales</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Skipped merged scales</span>
              <span class="k">return</span> <span class="nx">scales</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">combine</span><span class="p">();</span>
          <span class="c1">// need to separate const and non const object destruction</span>
          <span class="kd">var</span> <span class="nx">domainRaw</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">domainRaw</span><span class="p">,</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">range</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">_d</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">domainRaw</span><span class="p">,</span> <span class="nx">_r</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">range</span><span class="p">,</span> <span class="nx">otherScaleProps</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">scale</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;domainRaw&quot;</span><span class="p">,</span> <span class="s2">&quot;range&quot;</span><span class="p">]);</span>
          <span class="nx">range</span> <span class="o">=</span> <span class="nx">assembleScaleRange</span><span class="p">(</span><span class="nx">range</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="c1">// As scale parsing occurs before selection parsing, a temporary signal</span>
          <span class="c1">// is used for domainRaw. Here, we detect if this temporary signal</span>
          <span class="c1">// is set, and replace it with the correct domainRaw signal.</span>
          <span class="c1">// For more information, see isRawSelectionDomain in selection.ts.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">domainRaw</span> <span class="o">&amp;&amp;</span> <span class="nx">isRawSelectionDomain</span><span class="p">(</span><span class="nx">domainRaw</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">domainRaw</span> <span class="o">=</span> <span class="nx">selectionScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">domainRaw</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="nx">scales</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span>
              <span class="nx">type</span><span class="o">:</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">domain</span><span class="o">:</span> <span class="nx">assembleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">},</span> <span class="p">(</span><span class="nx">domainRaw</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">domainRaw</span><span class="o">:</span> <span class="nx">domainRaw</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">range</span><span class="o">:</span> <span class="nx">range</span> <span class="p">},</span> <span class="nx">otherScaleProps</span><span class="p">));</span>
          <span class="k">return</span> <span class="nx">scales</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleScaleRange</span><span class="p">(</span><span class="nx">scaleRange</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// add signals to x/y range</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">||</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">scaleRange</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// For x/y range step, use a signal created in layout assemble instead of a constant range step.</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">step</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">scaleName</span> <span class="o">+</span> <span class="s1">&#39;_step&#39;</span> <span class="p">}</span>
              <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">scaleRange</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleRange</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">r0</span> <span class="o">=</span> <span class="nx">scaleRange</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">r1</span> <span class="o">=</span> <span class="nx">scaleRange</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">r0</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgSignalRef</span><span class="p">(</span><span class="nx">r1</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// Replace width signal just in case it is renamed.</span>
                  <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeName</span><span class="p">(</span><span class="nx">r1</span><span class="p">.</span><span class="nx">signal</span><span class="p">)</span> <span class="p">}];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isVgSignalRef</span><span class="p">(</span><span class="nx">r0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">r1</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Replace height signal just in case it is renamed.</span>
                  <span class="k">return</span> <span class="p">[{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeName</span><span class="p">(</span><span class="nx">r0</span><span class="p">.</span><span class="nx">signal</span><span class="p">)</span> <span class="p">},</span> <span class="mi">0</span><span class="p">];</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">scaleRange</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">ScaleComponent</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">ScaleComponent</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">ScaleComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">typeWithExplicit</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{},</span> <span class="c1">// no initial explicit property</span>
          <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="p">}</span> <span class="c1">// name as initial implicit property</span>
          <span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">merged</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">domains</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="nx">typeWithExplicit</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">ScaleComponent</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Split</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">RANGE_PROPERTIES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="s1">&#39;rangeStep&#39;</span><span class="p">,</span> <span class="s1">&#39;scheme&#39;</span><span class="p">];</span>
  <span class="kd">function</span> <span class="nx">parseScaleRange</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">parseUnitScaleRange</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">parseNonUnitScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseUnitScaleRange</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">localScaleComponents</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">;</span>
      <span class="c1">// use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!</span>
      <span class="nx">SCALE_CHANNELS</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">localScaleCmpt</span> <span class="o">=</span> <span class="nx">localScaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">localScaleCmpt</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">mergedScaleCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">specifiedScales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="c1">// Read if there is a specified width/height</span>
          <span class="kd">var</span> <span class="nx">sizeType</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span> <span class="o">?</span> <span class="s1">&#39;height&#39;</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">sizeSpecified</span> <span class="o">=</span> <span class="nx">sizeType</span> <span class="o">?</span> <span class="o">!!</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">mergedScaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
          <span class="c1">// if autosize is fit, size cannot be data driven</span>
          <span class="kd">var</span> <span class="nx">rangeStep</span> <span class="o">=</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="s1">&#39;band&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">specifiedScale</span><span class="p">.</span><span class="nx">rangeStep</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">sizeType</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">sizeSpecified</span> <span class="o">&amp;&amp;</span> <span class="nx">rangeStep</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CANNOT_FIX_RANGE_STEP_WITH_FIT</span><span class="p">);</span>
              <span class="nx">sizeSpecified</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">xyRangeSteps</span> <span class="o">=</span> <span class="nx">getXYRangeStep</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">rangeWithExplicit</span> <span class="o">=</span> <span class="nx">parseRangeForChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">specifiedScale</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">localScaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">sizeSpecified</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">),</span> <span class="nx">xyRangeSteps</span><span class="p">);</span>
          <span class="nx">localScaleCmpt</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="nx">rangeWithExplicit</span><span class="p">);</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getXYRangeStep</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">xyRangeSteps</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">xScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">xRange</span> <span class="o">=</span> <span class="nx">xScale</span> <span class="o">&amp;&amp;</span> <span class="nx">xScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">xRange</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">xRange</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">xRange</span><span class="p">.</span><span class="nx">step</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">xyRangeSteps</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">xRange</span><span class="p">.</span><span class="nx">step</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">yScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">yRange</span> <span class="o">=</span> <span class="nx">yScale</span> <span class="o">&amp;&amp;</span> <span class="nx">yScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">yRange</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">yRange</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">yRange</span><span class="p">.</span><span class="nx">step</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">xyRangeSteps</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">yRange</span><span class="p">.</span><span class="nx">step</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">xyRangeSteps</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Return mixins that includes one of the range properties (range, rangeStep, scheme).</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">parseRangeForChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">specifiedScale</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">zero$$1</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">sizeSpecified</span><span class="p">,</span> <span class="nx">sizeSignal</span><span class="p">,</span> <span class="nx">xyRangeSteps</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">noRangeStep</span> <span class="o">=</span> <span class="nx">sizeSpecified</span> <span class="o">||</span> <span class="nx">specifiedScale</span><span class="p">.</span><span class="nx">rangeStep</span> <span class="o">===</span> <span class="kc">null</span><span class="p">;</span>
      <span class="c1">// Check if any of the range properties is specified.</span>
      <span class="c1">// If so, check if it is compatible and make sure that we only output one of the properties</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">RANGE_PROPERTIES_1</span> <span class="o">=</span> <span class="nx">RANGE_PROPERTIES</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">RANGE_PROPERTIES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">property</span> <span class="o">=</span> <span class="nx">RANGE_PROPERTIES_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedScale</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">supportedByScaleType</span> <span class="o">=</span> <span class="nx">scaleTypeSupportProperty</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">channelIncompatability</span> <span class="o">=</span> <span class="nx">channelScalePropertyIncompatability</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">supportedByScaleType</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">scalePropertyNotWorkWithScaleType</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channelIncompatability</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// channel</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">channelIncompatability</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">switch</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">case</span> <span class="s1">&#39;range&#39;</span><span class="o">:</span>
                          <span class="k">return</span> <span class="nx">makeExplicit</span><span class="p">(</span><span class="nx">specifiedScale</span><span class="p">[</span><span class="nx">property</span><span class="p">]);</span>
                      <span class="k">case</span> <span class="s1">&#39;scheme&#39;</span><span class="o">:</span>
                          <span class="k">return</span> <span class="nx">makeExplicit</span><span class="p">(</span><span class="nx">parseScheme</span><span class="p">(</span><span class="nx">specifiedScale</span><span class="p">[</span><span class="nx">property</span><span class="p">]));</span>
                      <span class="k">case</span> <span class="s1">&#39;rangeStep&#39;</span><span class="o">:</span>
                          <span class="kd">var</span> <span class="nx">rangeStep</span> <span class="o">=</span> <span class="nx">specifiedScale</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
                          <span class="k">if</span> <span class="p">(</span><span class="nx">rangeStep</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">sizeSpecified</span><span class="p">)</span> <span class="p">{</span>
                                  <span class="k">return</span> <span class="nx">makeExplicit</span><span class="p">({</span> <span class="nx">step</span><span class="o">:</span> <span class="nx">rangeStep</span> <span class="p">});</span>
                              <span class="p">}</span>
                              <span class="k">else</span> <span class="p">{</span>
                                  <span class="c1">// If top-level size is specified, we ignore specified rangeStep.</span>
                                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">rangeStepDropped</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
                              <span class="p">}</span>
                          <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">makeImplicit</span><span class="p">(</span><span class="nx">defaultRange</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">zero$$1</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">sizeSignal</span><span class="p">,</span> <span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">noRangeStep</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseScheme</span><span class="p">(</span><span class="nx">scheme</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isExtendedScheme</span><span class="p">(</span><span class="nx">scheme</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">scheme</span><span class="o">:</span> <span class="nx">scheme</span><span class="p">.</span><span class="nx">name</span> <span class="p">};</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scheme</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">r</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="nx">scheme</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scheme</span><span class="p">.</span><span class="nx">extent</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">r</span><span class="p">.</span><span class="nx">extent</span> <span class="o">=</span> <span class="nx">scheme</span><span class="p">.</span><span class="nx">extent</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">r</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">scheme</span><span class="o">:</span> <span class="nx">scheme</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defaultRange</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">zero$$1</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">sizeSignal</span><span class="p">,</span> <span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">noRangeStep</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">X</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">Y</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;point&#39;</span><span class="p">,</span> <span class="s1">&#39;band&#39;</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">noRangeStep</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;text&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">textXRangeStep</span><span class="p">)</span> <span class="p">{</span>
                          <span class="k">return</span> <span class="p">{</span> <span class="nx">step</span><span class="o">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">textXRangeStep</span> <span class="p">};</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span><span class="p">)</span> <span class="p">{</span>
                          <span class="k">return</span> <span class="p">{</span> <span class="nx">step</span><span class="o">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span> <span class="p">};</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="c1">// If range step is null, use zero to width or height.</span>
              <span class="c1">// Note that these range signals are temporary</span>
              <span class="c1">// as they can be merged and renamed.</span>
              <span class="c1">// (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)</span>
              <span class="c1">// We will later replace these temporary names with</span>
              <span class="c1">// the final name in assembleScaleRange()</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">Y</span> <span class="o">&amp;&amp;</span> <span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// For y continuous scale, we have to start from the height as the bottom part has the max value.</span>
                  <span class="k">return</span> <span class="p">[{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">sizeSignal</span> <span class="p">},</span> <span class="mi">0</span><span class="p">];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">sizeSignal</span> <span class="p">}];</span>
              <span class="p">}</span>
          <span class="k">case</span> <span class="nx">SIZE</span><span class="o">:</span>
              <span class="c1">// TODO: support custom rangeMin, rangeMax</span>
              <span class="kd">var</span> <span class="nx">rangeMin</span> <span class="o">=</span> <span class="nx">sizeRangeMin</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">zero$$1</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">rangeMax</span> <span class="o">=</span> <span class="nx">sizeRangeMax</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
              <span class="k">return</span> <span class="p">[</span><span class="nx">rangeMin</span><span class="p">,</span> <span class="nx">rangeMax</span><span class="p">];</span>
          <span class="k">case</span> <span class="nx">SHAPE</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;symbol&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="nx">COLOR</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">FILL</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">STROKE</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Only nominal data uses ordinal scale by default</span>
                  <span class="k">return</span> <span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;nominal&#39;</span> <span class="o">?</span> <span class="s1">&#39;category&#39;</span> <span class="o">:</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;rect&#39;</span> <span class="o">||</span> <span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;geoshape&#39;</span> <span class="o">?</span> <span class="s1">&#39;heatmap&#39;</span> <span class="o">:</span> <span class="s1">&#39;ramp&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="nx">OPACITY</span><span class="o">:</span>
              <span class="c1">// TODO: support custom rangeMin, rangeMax</span>
              <span class="k">return</span> <span class="p">[</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">minOpacity</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxOpacity</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach here */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Scale range undefined for channel &quot;</span> <span class="o">+</span> <span class="nx">channel</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">sizeRangeMin</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">zero$$1</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">zero$$1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;bar&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;tick&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">minBandSize</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;line&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;trail&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;rule&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">minStrokeWidth</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;text&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">minFontSize</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;point&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;square&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;circle&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">minSize</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach here */</span>
      <span class="c1">// sizeRangeMin not implemented for the mark</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">incompatibleChannel</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">mark</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">sizeRangeMax</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleConfig</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;bar&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;tick&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxBandSize</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxBandSize</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">minXYRangeStep</span><span class="p">(</span><span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;line&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;trail&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;rule&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxStrokeWidth</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;text&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxFontSize</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;point&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;square&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;circle&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxSize</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">maxSize</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="c1">// FIXME this case totally should be refactored</span>
              <span class="kd">var</span> <span class="nx">pointStep</span> <span class="o">=</span> <span class="nx">minXYRangeStep</span><span class="p">(</span><span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">);</span>
              <span class="k">return</span> <span class="p">(</span><span class="nx">pointStep</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">pointStep</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach here */</span>
      <span class="c1">// sizeRangeMax not implemented for the mark</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">incompatibleChannel</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">mark</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">minXYRangeStep</span><span class="p">(</span><span class="nx">xyRangeSteps</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">xyRangeSteps</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">xyRangeSteps</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">rangeStep</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">rangeStep</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="mi">21</span><span class="p">;</span> <span class="c1">// FIXME: re-evaluate the default value here.</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">parseUnitScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">parseNonUnitScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseUnitScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">localScaleComponents</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">;</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">localScaleComponents</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">specifiedScales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">localScaleCmpt</span> <span class="o">=</span> <span class="nx">localScaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">mergedScaleCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">specifiedValue</span> <span class="o">=</span> <span class="nx">specifiedScale</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">sType</span> <span class="o">=</span> <span class="nx">mergedScaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">supportedByScaleType</span> <span class="o">=</span> <span class="nx">scaleTypeSupportProperty</span><span class="p">(</span><span class="nx">sType</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">channelIncompatability</span> <span class="o">=</span> <span class="nx">channelScalePropertyIncompatability</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// If there is a specified value, check if it is compatible with scale type and channel</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">supportedByScaleType</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">scalePropertyNotWorkWithScaleType</span><span class="p">(</span><span class="nx">sType</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channelIncompatability</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// channel</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">channelIncompatability</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">supportedByScaleType</span> <span class="o">&amp;&amp;</span> <span class="nx">channelIncompatability</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// copyKeyFromObject ensure type safety</span>
                  <span class="nx">localScaleCmpt</span><span class="p">.</span><span class="nx">copyKeyFromObject</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">specifiedScale</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">getDefaultValue</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">mergedScaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">),</span> <span class="nx">mergedScaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;padding&#39;</span><span class="p">),</span> <span class="nx">mergedScaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;paddingInner&#39;</span><span class="p">),</span> <span class="nx">specifiedScale</span><span class="p">.</span><span class="nx">domain</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">localScaleCmpt</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// Note: This method is used in Voyager.</span>
  <span class="kd">function</span> <span class="nx">getDefaultValue</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">scalePadding</span><span class="p">,</span> <span class="nx">scalePaddingInner</span><span class="p">,</span> <span class="nx">specifiedDomain</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleConfig</span> <span class="o">=</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">;</span>
      <span class="c1">// If we have default rule-base, determine default value first</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;nice&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">nice</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;padding&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">padding</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">bar</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;paddingInner&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">paddingInner</span><span class="p">(</span><span class="nx">scalePadding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;paddingOuter&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">paddingOuter</span><span class="p">(</span><span class="nx">scalePadding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">scalePaddingInner</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;reverse&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;zero&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">zero$1</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedDomain</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Otherwise, use scale config</span>
      <span class="k">return</span> <span class="nx">scaleConfig</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseNonUnitScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">localScaleComponents</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;range&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">parseScaleRange</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">parseScaleProperty</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">property</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">localScaleComponents</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">valueWithExplicit</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">childComponent</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">childComponent</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">childValueWithExplicit</span> <span class="o">=</span> <span class="nx">childComponent</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">property</span><span class="p">);</span>
                  <span class="nx">valueWithExplicit</span> <span class="o">=</span> <span class="nx">mergeValuesWithExplicit</span><span class="p">(</span><span class="nx">valueWithExplicit</span><span class="p">,</span> <span class="nx">childValueWithExplicit</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="nx">tieBreakByComparing</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">switch</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
                          <span class="k">case</span> <span class="s1">&#39;range&#39;</span><span class="o">:</span>
                              <span class="c1">// For range step, prefer larger step</span>
                              <span class="k">if</span> <span class="p">(</span><span class="nx">v1</span><span class="p">.</span><span class="nx">step</span> <span class="o">&amp;&amp;</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">step</span><span class="p">)</span> <span class="p">{</span>
                                  <span class="k">return</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">step</span> <span class="o">-</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">step</span><span class="p">;</span>
                              <span class="p">}</span>
                              <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                          <span class="c1">// TODO: precedence rule for other properties</span>
                      <span class="p">}</span>
                      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="p">}));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">localScaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">valueWithExplicit</span><span class="p">);</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">nice</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">||</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">ScaleType</span><span class="p">.</span><span class="nx">TIME</span><span class="p">,</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span><span class="p">],</span> <span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">],</span> <span class="nx">channel</span><span class="p">);</span> <span class="c1">// return true for quantitative X/Y unless binned</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">padding</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">barConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">],</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isContinuousToContinuous</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">continuousPadding</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">continuousPadding</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;bar&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">((</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">||</span>
                      <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">barConfig</span><span class="p">.</span><span class="nx">continuousBandSize</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">POINT</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">pointPadding</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">paddingInner</span><span class="p">(</span><span class="nx">paddingValue</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">paddingValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If user has already manually specified &quot;padding&quot;, no need to add default paddingInner.</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">],</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// Padding is only set for X and Y by default.</span>
          <span class="c1">// Basically it doesn&#39;t make sense to add padding for color and size.</span>
          <span class="c1">// paddingOuter would only be called if it&#39;s a band scale, just return the default for bandScale.</span>
          <span class="k">return</span> <span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">bandPaddingInner</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">paddingOuter</span><span class="p">(</span><span class="nx">paddingValue</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">paddingInnerValue</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">paddingValue</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If user has already manually specified &quot;padding&quot;, no need to add default paddingOuter.</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">],</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// Padding is only set for X and Y by default.</span>
          <span class="c1">// Basically it doesn&#39;t make sense to add padding for color and size.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">bandPaddingOuter</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">scaleConfig</span><span class="p">.</span><span class="nx">bandPaddingOuter</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="cm">/* By default, paddingOuter is paddingInner / 2. The reason is that</span>
<span class="cm">                  size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).</span>
<span class="cm">                  and we want the width/height to be integer by default.</span>
<span class="cm">                  Note that step (by default) and cardinality are integers.) */</span>
              <span class="k">return</span> <span class="nx">paddingInnerValue</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">sort</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">sort</span> <span class="o">===</span> <span class="s1">&#39;descending&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// For continuous domain scales, Vega does not support domain sort.</span>
          <span class="c1">// Thus, we reverse range instead if sort is descending</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">zero$1</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedScale</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// If users explicitly provide a domain range, we should not augment zero as that will be unexpected.</span>
      <span class="kd">var</span> <span class="nx">hasCustomDomain</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">specifiedScale</span> <span class="o">&amp;&amp;</span> <span class="nx">specifiedScale</span> <span class="o">!==</span> <span class="s1">&#39;unaggregated&#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">hasCustomDomain</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// If there is no custom domain, return true only for the following cases:</span>
      <span class="c1">// 1) using quantitative field with size</span>
      <span class="c1">// While this can be either ratio or interval fields, our assumption is that</span>
      <span class="c1">// ratio are more common.</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;size&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 2) non-binned, quantitative x-scale or y-scale</span>
      <span class="c1">// (For binning, we should not include zero by default because binning are calculated without zero.)</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">],</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;trail&#39;</span><span class="p">],</span> <span class="nx">type</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">((</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">||</span>
                  <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Determine if there is a specified scale type and if it is appropriate,</span>
<span class="cm">   * or determine default type if type is unspecified or inappropriate.</span>
<span class="cm">   */</span>
  <span class="c1">// NOTE: CompassQL uses this method.</span>
  <span class="kd">function</span> <span class="nx">scaleType</span><span class="p">(</span><span class="nx">specifiedType</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">defaultScaleType</span> <span class="o">=</span> <span class="nx">defaultType$1</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// There is no scale for these channels</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedType</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Check if explicitly specified scale type is supported by the channel</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">channelSupportScaleType</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">specifiedType</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">specifiedType</span><span class="p">,</span> <span class="nx">defaultScaleType</span><span class="p">));</span>
              <span class="k">return</span> <span class="nx">defaultScaleType</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Check if explicitly specified scale type is supported by the data type</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">scaleTypeSupportDataType</span><span class="p">(</span><span class="nx">specifiedType</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithFieldDef</span><span class="p">(</span><span class="nx">specifiedType</span><span class="p">,</span> <span class="nx">defaultScaleType</span><span class="p">));</span>
              <span class="k">return</span> <span class="nx">defaultScaleType</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">specifiedType</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">defaultScaleType</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Determine appropriate default scale type.</span>
<span class="cm">   */</span>
  <span class="c1">// NOTE: Voyager uses this method.</span>
  <span class="kd">function</span> <span class="nx">defaultType$1</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">scaleConfig</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;nominal&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;ordinal&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isColorChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">||</span> <span class="nx">rangeType</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;discrete&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;shape&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">discreteChannelCannotEncode</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">));</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;rule&#39;</span><span class="p">],</span> <span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
                      <span class="c1">// The rect/bar mark should fit into a band.</span>
                      <span class="c1">// For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429</span>
                      <span class="k">return</span> <span class="s1">&#39;band&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="s1">&#39;band&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="c1">// Otherwise, use ordinal point scale so we can easily get center positions of the marks.</span>
              <span class="k">return</span> <span class="s1">&#39;point&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;temporal&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isColorChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;sequential&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">rangeType</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;discrete&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">discreteChannelCannotEncode</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;temporal&#39;</span><span class="p">));</span>
                  <span class="c1">// TODO: consider using quantize (equivalent to binning) once we have it</span>
                  <span class="k">return</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="s1">&#39;time&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;quantitative&#39;</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isColorChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="s1">&#39;bin-ordinal&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// Use `sequential` as the default color scale for continuous data</span>
                  <span class="c1">// since it supports both array range and scheme range.</span>
                  <span class="k">return</span> <span class="s1">&#39;sequential&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">rangeType</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">===</span> <span class="s1">&#39;discrete&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">discreteChannelCannotEncode</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;quantitative&#39;</span><span class="p">));</span>
                  <span class="c1">// TODO: consider using quantize (equivalent to binning) once we have it</span>
                  <span class="k">return</span> <span class="s1">&#39;ordinal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="c1">// x and y use a linear scale because selections don&#39;t work with bin scales.</span>
              <span class="c1">// Binned scales apply discretization but pan/zoom apply transformations to a [min, max] extent domain.</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">!==</span> <span class="s1">&#39;x&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">!==</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;bin-linear&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="s1">&#39;linear&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;latitude&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;longitude&#39;</span><span class="o">:</span>
          <span class="k">case</span> <span class="s1">&#39;geojson&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: should never reach this */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidFieldType</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseScale</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">parseScaleCore</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="nx">parseScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES_1</span> <span class="o">=</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">parseScaleProperty</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">prop</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// range depends on zero</span>
      <span class="nx">parseScaleRange</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseScaleCore</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span> <span class="o">=</span> <span class="nx">parseUnitScaleCore</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span> <span class="o">=</span> <span class="nx">parseNonUnitScaleCore</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Parse scales for all channels of a model.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">parseUnitScaleCore</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">SCALE_CHANNELS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">scaleComponents</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fieldDef</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="c1">// Don&#39;t generate scale for shape of geoshape</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span> <span class="o">===</span> <span class="nx">GEOSHAPE</span> <span class="o">&amp;&amp;</span>
              <span class="nx">channel</span> <span class="o">===</span> <span class="nx">SHAPE</span> <span class="o">&amp;&amp;</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">GEOJSON</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">scaleComponents</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">;</span>
              <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">;</span>
              <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">];</span> <span class="c1">// We use [&#39;scale&#39;] since we know that channel here has scale for sure</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">Y</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">&amp;&amp;</span> <span class="nx">specifiedScale</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">specifiedScale</span> <span class="o">!==</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">specifiedScale</span> <span class="o">||</span> <span class="p">{};</span>
              <span class="kd">var</span> <span class="nx">specifiedScaleType</span> <span class="o">=</span> <span class="nx">specifiedScale</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">sType</span> <span class="o">=</span> <span class="nx">scaleType</span><span class="p">(</span><span class="nx">specifiedScale</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">mark</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">);</span>
              <span class="nx">scaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ScaleComponent</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">sType</span><span class="p">,</span> <span class="nx">explicit</span><span class="o">:</span> <span class="nx">specifiedScaleType</span> <span class="o">===</span> <span class="nx">sType</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">scaleComponents</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">scaleTypeTieBreaker</span> <span class="o">=</span> <span class="nx">tieBreakByComparing</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">st1</span><span class="p">,</span> <span class="nx">st2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">scaleTypePrecedence</span><span class="p">(</span><span class="nx">st1</span><span class="p">)</span> <span class="o">-</span> <span class="nx">scaleTypePrecedence</span><span class="p">(</span><span class="nx">st2</span><span class="p">));</span> <span class="p">});</span>
  <span class="kd">function</span> <span class="nx">parseNonUnitScaleCore</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scaleComponents</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">scaleTypeWithExplicitIndex</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">resolve</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">parseScaleCore</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
          <span class="c1">// Instead of always merging right away -- check if it is compatible to merge first!</span>
          <span class="nx">keys</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// if resolve is undefined, set default first</span>
              <span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">||</span> <span class="nx">defaultScaleResolve</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">explicitScaleType</span> <span class="o">=</span> <span class="nx">scaleTypeWithExplicitIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
                  <span class="kd">var</span> <span class="nx">childScaleType</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">explicitScaleType</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">scaleCompatible</span><span class="p">(</span><span class="nx">explicitScaleType</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">childScaleType</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
                          <span class="c1">// merge scale component if type are compatible</span>
                          <span class="nx">scaleTypeWithExplicitIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">mergeValuesWithExplicit</span><span class="p">(</span><span class="nx">explicitScaleType</span><span class="p">,</span> <span class="nx">childScaleType</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="nx">scaleTypeTieBreaker</span><span class="p">);</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="p">{</span>
                          <span class="c1">// Otherwise, update conflicting channel to be independent</span>
                          <span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;independent&#39;</span><span class="p">;</span>
                          <span class="c1">// Remove from the index so they don&#39;t get merged</span>
                          <span class="k">delete</span> <span class="nx">scaleTypeWithExplicitIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">scaleTypeWithExplicitIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">childScaleType</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="c1">// Parse each child scale and determine if a particular channel can be merged.</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Merge each channel listed in the index</span>
      <span class="nx">keys</span><span class="p">(</span><span class="nx">scaleTypeWithExplicitIndex</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Create new merged scale component</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">typeWithExplicit</span> <span class="o">=</span> <span class="nx">scaleTypeWithExplicitIndex</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="nx">scaleComponents</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ScaleComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">typeWithExplicit</span><span class="p">);</span>
          <span class="c1">// rename each child and mark them as merged</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">childScale</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">childScale</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">child</span><span class="p">.</span><span class="nx">renameScale</span><span class="p">(</span><span class="nx">childScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">),</span> <span class="nx">name</span><span class="p">);</span>
                  <span class="nx">childScale</span><span class="p">.</span><span class="nx">merged</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">scaleComponents</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">NameMap</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">NameMap</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">nameMap</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="p">}</span>
      <span class="nx">NameMap</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">rename</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">nameMap</span><span class="p">[</span><span class="nx">oldName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newName</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">NameMap</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">has</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">nameMap</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">NameMap</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If the name appears in the _nameMap, we need to read its new name.</span>
          <span class="c1">// We have to loop over the dict just in case the new name also gets renamed.</span>
          <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">nameMap</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">name</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">nameMap</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">{</span>
              <span class="nx">name</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">nameMap</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">name</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">NameMap</span><span class="p">;</span>
  <span class="p">}());</span>
  <span class="cm">/*</span>
<span class="cm">    We use type guards instead of `instanceof` as `instanceof` makes</span>
<span class="cm">    different parts of the compiler depend on the actual implementation of</span>
<span class="cm">    the model classes, which in turn depend on different parts of the compiler.</span>
<span class="cm">    Thus, `instanceof` leads to circular dependency problems.</span>

<span class="cm">    On the other hand, type guards only make different parts of the compiler</span>
<span class="cm">    depend on the type of the model classes, but not the actual implementation.</span>
<span class="cm">  */</span>
  <span class="kd">function</span> <span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;unit&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;facet&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isRepeatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;repeat&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isConcatModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;concat&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isLayerModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">model</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;layer&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">Model</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="kd">function</span> <span class="nx">Model</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="cm">/**</span>
<span class="cm">           * Corrects the data references in marks after assemble.</span>
<span class="cm">           */</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">correctDataNames</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// TODO: make this correct</span>
              <span class="c1">// for normal data references</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">from</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">lookupDataSource</span><span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="c1">// for access to facet data</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">from</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">facet</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">lookupDataSource</span><span class="p">(</span><span class="nx">mark</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">mark</span><span class="p">;</span>
          <span class="p">};</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">config</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">repeater</span> <span class="o">=</span> <span class="nx">repeater</span><span class="p">;</span>
          <span class="c1">// If name is not provided, always use parent&#39;s givenName to avoid name conflicts.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="nx">parentGivenName</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">title</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">text</span><span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">title</span> <span class="p">}</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">title</span><span class="p">;</span>
          <span class="c1">// Shared name maps</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">scaleNameMap</span> <span class="o">=</span> <span class="nx">parent</span> <span class="o">?</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">scaleNameMap</span> <span class="o">:</span> <span class="k">new</span> <span class="nx">NameMap</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">projectionNameMap</span> <span class="o">=</span> <span class="nx">parent</span> <span class="o">?</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">projectionNameMap</span> <span class="o">:</span> <span class="k">new</span> <span class="nx">NameMap</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">layoutSizeNameMap</span> <span class="o">=</span> <span class="nx">parent</span> <span class="o">?</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">layoutSizeNameMap</span> <span class="o">:</span> <span class="k">new</span> <span class="nx">NameMap</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">description</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">description</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">transforms</span> <span class="o">=</span> <span class="nx">normalizeTransform</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">transform</span> <span class="o">||</span> <span class="p">[]);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">sources</span><span class="o">:</span> <span class="nx">parent</span> <span class="o">?</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">sources</span> <span class="o">:</span> <span class="p">{},</span>
                  <span class="nx">outputNodes</span><span class="o">:</span> <span class="nx">parent</span> <span class="o">?</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodes</span> <span class="o">:</span> <span class="p">{},</span>
                  <span class="nx">outputNodeRefCounts</span><span class="o">:</span> <span class="nx">parent</span> <span class="o">?</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodeRefCounts</span> <span class="o">:</span> <span class="p">{},</span>
                  <span class="c1">// data is faceted if the spec is a facet spec or the parent has faceted data and no data is defined</span>
                  <span class="nx">isFaceted</span><span class="o">:</span> <span class="nx">isFacetSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">parent</span> <span class="o">&amp;&amp;</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">isFaceted</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">spec</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
              <span class="p">},</span>
              <span class="nx">layoutSize</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Split</span><span class="p">(),</span>
              <span class="nx">layoutHeaders</span><span class="o">:</span> <span class="p">{</span> <span class="nx">row</span><span class="o">:</span> <span class="p">{},</span> <span class="nx">column</span><span class="o">:</span> <span class="p">{}</span> <span class="p">},</span>
              <span class="nx">mark</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
              <span class="nx">resolve</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">scale</span><span class="o">:</span> <span class="p">{},</span> <span class="nx">axis</span><span class="o">:</span> <span class="p">{},</span> <span class="nx">legend</span><span class="o">:</span> <span class="p">{}</span> <span class="p">},</span> <span class="p">(</span><span class="nx">resolve</span> <span class="o">||</span> <span class="p">{})),</span>
              <span class="nx">selection</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
              <span class="nx">scales</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
              <span class="nx">projection</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
              <span class="nx">axes</span><span class="o">:</span> <span class="p">{},</span>
              <span class="nx">legends</span><span class="o">:</span> <span class="p">{},</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">);</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">);</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">initSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">size</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">size</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseScale</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseLayoutSize</span><span class="p">();</span> <span class="c1">// depends on scale</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">renameTopLevelLayoutSize</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseSelection</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseProjection</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseData</span><span class="p">();</span> <span class="c1">// (pathorder) depends on markDef; selection filters depend on parsed selections; depends on projection because some transforms require the finalized projection name.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span><span class="p">();</span> <span class="c1">// depends on scale and layout size</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseLegend</span><span class="p">();</span> <span class="c1">// depends on scale, markDef</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseMarkGroup</span><span class="p">();</span> <span class="c1">// depends on data name, scale, layout size, axisGroup, and children&#39;s scale, axis, legend and mark.</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseScale</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseScale</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseProjection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseProjection</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Rename top-level spec&#39;s size to be just width / height, ignoring model name.</span>
<span class="cm">       * This essentially merges the top-level spec&#39;s width/height signals with the width/height signals</span>
<span class="cm">       * to help us reduce redundant signals declaration.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">renameTopLevelLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">)</span> <span class="o">!==</span> <span class="s1">&#39;width&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">renameLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">),</span> <span class="s1">&#39;width&#39;</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span> <span class="o">!==</span> <span class="s1">&#39;height&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">renameLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">),</span> <span class="s1">&#39;height&#39;</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseLegend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseLegend</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleGroupStyle</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;unit&#39;</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;layer&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;cell&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;unit&#39;</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;layer&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">width</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">),</span>
                  <span class="nx">height</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
              <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleHeaderMarks</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">layoutHeaders</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">headerMarks</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">HEADER_CHANNELS_1</span> <span class="o">=</span> <span class="nx">HEADER_CHANNELS</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">HEADER_CHANNELS_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">HEADER_CHANNELS_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">headerMarks</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">getTitleGroup</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">HEADER_CHANNELS_2</span> <span class="o">=</span> <span class="nx">HEADER_CHANNELS</span><span class="p">;</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">HEADER_CHANNELS_2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">HEADER_CHANNELS_2</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
              <span class="nx">headerMarks</span> <span class="o">=</span> <span class="nx">headerMarks</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">getHeaderGroups</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">headerMarks</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleAxes</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleAxes</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLegends</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleLegends</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleProjections</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleProjections</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleTitle</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">extractTitleConfig</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">title</span><span class="p">).</span><span class="nx">nonMark</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">title</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">title$$1</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;layer&#39;</span><span class="p">],</span> <span class="k">this</span><span class="p">.</span><span class="nx">type</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// As described in https://github.com/vega/vega-lite/issues/2875:</span>
                  <span class="c1">// Due to vega/vega#960 (comment), we only support title&#39;s anchor for unit and layered spec for now.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">title$$1</span><span class="p">.</span><span class="nx">anchor</span> <span class="o">&amp;&amp;</span> <span class="nx">title$$1</span><span class="p">.</span><span class="nx">anchor</span> <span class="o">!==</span> <span class="s1">&#39;start&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">cannotSetTitleAnchor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">type</span><span class="p">));</span>
                  <span class="p">}</span>
                  <span class="nx">title$$1</span><span class="p">.</span><span class="nx">anchor</span> <span class="o">=</span> <span class="s1">&#39;start&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">title$$1</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">title$$1</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Assemble the mark group for this model.  We accept optional `signals` so that we can include concat top-level signals with the top-level model&#39;s local signals.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">signals</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">signals</span> <span class="o">=</span> <span class="p">[];</span> <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">group</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">signals</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span><span class="p">());</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">signals</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">group</span><span class="p">.</span><span class="nx">signals</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">layout</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">assembleLayout</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">layout</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">group</span><span class="p">.</span><span class="nx">layout</span> <span class="o">=</span> <span class="nx">layout</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">group</span><span class="p">.</span><span class="nx">marks</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">assembleHeaderMarks</span><span class="p">(),</span> <span class="k">this</span><span class="p">.</span><span class="nx">assembleMarks</span><span class="p">());</span>
          <span class="c1">// Only include scales if this spec is top-level or if parent is facet.</span>
          <span class="c1">// (Otherwise, it will be merged with upper-level&#39;s scope.)</span>
          <span class="kd">var</span> <span class="nx">scales</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">||</span> <span class="nx">isFacetModel</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">))</span> <span class="o">?</span> <span class="nx">assembleScales</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">:</span> <span class="p">[];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scales</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">group</span><span class="p">.</span><span class="nx">scales</span> <span class="o">=</span> <span class="nx">scales</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">axes</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">assembleAxes</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">axes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">group</span><span class="p">.</span><span class="nx">axes</span> <span class="o">=</span> <span class="nx">axes</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">legends</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">assembleLegends</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">legends</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">group</span><span class="p">.</span><span class="nx">legends</span> <span class="o">=</span> <span class="nx">legends</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">group</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasDescendantWithFieldOnChannel</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">child</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">hasDescendantWithFieldOnChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">varName</span><span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">text</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Request a data source name for the given data source type and mark that data source as required. This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">requestDataName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fullName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
          <span class="c1">// Increase ref count. This is critical because otherwise we won&#39;t create a data source.</span>
          <span class="c1">// We also increase the ref counts on OutputNode.getSource() calls.</span>
          <span class="kd">var</span> <span class="nx">refCounts</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodeRefCounts</span><span class="p">;</span>
          <span class="nx">refCounts</span><span class="p">[</span><span class="nx">fullName</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">refCounts</span><span class="p">[</span><span class="nx">fullName</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">fullName</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSizeSignalRef</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">sizeType</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetModel</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">sizeType</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleComponent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// independent scale</span>
                  <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                  <span class="kd">var</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">range</span><span class="p">))</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">scaleName</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">);</span>
                      <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">assembleDomain</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
                      <span class="kd">var</span> <span class="nx">field$$1</span> <span class="o">=</span> <span class="nx">getFieldFromDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">field$$1</span><span class="p">)</span> <span class="p">{</span>
                          <span class="kd">var</span> <span class="nx">fieldRef</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">({</span> <span class="nx">aggregate</span><span class="o">:</span> <span class="s1">&#39;distinct&#39;</span><span class="p">,</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field$$1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">});</span>
                          <span class="k">return</span> <span class="p">{</span>
                              <span class="nx">signal</span><span class="o">:</span> <span class="nx">sizeExpr</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scaleComponent</span><span class="p">,</span> <span class="nx">fieldRef</span><span class="p">)</span>
                          <span class="p">};</span>
                      <span class="p">}</span>
                      <span class="k">else</span> <span class="p">{</span>
                          <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Unknown field for </span><span class="cp">${</span><span class="n">channel</span><span class="cp">}</span><span class="s1">.  Cannot calculate view size.&#39;</span><span class="p">);</span>
                          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">layoutSizeNameMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">))</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Lookup the name of the datasource for an output node. You probably want to call this in assemble.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">lookupDataSource</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodes</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Name not found in map so let&#39;s just return what we got.</span>
              <span class="c1">// This can happen if we already have the correct name.</span>
              <span class="k">return</span> <span class="nx">name</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">getSource</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSizeName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldSizeName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">layoutSizeNameMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">oldSizeName</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">renameLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">layoutSizeNameMap</span><span class="p">.</span><span class="nx">rename</span><span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">renameScale</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">scaleNameMap</span><span class="p">.</span><span class="nx">rename</span><span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">renameProjection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">projectionNameMap</span><span class="p">.</span><span class="nx">rename</span><span class="p">(</span><span class="nx">oldName</span><span class="p">,</span> <span class="nx">newName</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * @return scale name for a given channel after the scale has been parsed and named.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">scaleName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">originalScaleName</span><span class="p">,</span> <span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// During the parse phase always return a value</span>
              <span class="c1">// No need to refer to rename map because a scale can&#39;t be renamed</span>
              <span class="c1">// before it has the original name.</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">originalScaleName</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="c1">// If there is a scale for the channel, it should either</span>
          <span class="c1">// be in the scale component or exist in the name map</span>
          <span class="k">if</span> <span class="p">(</span>
          <span class="c1">// If there is a scale for the channel, there should be a local scale component for it</span>
          <span class="p">(</span><span class="nx">isChannel</span><span class="p">(</span><span class="nx">originalScaleName</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isScaleChannel</span><span class="p">(</span><span class="nx">originalScaleName</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">originalScaleName</span><span class="p">])</span> <span class="o">||</span>
              <span class="c1">// in the scale name map (the scale get merged by its parent)</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">scaleNameMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">originalScaleName</span><span class="p">)))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">scaleNameMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">originalScaleName</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * @return projection name after the projection has been parsed and named.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">projectionName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// During the parse phase always return a value</span>
              <span class="c1">// No need to refer to rename map because a projection can&#39;t be renamed</span>
              <span class="c1">// before it has the original name.</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;projection&#39;</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">projection</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">projectionNameMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;projection&#39;</span><span class="p">)))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">projectionNameMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;projection&#39;</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Traverse a model&#39;s hierarchy to get the scale component for a particular channel.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getScaleComponent</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="cm">/* istanbul ignore next: This is warning for debugging test */</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;getScaleComponent cannot be called before parseScale().  Make sure you have called parseScale or use parseUnitModelWithScale().&#39;</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">localScaleComponent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">localScaleComponent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">localScaleComponent</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">localScaleComponent</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Traverse a model&#39;s hierarchy to get a particular selection component.</span>
<span class="cm">       */</span>
      <span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSelectionComponent</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">variableName</span><span class="p">,</span> <span class="nx">origName</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">sel</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">[</span><span class="nx">variableName</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">sel</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">sel</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">getSelectionComponent</span><span class="p">(</span><span class="nx">variableName</span><span class="p">,</span> <span class="nx">origName</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">sel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">selectionNotFound</span><span class="p">(</span><span class="nx">origName</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">sel</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">Model</span><span class="p">;</span>
  <span class="p">}());</span>
  <span class="cm">/** Abstract class for UnitModel and FacetModel.  Both of which can contain fieldDefs as a part of its own specification. */</span>
  <span class="kd">var</span> <span class="nx">ModelWithField</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">ModelWithField</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">ModelWithField</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">_super</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/** Get &quot;field&quot; reference for vega */</span>
      <span class="nx">ModelWithField</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">vgField</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">opt</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">ModelWithField</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">reduceFieldDef</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">init</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">reduce</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getMapping</span><span class="p">(),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cd</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">cd</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">acc</span><span class="p">;</span>
          <span class="p">},</span> <span class="nx">init</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">ModelWithField</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forEachFieldDef</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">forEach</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getMapping</span><span class="p">(),</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">cd</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">cd</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">f</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">},</span> <span class="nx">t</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">ModelWithField</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Model</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">scaleBindings</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;interval&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">&amp;&amp;</span>
              <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">bind</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">bind</span> <span class="o">===</span> <span class="s1">&#39;scales&#39;</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selDef</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">bound</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">scales</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scale</span> <span class="o">?</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">scale</span> <span class="o">||</span> <span class="o">!</span><span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isBinScale</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">SCALE_BINDINGS_CONTINUOUS</span><span class="p">);</span>
                  <span class="k">return</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="nx">scale</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="p">},</span> <span class="kc">true</span><span class="p">);</span>
              <span class="nx">bound</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
              <span class="c1">// Bind both x/y for diag plot of repeated views.</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">repeater</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">repeater</span><span class="p">.</span><span class="nx">row</span> <span class="o">===</span> <span class="nx">model</span><span class="p">.</span><span class="nx">repeater</span><span class="p">.</span><span class="nx">column</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">scale2</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">?</span> <span class="nx">Y</span> <span class="o">:</span> <span class="nx">X</span><span class="p">);</span>
                  <span class="nx">scale2</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="p">},</span> <span class="kc">true</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">},</span>
      <span class="nx">topLevelSignals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Top-level signals are only needed when coordinating composed views.</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">signals</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">channels</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">scales</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">signals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">);</span> <span class="p">}).</span><span class="nx">length</span><span class="p">);</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">channels</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span> <span class="p">};</span>
          <span class="p">}));</span>
      <span class="p">},</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Nested signals need only push to top-level signals when within composed views.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">scales</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">);</span> <span class="p">})[</span><span class="mi">0</span><span class="p">];</span>
                  <span class="nx">signal</span><span class="p">.</span><span class="nx">push</span> <span class="o">=</span> <span class="s1">&#39;outer&#39;</span><span class="p">;</span>
                  <span class="k">delete</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
                  <span class="k">delete</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">update</span><span class="p">;</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">domain$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
      <span class="k">return</span> <span class="s2">&quot;domain(&quot;</span> <span class="o">+</span> <span class="nx">scale</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">BRUSH</span> <span class="o">=</span> <span class="s1">&#39;_brush&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">SCALE_TRIGGER</span> <span class="o">=</span> <span class="s1">&#39;_scale_trigger&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">interval</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">predicate</span><span class="o">:</span> <span class="s1">&#39;vlInterval&#39;</span><span class="p">,</span>
      <span class="nx">scaleDomain</span><span class="o">:</span> <span class="s1">&#39;vlIntervalDomain&#39;</span><span class="p">,</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">hasScales</span> <span class="o">=</span> <span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">signals</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">intervals</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">tupleTriggers</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">scaleTriggers</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">translate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasScales</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">filterExpr_1</span> <span class="o">=</span> <span class="s2">&quot;!event.item || event.item.mark.name !== &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">BRUSH</span><span class="p">);</span>
              <span class="nx">events</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">filters</span> <span class="o">=</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">between</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">filter</span> <span class="o">||</span> <span class="p">(</span><span class="nx">evt</span><span class="p">.</span><span class="nx">between</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">filter</span> <span class="o">=</span> <span class="p">[]);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">filters</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">filterExpr_1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">filters</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">filterExpr_1</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">!==</span> <span class="nx">X</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">!==</span> <span class="nx">Y</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Interval selections only support x and y encoding channels.&#39;</span><span class="p">);</span>
                  <span class="k">return</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="kd">var</span> <span class="nx">cs</span> <span class="o">=</span> <span class="nx">channelSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">dname</span> <span class="o">=</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">vname</span> <span class="o">=</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;visual&#39;</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">scaleStr</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
              <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">toNum</span> <span class="o">=</span> <span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;+&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
              <span class="nx">signals</span><span class="p">.</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">cs</span><span class="p">);</span>
              <span class="nx">tupleTriggers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dname</span><span class="p">);</span>
              <span class="nx">intervals</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;{encoding: &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span>
                  <span class="p">(</span><span class="s2">&quot;field: &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, extent: &quot;</span> <span class="o">+</span> <span class="nx">dname</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">));</span>
              <span class="nx">scaleTriggers</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                  <span class="nx">scaleName</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">),</span>
                  <span class="nx">expr</span><span class="o">:</span> <span class="s2">&quot;(!isArray(&quot;</span> <span class="o">+</span> <span class="nx">dname</span> <span class="o">+</span> <span class="s2">&quot;) || &quot;</span> <span class="o">+</span>
                      <span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">toNum</span> <span class="o">+</span> <span class="s2">&quot;invert(&quot;</span> <span class="o">+</span> <span class="nx">scaleStr</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">vname</span> <span class="o">+</span> <span class="s2">&quot;)[0] === &quot;</span> <span class="o">+</span> <span class="nx">toNum</span> <span class="o">+</span> <span class="nx">dname</span> <span class="o">+</span> <span class="s2">&quot;[0] &amp;&amp; &quot;</span><span class="p">)</span> <span class="o">+</span>
                      <span class="p">(</span><span class="nx">toNum</span> <span class="o">+</span> <span class="s2">&quot;invert(&quot;</span> <span class="o">+</span> <span class="nx">scaleStr</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">vname</span> <span class="o">+</span> <span class="s2">&quot;)[1] === &quot;</span> <span class="o">+</span> <span class="nx">toNum</span> <span class="o">+</span> <span class="nx">dname</span> <span class="o">+</span> <span class="s2">&quot;[1]))&quot;</span><span class="p">)</span>
              <span class="p">});</span>
          <span class="p">});</span>
          <span class="c1">// Proxy scale reactions to ensure that an infinite loop doesn&#39;t occur</span>
          <span class="c1">// when an interval selection filter touches the scale.</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasScales</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">signals</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                  <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">SCALE_TRIGGER</span><span class="p">,</span>
                  <span class="nx">update</span><span class="o">:</span> <span class="nx">scaleTriggers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expr</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">)</span> <span class="o">+</span>
                      <span class="p">(</span><span class="s2">&quot; ? &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">SCALE_TRIGGER</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; : {}&quot;</span><span class="p">)</span>
              <span class="p">});</span>
          <span class="p">}</span>
          <span class="c1">// Only add an interval to the store if it has valid data extents. Data extents</span>
          <span class="c1">// are set to null if pixel extents are equal to account for intervals over</span>
          <span class="c1">// ordinal/nominal domains which, when inverted, will still produce a valid datum.</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">,</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">tupleTriggers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">({</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">t</span> <span class="p">});</span> <span class="p">}),</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="nx">tupleTriggers</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">)</span> <span class="o">+</span>
                          <span class="p">(</span><span class="s2">&quot; ? {unit: &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, intervals: [&quot;</span> <span class="o">+</span> <span class="nx">intervals</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]} : null&quot;</span><span class="p">)</span>
                  <span class="p">}]</span>
          <span class="p">});</span>
      <span class="p">},</span>
      <span class="nx">modifyExpr</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">tpl</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">tpl</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span>
              <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">?</span> <span class="s1">&#39;true&#39;</span> <span class="o">:</span> <span class="s2">&quot;{unit: &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">);</span>
      <span class="p">},</span>
      <span class="nx">marks</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">marks</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">positionalProjections</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">),</span> <span class="nx">xi</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">xi</span><span class="p">,</span> <span class="nx">yi</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">yi</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">store</span> <span class="o">=</span> <span class="s2">&quot;data(&quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">STORE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
          <span class="c1">// Do not add a brush if we&#39;re binding to scales.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">marks</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">x</span><span class="o">:</span> <span class="nx">xi</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_x[0]&quot;</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span> <span class="p">},</span>
              <span class="nx">y</span><span class="o">:</span> <span class="nx">yi</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_y[0]&quot;</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span> <span class="p">},</span>
              <span class="nx">x2</span><span class="o">:</span> <span class="nx">xi</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_x[1]&quot;</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;width&#39;</span> <span class="p">}</span> <span class="p">},</span>
              <span class="nx">y2</span><span class="o">:</span> <span class="nx">yi</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_y[1]&quot;</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;height&#39;</span> <span class="p">}</span> <span class="p">}</span>
          <span class="p">};</span>
          <span class="c1">// If the selection is resolved to global, only a single interval is in</span>
          <span class="c1">// the store. Wrap brush mark&#39;s encodings with a production rule to test</span>
          <span class="c1">// this based on the `unit` property. Hide the brush mark if it corresponds</span>
          <span class="c1">// to a unit different from the one in the store.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">update</span><span class="p">);</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                  <span class="nx">update</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">test</span><span class="o">:</span> <span class="nx">store</span> <span class="o">+</span> <span class="s2">&quot;.length &amp;&amp; &quot;</span> <span class="o">+</span> <span class="nx">store</span> <span class="o">+</span> <span class="s2">&quot;[0].unit === &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">},</span> <span class="nx">update</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]),</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span> <span class="p">}];</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="c1">// Two brush marks ensure that fill colors and other aesthetic choices do</span>
          <span class="c1">// not interefere with the core marks, but that the brushed region can still</span>
          <span class="c1">// be interacted with (e.g., dragging it around).</span>
          <span class="kd">var</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">fill</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">fill</span><span class="p">,</span> <span class="nx">fillOpacity</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">fillOpacity</span><span class="p">,</span> <span class="nx">stroke</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">_c</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;fill&quot;</span><span class="p">,</span> <span class="s2">&quot;fillOpacity&quot;</span><span class="p">]);</span>
          <span class="kd">var</span> <span class="nx">vgStroke</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">stroke</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">def</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">def</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{</span>
                      <span class="nx">test</span><span class="o">:</span> <span class="p">[</span>
                          <span class="nx">xi</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_x[0] !== &quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_x[1]&quot;</span><span class="p">,</span>
                          <span class="nx">yi</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_y[0] !== &quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_y[1]&quot;</span><span class="p">,</span>
                      <span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">),</span>
                      <span class="nx">value</span><span class="o">:</span> <span class="nx">stroke</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
                  <span class="p">},</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">null</span> <span class="p">}];</span>
              <span class="k">return</span> <span class="nx">def</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">BRUSH</span> <span class="o">+</span> <span class="s1">&#39;_bg&#39;</span><span class="p">,</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;rect&#39;</span><span class="p">,</span>
                  <span class="nx">clip</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
                  <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">enter</span><span class="o">:</span> <span class="p">{</span>
                          <span class="nx">fill</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">fill</span> <span class="p">},</span>
                          <span class="nx">fillOpacity</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">fillOpacity</span> <span class="p">}</span>
                      <span class="p">},</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="nx">update</span>
                  <span class="p">}</span>
              <span class="p">}].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">marks</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">BRUSH</span><span class="p">,</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;rect&#39;</span><span class="p">,</span>
              <span class="nx">clip</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
              <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">enter</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">fill</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;transparent&#39;</span> <span class="p">}</span>
                  <span class="p">},</span>
                  <span class="nx">update</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">update</span><span class="p">,</span> <span class="nx">vgStroke</span><span class="p">)</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns the visual and data signals for an interval selection.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">channelSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">vname</span> <span class="o">=</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;visual&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">dname</span> <span class="o">=</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">hasScales</span> <span class="o">=</span> <span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scaleStr</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scale</span> <span class="o">?</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">).</span><span class="nx">signal</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">coord</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot;(unit)&quot;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">on</span> <span class="o">=</span> <span class="nx">events</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">def</span><span class="p">,</span> <span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">def</span><span class="p">.</span><span class="nx">concat</span><span class="p">({</span> <span class="nx">events</span><span class="o">:</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">between</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">coord</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">coord</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="p">},</span> <span class="c1">// Brush Start</span>
          <span class="p">{</span> <span class="nx">events</span><span class="o">:</span> <span class="nx">evt</span><span class="p">,</span> <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">vname</span> <span class="o">+</span> <span class="s2">&quot;[0], clamp(&quot;</span> <span class="o">+</span> <span class="nx">coord</span> <span class="o">+</span> <span class="s2">&quot;, 0, &quot;</span> <span class="o">+</span> <span class="nx">size</span> <span class="o">+</span> <span class="s2">&quot;)]&quot;</span> <span class="p">}</span> <span class="c1">// Brush End</span>
          <span class="p">);</span>
      <span class="p">});</span>
      <span class="c1">// React to pan/zooms of continuous scales. Non-continuous scales</span>
      <span class="c1">// (bin-linear, band, point) cannot be pan/zoomed and any other changes</span>
      <span class="c1">// to their domains (e.g., filtering) should clear the brushes.</span>
      <span class="nx">on</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="nx">events</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">SCALE_TRIGGER</span> <span class="p">},</span>
          <span class="nx">update</span><span class="o">:</span> <span class="nx">hasContinuousDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isBinScale</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">?</span>
              <span class="s2">&quot;[scale(&quot;</span> <span class="o">+</span> <span class="nx">scaleStr</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">dname</span> <span class="o">+</span> <span class="s2">&quot;[0]), scale(&quot;</span> <span class="o">+</span> <span class="nx">scaleStr</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">dname</span> <span class="o">+</span> <span class="s2">&quot;[1])]&quot;</span> <span class="o">:</span> <span class="s2">&quot;[0, 0]&quot;</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">hasScales</span> <span class="o">?</span> <span class="p">[{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">dname</span><span class="p">,</span> <span class="nx">on</span><span class="o">:</span> <span class="p">[]</span> <span class="p">}]</span> <span class="o">:</span> <span class="p">[{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">vname</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="p">[],</span> <span class="nx">on</span><span class="o">:</span> <span class="nx">on</span>
          <span class="p">},</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">dname</span><span class="p">,</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span> <span class="nx">events</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">vname</span> <span class="p">},</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">vname</span> <span class="o">+</span> <span class="s2">&quot;[0] === &quot;</span> <span class="o">+</span> <span class="nx">vname</span> <span class="o">+</span> <span class="s2">&quot;[1] ? null : invert(&quot;</span> <span class="o">+</span> <span class="nx">scaleStr</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">vname</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="p">}]</span>
          <span class="p">}];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">events</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">on</span><span class="p">,</span> <span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">evt</span><span class="p">.</span><span class="nx">between</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">evt</span> <span class="o">+</span> <span class="s2">&quot; is not an ordered event stream for interval selections&quot;</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">on</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">cb</span><span class="p">(</span><span class="nx">on</span><span class="p">,</span> <span class="nx">evt</span><span class="p">);</span>
      <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">VORONOI</span> <span class="o">=</span> <span class="s1">&#39;voronoi&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">nearest</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">&#39;interval&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">nearest</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">marks</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">marks</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">positionalProjections</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">),</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">markType</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isPathMark</span><span class="p">(</span><span class="nx">markType</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">nearestNotSupportForContinuous</span><span class="p">(</span><span class="nx">markType</span><span class="p">));</span>
              <span class="k">return</span> <span class="nx">marks</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">cellDef</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">VORONOI</span><span class="p">),</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;path&#39;</span><span class="p">,</span>
              <span class="nx">from</span><span class="o">:</span> <span class="p">{</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;marks&#39;</span><span class="p">)</span> <span class="p">},</span>
              <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">enter</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">fill</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;transparent&#39;</span> <span class="p">},</span>
                      <span class="nx">strokeWidth</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mf">0.35</span> <span class="p">},</span>
                      <span class="nx">stroke</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;transparent&#39;</span> <span class="p">},</span>
                      <span class="nx">isVoronoi</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">},</span>
              <span class="nx">transform</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;voronoi&#39;</span><span class="p">,</span>
                      <span class="nx">x</span><span class="o">:</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">y</span><span class="p">))</span> <span class="o">?</span> <span class="s1">&#39;datum.datum.x || 0&#39;</span> <span class="o">:</span> <span class="s1">&#39;0&#39;</span> <span class="p">},</span>
                      <span class="nx">y</span><span class="o">:</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="p">(</span><span class="nx">y</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">y</span><span class="p">))</span> <span class="o">?</span> <span class="s1">&#39;datum.datum.y || 0&#39;</span> <span class="o">:</span> <span class="s1">&#39;0&#39;</span> <span class="p">},</span>
                      <span class="nx">size</span><span class="o">:</span> <span class="p">[</span><span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)]</span>
                  <span class="p">}]</span>
          <span class="p">};</span>
          <span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">exists</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
          <span class="nx">marks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">mark</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">mark</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">VORONOI</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">exists</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">exists</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">marks</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">cellDef</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">marks</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">signals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">proj</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">datum</span> <span class="o">=</span> <span class="nx">nearest</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="o">?</span>
          <span class="s1">&#39;(item().isVoronoi ? datum.datum : datum)&#39;</span> <span class="o">:</span> <span class="s1">&#39;datum&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">bins</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">encodings</span> <span class="o">=</span> <span class="nx">proj</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">);</span> <span class="p">}).</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="nx">proj</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">values</span> <span class="o">=</span> <span class="nx">proj</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="c1">// Binned fields should capture extents, for a range test against the raw field.</span>
          <span class="k">return</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="nx">bins</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">),</span>
              <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{}),</span> <span class="nx">datum</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span>
                  <span class="p">(</span><span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">}),</span> <span class="nx">datum</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">))</span> <span class="o">:</span>
              <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">datum</span><span class="p">);</span>
      <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">);</span>
      <span class="c1">// Only add a discrete selection to the store if a datum is present _and_</span>
      <span class="c1">// the interaction isn&#39;t occurring on a group mark. This guards against</span>
      <span class="c1">// polluting interactive state with invalid values in faceted displays</span>
      <span class="c1">// as the group marks are also data-driven. We force the update to account</span>
      <span class="c1">// for constant null states but varying toggles (e.g., shift-click in</span>
      <span class="c1">// whitespace followed by a click in whitespace; the store should only</span>
      <span class="c1">// be cleared on the second click).</span>
      <span class="k">return</span> <span class="p">[{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="p">{},</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">events</span><span class="p">,</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;datum &amp;&amp; item().mark.marktype !== &#39;group&#39; ? &quot;</span> <span class="o">+</span>
                          <span class="p">(</span><span class="s2">&quot;{unit: &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, encodings: [&quot;</span> <span class="o">+</span> <span class="nx">encodings</span> <span class="o">+</span> <span class="s2">&quot;], &quot;</span><span class="p">)</span> <span class="o">+</span>
                          <span class="p">(</span><span class="s2">&quot;fields: [&quot;</span> <span class="o">+</span> <span class="nx">fields</span> <span class="o">+</span> <span class="s2">&quot;], values: [&quot;</span> <span class="o">+</span> <span class="nx">values</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span> <span class="o">+</span>
                          <span class="p">(</span><span class="nx">bins</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="nx">bins</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;bin_&#39;</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: 1&quot;</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span>
                          <span class="s1">&#39;} : null&#39;</span><span class="p">,</span>
                      <span class="nx">force</span><span class="o">:</span> <span class="kc">true</span>
                  <span class="p">}]</span>
          <span class="p">}];</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">multi</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">predicate</span><span class="o">:</span> <span class="s1">&#39;vlMulti&#39;</span><span class="p">,</span>
      <span class="nx">scaleDomain</span><span class="o">:</span> <span class="s1">&#39;vlMultiDomain&#39;</span><span class="p">,</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="nx">signals</span><span class="p">,</span>
      <span class="nx">modifyExpr</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">tpl</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">tpl</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span>
              <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">?</span> <span class="s1">&#39;null&#39;</span> <span class="o">:</span> <span class="s2">&quot;{unit: &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">single</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">predicate</span><span class="o">:</span> <span class="s1">&#39;vlSingle&#39;</span><span class="p">,</span>
      <span class="nx">scaleDomain</span><span class="o">:</span> <span class="s1">&#39;vlSingleDomain&#39;</span><span class="p">,</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="nx">signals</span><span class="p">,</span>
      <span class="nx">topLevelSignals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals$$1</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">hasSignal</span> <span class="o">=</span> <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span> <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="s2">&quot;data(&quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">STORE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">values</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">+</span> <span class="s2">&quot;[0].values&quot;</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">hasSignal</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="nx">signals$$1</span> <span class="o">:</span> <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">concat</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
              <span class="nx">update</span><span class="o">:</span> <span class="nx">data</span> <span class="o">+</span> <span class="s2">&quot;.length &amp;&amp; {&quot;</span> <span class="o">+</span>
                  <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">values</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
          <span class="p">});</span>
      <span class="p">},</span>
      <span class="nx">modifyExpr</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">tpl</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">tpl</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span>
              <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">?</span> <span class="s1">&#39;true&#39;</span> <span class="o">:</span> <span class="s2">&quot;{unit: &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">inputBindings</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;single&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">&amp;&amp;</span>
              <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">bind</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">bind</span> <span class="o">!==</span> <span class="s1">&#39;scales&#39;</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">topLevelSignals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">proj</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">bind</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">bind</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">datum</span> <span class="o">=</span> <span class="nx">nearest</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="o">?</span>
              <span class="s1">&#39;(item().isVoronoi ? datum.datum : datum)&#39;</span> <span class="o">:</span> <span class="s1">&#39;datum&#39;</span><span class="p">;</span>
          <span class="nx">proj</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">sgname</span> <span class="o">=</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">hasSignal</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">sgname</span><span class="p">;</span> <span class="p">});</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasSignal</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">signals</span><span class="p">.</span><span class="nx">unshift</span><span class="p">({</span>
                      <span class="nx">name</span><span class="o">:</span> <span class="nx">sgname</span><span class="p">,</span>
                      <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                      <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                              <span class="nx">events</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">events</span><span class="p">,</span>
                              <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;datum &amp;&amp; item().mark.marktype !== &#39;group&#39; ? &quot;</span> <span class="o">+</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">datum</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; : null&quot;</span>
                          <span class="p">}],</span>
                      <span class="nx">bind</span><span class="o">:</span> <span class="nx">bind</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">||</span> <span class="nx">bind</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">]</span> <span class="o">||</span> <span class="nx">bind</span>
                  <span class="p">});</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">proj</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">;</span> <span class="p">})[</span><span class="mi">0</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="nx">proj</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">$</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">values</span> <span class="o">=</span> <span class="nx">proj</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span> <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="p">.</span><span class="nx">update</span> <span class="o">=</span> <span class="nx">values</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; ? {fields: [&quot;</span> <span class="o">+</span> <span class="nx">fields</span> <span class="o">+</span> <span class="s2">&quot;], values: [&quot;</span> <span class="o">+</span> <span class="nx">values</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]} : null&quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">delete</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
          <span class="k">delete</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">on</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">project</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">def</span> <span class="o">=</span> <span class="nx">selDef</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">def</span><span class="p">.</span><span class="nx">fields</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">def</span><span class="p">.</span><span class="nx">encodings</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">parse</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selDef</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channels</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">timeUnits</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="c1">// TODO: find a possible channel mapping for these fields.</span>
          <span class="p">(</span><span class="nx">selDef</span><span class="p">.</span><span class="nx">fields</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">channels</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="p">});</span>
          <span class="p">(</span><span class="nx">selDef</span><span class="p">.</span><span class="nx">encodings</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">tuField</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
                      <span class="nx">channels</span><span class="p">[</span><span class="nx">tuField</span><span class="p">]</span> <span class="o">=</span> <span class="nx">channel</span><span class="p">;</span>
                      <span class="c1">// Construct TimeUnitComponents which will be combined into a</span>
                      <span class="c1">// TimeUnitNode. This node may need to be inserted into the</span>
                      <span class="c1">// dataflow if the selection is used across views that do not</span>
                      <span class="c1">// have these time units defined.</span>
                      <span class="nx">timeUnits</span><span class="p">[</span><span class="nx">tuField</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                          <span class="nx">as</span><span class="o">:</span> <span class="nx">tuField</span><span class="p">,</span>
                          <span class="nx">field</span><span class="o">:</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                          <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span>
                      <span class="p">};</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">channels</span><span class="p">[</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="nx">channel</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">cannotProjectOnChannelWithoutField</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">projection</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span> <span class="o">||</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span> <span class="o">=</span> <span class="p">[]);</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">field</span> <span class="k">in</span> <span class="nx">channels</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channels</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">field</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">projection</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">channel</span><span class="o">:</span> <span class="nx">channels</span><span class="p">[</span><span class="nx">field</span><span class="p">]</span> <span class="p">});</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">fields</span> <span class="o">||</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">fields</span> <span class="o">=</span> <span class="p">{});</span>
          <span class="nx">projection</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">;</span> <span class="p">}).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fields</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">field</span><span class="p">;</span> <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">timeUnits</span><span class="p">).</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">timeUnit</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TimeUnitNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">timeUnits</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">TOGGLE</span> <span class="o">=</span> <span class="s1">&#39;_toggle&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">toggle</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;multi&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">toggle</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TOGGLE</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span> <span class="nx">events</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">events</span><span class="p">,</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">toggle</span> <span class="p">}]</span>
          <span class="p">});</span>
      <span class="p">},</span>
      <span class="nx">modifyExpr</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">tpl</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">TOGGLE</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot; ? null : &quot;</span> <span class="o">+</span> <span class="nx">tpl</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span>
              <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">?</span>
                  <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot; ? null : true, &quot;</span> <span class="o">:</span>
                  <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot; ? null : {unit: &quot;</span> <span class="o">+</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}, &quot;</span><span class="p">)</span> <span class="o">+</span>
              <span class="p">(</span><span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot; ? &quot;</span> <span class="o">+</span> <span class="nx">tpl</span> <span class="o">+</span> <span class="s2">&quot; : null&quot;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">ANCHOR</span> <span class="o">=</span> <span class="s1">&#39;_translate_anchor&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">DELTA</span> <span class="o">=</span> <span class="s1">&#39;_translate_delta&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">translate</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;interval&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">translate</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">hasScales</span> <span class="o">=</span> <span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">ANCHOR</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">positionalProjections</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">),</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">events</span> <span class="o">=</span> <span class="nx">parseSelector</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">translate</span><span class="p">,</span> <span class="s1">&#39;scope&#39;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasScales</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">events</span> <span class="o">=</span> <span class="nx">events</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">between</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">markname</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">BRUSH</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="nx">signals</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">anchor</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="p">{},</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">events</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">between</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="p">}),</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="s1">&#39;{x: x(unit), y: y(unit)&#39;</span> <span class="o">+</span>
                          <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="s1">&#39;, extent_x: &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hasScales</span> <span class="o">?</span> <span class="nx">domain$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">X</span><span class="p">)</span> <span class="o">:</span>
                              <span class="s2">&quot;slice(&quot;</span> <span class="o">+</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;visual&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span>
                          <span class="p">(</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="s1">&#39;, extent_y: &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hasScales</span> <span class="o">?</span> <span class="nx">domain$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">Y</span><span class="p">)</span> <span class="o">:</span>
                              <span class="s2">&quot;slice(&quot;</span> <span class="o">+</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;visual&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
                  <span class="p">}]</span>
          <span class="p">},</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">DELTA</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="p">{},</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">events</span><span class="p">,</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;{x: &quot;</span> <span class="o">+</span> <span class="nx">anchor</span> <span class="o">+</span> <span class="s2">&quot;.x - x(unit), y: &quot;</span> <span class="o">+</span> <span class="nx">anchor</span> <span class="o">+</span> <span class="s2">&quot;.y - y(unit)}&quot;</span>
                  <span class="p">}]</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">onDelta</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">X</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">signals</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">onDelta</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">Y</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">signals</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">onDelta</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">hasScales</span> <span class="o">=</span> <span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">hasScales</span> <span class="o">?</span> <span class="s1">&#39;data&#39;</span> <span class="o">:</span> <span class="s1">&#39;visual&#39;</span><span class="p">);</span>
      <span class="p">})[</span><span class="mi">0</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">ANCHOR</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">delta</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">DELTA</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">sizeSg</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="nx">size</span><span class="p">).</span><span class="nx">signal</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">scaleCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">sign</span> <span class="o">=</span> <span class="nx">hasScales</span> <span class="o">&amp;&amp;</span> <span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">?</span> <span class="s1">&#39;-&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> <span class="c1">// Invert delta when panning x-scales.</span>
      <span class="kd">var</span> <span class="nx">extent</span> <span class="o">=</span> <span class="nx">anchor</span> <span class="o">+</span> <span class="s2">&quot;.extent_&quot;</span> <span class="o">+</span> <span class="nx">channel</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">offset</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">sign</span> <span class="o">+</span> <span class="nx">delta</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">hasScales</span> <span class="o">?</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">sizeSg</span> <span class="o">:</span> <span class="s2">&quot;span(&quot;</span> <span class="o">+</span> <span class="nx">extent</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">panFn</span> <span class="o">=</span> <span class="o">!</span><span class="nx">hasScales</span> <span class="o">?</span> <span class="s1">&#39;panLinear&#39;</span> <span class="o">:</span>
          <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;log&#39;</span> <span class="o">?</span> <span class="s1">&#39;panLog&#39;</span> <span class="o">:</span>
              <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;pow&#39;</span> <span class="o">?</span> <span class="s1">&#39;panPow&#39;</span> <span class="o">:</span> <span class="s1">&#39;panLinear&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">panFn</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">extent</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">offset</span> <span class="o">+</span>
          <span class="p">(</span><span class="nx">hasScales</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;pow&#39;</span> <span class="o">?</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">scaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="nx">signal</span><span class="p">.</span><span class="nx">on</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="nx">events</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">delta</span> <span class="p">},</span>
          <span class="nx">update</span><span class="o">:</span> <span class="nx">hasScales</span> <span class="o">?</span> <span class="nx">update</span> <span class="o">:</span> <span class="s2">&quot;clampRange(&quot;</span> <span class="o">+</span> <span class="nx">update</span> <span class="o">+</span> <span class="s2">&quot;, 0, &quot;</span> <span class="o">+</span> <span class="nx">sizeSg</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">ANCHOR$1</span> <span class="o">=</span> <span class="s1">&#39;_zoom_anchor&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">DELTA$1</span> <span class="o">=</span> <span class="s1">&#39;_zoom_delta&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">zoom$1</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">has</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;interval&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">zoom</span><span class="p">;</span>
      <span class="p">},</span>
      <span class="nx">signals</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">hasScales</span> <span class="o">=</span> <span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">delta</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">DELTA$1</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">positionalProjections</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">),</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">sx</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">X</span><span class="p">));</span>
          <span class="kd">var</span> <span class="nx">sy</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">Y</span><span class="p">));</span>
          <span class="kd">var</span> <span class="nx">events</span> <span class="o">=</span> <span class="nx">parseSelector</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">zoom</span><span class="p">,</span> <span class="s1">&#39;scope&#39;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasScales</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">events</span> <span class="o">=</span> <span class="nx">events</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">markname</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">BRUSH</span><span class="p">,</span> <span class="nx">e</span><span class="p">);</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="nx">signals</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">ANCHOR$1</span><span class="p">,</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">events</span><span class="p">,</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="o">!</span><span class="nx">hasScales</span> <span class="o">?</span> <span class="s2">&quot;{x: x(unit), y: y(unit)}&quot;</span> <span class="o">:</span>
                          <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="p">[</span>
                              <span class="p">(</span><span class="nx">sx</span> <span class="o">?</span> <span class="s2">&quot;x: invert(&quot;</span> <span class="o">+</span> <span class="nx">sx</span> <span class="o">+</span> <span class="s2">&quot;, x(unit))&quot;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                              <span class="p">(</span><span class="nx">sy</span> <span class="o">?</span> <span class="s2">&quot;y: invert(&quot;</span> <span class="o">+</span> <span class="nx">sy</span> <span class="o">+</span> <span class="s2">&quot;, y(unit))&quot;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                          <span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">expr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="nx">expr</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span>
                  <span class="p">}]</span>
          <span class="p">},</span> <span class="p">{</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">delta</span><span class="p">,</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">events</span><span class="p">,</span>
                      <span class="nx">force</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="s1">&#39;pow(1.001, event.deltaY * pow(16, event.deltaMode))&#39;</span>
                  <span class="p">}]</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">onDelta$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">signals</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">onDelta$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">signals</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">signals</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">onDelta$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">hasScales</span> <span class="o">=</span> <span class="nx">scaleBindings</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">hasScales</span> <span class="o">?</span> <span class="s1">&#39;data&#39;</span> <span class="o">:</span> <span class="s1">&#39;visual&#39;</span><span class="p">);</span>
      <span class="p">})[</span><span class="mi">0</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">sizeSg</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="nx">size</span><span class="p">).</span><span class="nx">signal</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">scaleCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">base</span> <span class="o">=</span> <span class="nx">hasScales</span> <span class="o">?</span> <span class="nx">domain$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">:</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">delta</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">DELTA$1</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">ANCHOR$1</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nx">channel</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">zoomFn</span> <span class="o">=</span> <span class="o">!</span><span class="nx">hasScales</span> <span class="o">?</span> <span class="s1">&#39;zoomLinear&#39;</span> <span class="o">:</span>
          <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;log&#39;</span> <span class="o">?</span> <span class="s1">&#39;zoomLog&#39;</span> <span class="o">:</span>
              <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;pow&#39;</span> <span class="o">?</span> <span class="s1">&#39;zoomPow&#39;</span> <span class="o">:</span> <span class="s1">&#39;zoomLinear&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">zoomFn</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">base</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">anchor</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">delta</span> <span class="o">+</span>
          <span class="p">(</span><span class="nx">hasScales</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;pow&#39;</span> <span class="o">?</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">scaleCmpt</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="nx">signal</span><span class="p">.</span><span class="nx">on</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="nx">events</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">delta</span> <span class="p">},</span>
          <span class="nx">update</span><span class="o">:</span> <span class="nx">hasScales</span> <span class="o">?</span> <span class="nx">update</span> <span class="o">:</span> <span class="s2">&quot;clampRange(&quot;</span> <span class="o">+</span> <span class="nx">update</span> <span class="o">+</span> <span class="s2">&quot;, 0, &quot;</span> <span class="o">+</span> <span class="nx">sizeSg</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">compilers</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">project</span><span class="o">:</span> <span class="nx">project</span><span class="p">,</span> <span class="nx">toggle</span><span class="o">:</span> <span class="nx">toggle</span><span class="p">,</span> <span class="nx">scales</span><span class="o">:</span> <span class="nx">scaleBindings</span><span class="p">,</span>
      <span class="nx">translate</span><span class="o">:</span> <span class="nx">translate</span><span class="p">,</span> <span class="nx">zoom</span><span class="o">:</span> <span class="nx">zoom$1</span><span class="p">,</span> <span class="nx">inputs</span><span class="o">:</span> <span class="nx">inputBindings</span><span class="p">,</span> <span class="nx">nearest</span><span class="o">:</span> <span class="nx">nearest</span> <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">forEachTransform</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">t</span> <span class="k">in</span> <span class="nx">compilers</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">compilers</span><span class="p">[</span><span class="nx">t</span><span class="p">].</span><span class="nx">has</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">cb</span><span class="p">(</span><span class="nx">compilers</span><span class="p">[</span><span class="nx">t</span><span class="p">]);</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">STORE</span> <span class="o">=</span> <span class="s1">&#39;_store&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">TUPLE</span> <span class="o">=</span> <span class="s1">&#39;_tuple&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">MODIFY</span> <span class="o">=</span> <span class="s1">&#39;_modify&#39;</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">SELECTION_DOMAIN</span> <span class="o">=</span> <span class="s1">&#39;_selection_domain_&#39;</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">parseUnitSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selDefs</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">selCmpts</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">selectionConfig</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">selection</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name_1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">selDefs</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name_1</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s2">&quot;continue&quot;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">selDef</span> <span class="o">=</span> <span class="nx">selDefs</span><span class="p">[</span><span class="nx">name_1</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">cfg</span> <span class="o">=</span> <span class="nx">selectionConfig</span><span class="p">[</span><span class="nx">selDef</span><span class="p">.</span><span class="nx">type</span><span class="p">];</span>
          <span class="c1">// Set default values from config if a property hasn&#39;t been specified,</span>
          <span class="c1">// or if it is true. E.g., &quot;translate&quot;: true should use the default</span>
          <span class="c1">// event handlers for translate. However, true may be a valid value for</span>
          <span class="c1">// a property (e.g., &quot;nearest&quot;: true).</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key$$1</span> <span class="k">in</span> <span class="nx">cfg</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// A selection should contain either `encodings` or `fields`, only use</span>
              <span class="c1">// default values for these two values if neither of them is specified.</span>
              <span class="k">if</span> <span class="p">((</span><span class="nx">key$$1</span> <span class="o">===</span> <span class="s1">&#39;encodings&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selDef</span><span class="p">.</span><span class="nx">fields</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">key$$1</span> <span class="o">===</span> <span class="s1">&#39;fields&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">selDef</span><span class="p">.</span><span class="nx">encodings</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">key$$1</span> <span class="o">===</span> <span class="s1">&#39;mark&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">selDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">cfg</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">],</span> <span class="nx">selDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]);</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">selDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">selDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">selDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cfg</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">]</span> <span class="o">||</span> <span class="nx">selDef</span><span class="p">[</span><span class="nx">key$$1</span><span class="p">];</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">name_1</span> <span class="o">=</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">name_1</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">selCmpt</span> <span class="o">=</span> <span class="nx">selCmpts</span><span class="p">[</span><span class="nx">name_1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">selDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">name_1</span><span class="p">,</span> <span class="nx">events</span><span class="o">:</span> <span class="nx">isString</span><span class="p">(</span><span class="nx">selDef</span><span class="p">.</span><span class="nx">on</span><span class="p">)</span> <span class="o">?</span> <span class="nx">parseSelector</span><span class="p">(</span><span class="nx">selDef</span><span class="p">.</span><span class="nx">on</span><span class="p">,</span> <span class="s1">&#39;scope&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="nx">selDef</span><span class="p">.</span><span class="nx">on</span> <span class="p">});</span>
          <span class="nx">forEachTransform</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">.</span><span class="nx">parse</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">txCompiler</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selDef</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">name_1</span> <span class="k">in</span> <span class="nx">selDefs</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">name_1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">selCmpts</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleUnitSelectionSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">signals$$1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">forEachSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">selCompiler</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">modifyExpr</span> <span class="o">=</span> <span class="nx">selCompiler</span><span class="p">.</span><span class="nx">modifyExpr</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">);</span>
          <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">signals$$1</span><span class="p">,</span> <span class="nx">selCompiler</span><span class="p">.</span><span class="nx">signals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">));</span>
          <span class="nx">forEachTransform</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">.</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">signals$$1</span> <span class="o">=</span> <span class="nx">txCompiler</span><span class="p">.</span><span class="nx">signals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals$$1</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">.</span><span class="nx">modifyExpr</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">modifyExpr</span> <span class="o">=</span> <span class="nx">txCompiler</span><span class="p">.</span><span class="nx">modifyExpr</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">modifyExpr</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">MODIFY</span><span class="p">,</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">TUPLE</span> <span class="p">},</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;modify(&quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">STORE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">modifyExpr</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                  <span class="p">}]</span>
          <span class="p">});</span>
      <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">facetModel</span> <span class="o">=</span> <span class="nx">getFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">signals$$1</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">facetModel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">name_2</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">facetModel</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">));</span>
          <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">unshift</span><span class="p">({</span>
              <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;facet&#39;</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="p">{},</span>
              <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span>
                      <span class="nx">events</span><span class="o">:</span> <span class="nx">parseSelector</span><span class="p">(</span><span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="s1">&#39;scope&#39;</span><span class="p">),</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="s2">&quot;isTuple(facet) ? facet : group(&quot;</span> <span class="o">+</span> <span class="nx">name_2</span> <span class="o">+</span> <span class="s2">&quot;).datum&quot;</span>
                  <span class="p">}]</span>
          <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">signals$$1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleTopLevelSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">signals$$1</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">needsUnit</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="nx">forEachSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">selCompiler</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">selCompiler</span><span class="p">.</span><span class="nx">topLevelSignals</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">signals$$1</span> <span class="o">=</span> <span class="nx">selCompiler</span><span class="p">.</span><span class="nx">topLevelSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals$$1</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="nx">forEachTransform</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">.</span><span class="nx">topLevelSignals</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">signals$$1</span> <span class="o">=</span> <span class="nx">txCompiler</span><span class="p">.</span><span class="nx">topLevelSignals</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">signals$$1</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="nx">needsUnit</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">needsUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">hasUnit</span> <span class="o">=</span> <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s1">&#39;unit&#39;</span><span class="p">;</span> <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">hasUnit</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">signals$$1</span><span class="p">.</span><span class="nx">unshift</span><span class="p">({</span>
                  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span>
                  <span class="nx">value</span><span class="o">:</span> <span class="p">{},</span>
                  <span class="nx">on</span><span class="o">:</span> <span class="p">[{</span> <span class="nx">events</span><span class="o">:</span> <span class="s1">&#39;mousemove&#39;</span><span class="p">,</span> <span class="nx">update</span><span class="o">:</span> <span class="s1">&#39;isTuple(group()) ? group() : unit&#39;</span> <span class="p">}]</span>
              <span class="p">});</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">signals$$1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleUnitSelectionData</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">forEachSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">contains$$1</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">STORE</span><span class="p">;</span> <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">contains$$1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">STORE</span> <span class="p">});</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleUnitSelectionMarks</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">marks</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">forEachSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">selCompiler</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">marks</span> <span class="o">=</span> <span class="nx">selCompiler</span><span class="p">.</span><span class="nx">marks</span> <span class="o">?</span> <span class="nx">selCompiler</span><span class="p">.</span><span class="nx">marks</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">marks</span><span class="p">)</span> <span class="o">:</span> <span class="nx">marks</span><span class="p">;</span>
          <span class="nx">forEachTransform</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">txCompiler</span><span class="p">.</span><span class="nx">marks</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">marks</span> <span class="o">=</span> <span class="nx">txCompiler</span><span class="p">.</span><span class="nx">marks</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">marks</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">marks</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">assembleLayerSelectionMarks</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">marks</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">child</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">marks</span> <span class="o">=</span> <span class="nx">assembleUnitSelectionMarks</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">marks</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">marks</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">selectionPredicate</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">selections</span><span class="p">,</span> <span class="nx">dfnode</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">stores</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">function</span> <span class="nx">expr</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">vname</span> <span class="o">=</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">selCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSelectionComponent</span><span class="p">(</span><span class="nx">vname</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">vname</span> <span class="o">+</span> <span class="nx">STORE</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">dfnode</span> <span class="o">||</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">raw</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">tunode</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">tunode</span><span class="p">.</span><span class="nx">insertAsParentOf</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">tunode</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">empty</span> <span class="o">!==</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">stores</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">store</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">compiler</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span><span class="p">).</span><span class="nx">predicate</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">store</span> <span class="o">+</span> <span class="s2">&quot;, datum&quot;</span><span class="p">)</span> <span class="o">+</span>
              <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">?</span> <span class="s1">&#39;)&#39;</span> <span class="o">:</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">predicateStr</span> <span class="o">=</span> <span class="nx">logicalExpr</span><span class="p">(</span><span class="nx">selections</span><span class="p">,</span> <span class="nx">expr</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="nx">stores</span><span class="p">.</span><span class="nx">length</span>
          <span class="o">?</span> <span class="s1">&#39;!(&#39;</span> <span class="o">+</span> <span class="nx">stores</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">&quot;length(data(&quot;</span> <span class="o">+</span> <span class="nx">s</span> <span class="o">+</span> <span class="s2">&quot;))&quot;</span><span class="p">;</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; || &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;) || &#39;</span>
          <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">predicateStr</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Selections are parsed _after_ scales. If a scale domain is set to</span>
  <span class="c1">// use a selection, the SELECTION_DOMAIN constant is used as the</span>
  <span class="c1">// domainRaw.signal during scale.parse and then replaced with the necessary</span>
  <span class="c1">// selection expression function during scale.assemble. To not pollute the</span>
  <span class="c1">// type signatures to account for this setup, the selection domain definition</span>
  <span class="c1">// is coerced to a string and appended to SELECTION_DOMAIN.</span>
  <span class="kd">function</span> <span class="nx">isRawSelectionDomain</span><span class="p">(</span><span class="nx">domainRaw</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">domainRaw</span><span class="p">.</span><span class="nx">signal</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">SELECTION_DOMAIN</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">selectionScaleDomain</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">domainRaw</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">selDomain</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">domainRaw</span><span class="p">.</span><span class="nx">signal</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">SELECTION_DOMAIN</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">));</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">selDomain</span><span class="p">.</span><span class="nx">selection</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">selCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Use &quot;bind&quot;: &quot;scales&quot; to setup a binding for scales and selections within the same view.&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">selCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSelectionComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">selDomain</span><span class="p">.</span><span class="nx">selection</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">selDomain</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">selDomain</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">selDomain</span><span class="p">.</span><span class="nx">field</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">field</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;A &quot;field&quot; or &quot;encoding&quot; must be specified when using a selection as a scale domain. &#39;</span> <span class="o">+</span>
                      <span class="p">(</span><span class="s2">&quot;Using \&quot;field\&quot;: &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selDomain</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">signal</span><span class="o">:</span> <span class="nx">compiler</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">type</span><span class="p">).</span><span class="nx">scaleDomain</span> <span class="o">+</span>
                  <span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="nx">STORE</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selDomain</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">||</span> <span class="kc">null</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="p">)</span> <span class="o">+</span>
                  <span class="nx">$</span><span class="p">(</span><span class="nx">selDomain</span><span class="p">.</span><span class="nx">field</span> <span class="o">||</span> <span class="kc">null</span><span class="p">)</span> <span class="o">+</span>
                  <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">===</span> <span class="s1">&#39;global&#39;</span> <span class="o">?</span> <span class="s1">&#39;)&#39;</span> <span class="o">:</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nx">$</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s1">&#39;null&#39;</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="c1">// Utility functions</span>
  <span class="kd">function</span> <span class="nx">forEachSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">selections</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">name_3</span> <span class="k">in</span> <span class="nx">selections</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">selections</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name_3</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">sel</span> <span class="o">=</span> <span class="nx">selections</span><span class="p">[</span><span class="nx">name_3</span><span class="p">];</span>
              <span class="nx">cb</span><span class="p">(</span><span class="nx">sel</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">(</span><span class="nx">sel</span><span class="p">.</span><span class="nx">type</span><span class="p">));</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">compiler</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;single&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">single</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;multi&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">multi</span><span class="p">;</span>
          <span class="k">case</span> <span class="s1">&#39;interval&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">interval</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">parent</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">unitName</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">facet</span> <span class="o">=</span> <span class="nx">getFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">facet</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">name</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">row</span> <span class="o">?</span> <span class="s2">&quot; + &#39;_&#39; + (&quot;</span> <span class="o">+</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="s1">&#39;row&#39;</span><span class="p">),</span> <span class="s1">&#39;facet&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
              <span class="o">+</span> <span class="p">(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">column</span> <span class="o">?</span> <span class="s2">&quot; + &#39;_&#39; + (&quot;</span> <span class="o">+</span> <span class="nx">accessPathWithDatum</span><span class="p">(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">),</span> <span class="s1">&#39;facet&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">requiresSelectionId</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">identifier</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="nx">forEachSelection</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">identifier</span> <span class="o">=</span> <span class="nx">identifier</span> <span class="o">||</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">proj</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">proj</span><span class="p">.</span><span class="nx">field</span> <span class="o">===</span> <span class="nx">SELECTION_ID</span><span class="p">;</span> <span class="p">});</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">identifier</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">channelSignalName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">range</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">sgNames</span> <span class="o">=</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">_signalNames</span> <span class="o">||</span> <span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">_signalNames</span> <span class="o">=</span> <span class="p">{});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">sgNames</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">sgNames</span><span class="p">[</span><span class="nx">channel</span><span class="p">][</span><span class="nx">range</span><span class="p">])</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">sgNames</span><span class="p">[</span><span class="nx">channel</span><span class="p">][</span><span class="nx">range</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="nx">sgNames</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sgNames</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">basename</span> <span class="o">=</span> <span class="nx">varName</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">range</span> <span class="o">===</span> <span class="s1">&#39;visual&#39;</span> <span class="o">?</span> <span class="nx">channel</span> <span class="o">:</span> <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">fields</span><span class="p">[</span><span class="nx">channel</span><span class="p">]));</span>
      <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">basename</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">sgNames</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">name</span> <span class="o">=</span> <span class="nx">basename</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">(</span><span class="nx">sgNames</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sgNames</span><span class="p">[</span><span class="nx">channel</span><span class="p">][</span><span class="nx">range</span><span class="p">]</span> <span class="o">=</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">positionalProjections</span><span class="p">(</span><span class="nx">selCmpt</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">xi</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">yi</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="nx">selCmpt</span><span class="p">.</span><span class="nx">project</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">x</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
              <span class="nx">xi</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">Y</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">y</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
              <span class="nx">yi</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">xi</span><span class="o">:</span> <span class="nx">xi</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">yi</span><span class="o">:</span> <span class="nx">yi</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isSelectionPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldEqualPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">equal</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldLTPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">lt</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldLTEPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">lte</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldGTPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">gt</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldGTEPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">gte</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldRangePredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">range</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">range</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldOneOfPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">predicate</span> <span class="o">&amp;&amp;</span> <span class="o">!!</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">oneOf</span><span class="p">)</span> <span class="o">||</span>
          <span class="nx">isArray</span><span class="p">(</span><span class="nx">predicate</span><span class="p">.</span><span class="k">in</span><span class="p">)</span> <span class="c1">// backward compatibility</span>
      <span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isFieldPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isFieldOneOfPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldEqualPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldRangePredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldLTPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldGTPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldLTEPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldGTEPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Converts a predicate into an expression.</span>
<span class="cm">   */</span>
  <span class="c1">// model is only used for selection filters.</span>
  <span class="kd">function</span> <span class="nx">expression</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">filterOp</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">logicalExpr</span><span class="p">(</span><span class="nx">filterOp</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isString</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">predicate</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isSelectionPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">selectionPredicate</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">selection</span><span class="p">,</span> <span class="nx">node</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span> <span class="c1">// Filter Object</span>
              <span class="k">return</span> <span class="nx">fieldFilterExpression</span><span class="p">(</span><span class="nx">predicate</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="c1">// This method is used by Voyager.  Do not change its behavior without changing Voyager.</span>
  <span class="kd">function</span> <span class="nx">fieldFilterExpression</span><span class="p">(</span><span class="nx">predicate</span><span class="p">,</span> <span class="nx">useInRange</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">useInRange</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">useInRange</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">fieldExpr$$1</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span> <span class="o">?</span>
          <span class="c1">// For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.</span>
          <span class="c1">// TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline</span>
          <span class="c1">// TODO: support utc</span>
          <span class="p">(</span><span class="s1">&#39;time(&#39;</span> <span class="o">+</span> <span class="nx">fieldExpr</span><span class="p">(</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">field</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span> <span class="o">:</span>
          <span class="nx">vgField</span><span class="p">(</span><span class="nx">predicate</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldEqualPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s1">&#39;===&#39;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">predicate</span><span class="p">.</span><span class="nx">equal</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldLTPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">upper</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">lt</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">upper</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldGTPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">lower</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">gt</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">lower</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldLTEPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">upper</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">lte</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s2">&quot;&lt;=&quot;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">upper</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldGTEPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">lower</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">gte</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s2">&quot;&gt;=&quot;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">lower</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldOneOfPredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// &quot;oneOf&quot; was formerly &quot;in&quot; -- so we need to add backward compatibility</span>
          <span class="kd">var</span> <span class="nx">oneOf</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">oneOf</span> <span class="o">||</span> <span class="nx">predicate</span><span class="p">[</span><span class="s1">&#39;in&#39;</span><span class="p">];</span>
          <span class="k">return</span> <span class="s1">&#39;indexof([&#39;</span> <span class="o">+</span>
              <span class="nx">oneOf</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">);</span> <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span>
              <span class="s1">&#39;], &#39;</span> <span class="o">+</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s1">&#39;) !== -1&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldRangePredicate</span><span class="p">(</span><span class="nx">predicate</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">lower</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">range</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">upper</span> <span class="o">=</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">range</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">lower</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">upper</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">useInRange</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;inrange(&#39;</span> <span class="o">+</span> <span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s1">&#39;, [&#39;</span> <span class="o">+</span>
                  <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">lower</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span>
                  <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">upper</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;])&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">exprs</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">lower</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">exprs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s2">&quot; &gt;= &quot;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">lower</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">upper</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">exprs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fieldExpr$$1</span> <span class="o">+</span> <span class="s2">&quot; &lt;= &quot;</span> <span class="o">+</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">upper</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">exprs</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">exprs</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &amp;&amp; &#39;</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;true&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: it should never reach here */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Invalid field predicate: &quot;</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">predicate</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isDateTime</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="k">return</span> <span class="s1">&#39;time(&#39;</span> <span class="o">+</span> <span class="nx">expr</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLocalSingleTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">datetime</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">datetime</span><span class="p">[</span><span class="nx">timeUnit</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">datetime</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
          <span class="k">return</span> <span class="s1">&#39;time(&#39;</span> <span class="o">+</span> <span class="nx">expr</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isUtcSingleTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">valueExpr</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">getLocalTimeUnit</span><span class="p">(</span><span class="nx">timeUnit</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizePredicate</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldPredicate</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">f</span><span class="p">,</span> <span class="p">{</span> <span class="nx">timeUnit</span><span class="o">:</span> <span class="nx">normalizeTimeUnit</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">)</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">f</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">isFilter</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isLookup</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;lookup&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isWindow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;window&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isCalculate</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;calculate&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isBin</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!!</span><span class="nx">t</span><span class="p">[</span><span class="s1">&#39;bin&#39;</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isTimeUnit$1</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;timeUnit&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isAggregate$1</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;aggregate&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isStack</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">t</span><span class="p">[</span><span class="s1">&#39;stack&#39;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">normalizeTransform</span><span class="p">(</span><span class="nx">transform</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">transform</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFilter</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">filter</span><span class="o">:</span> <span class="nx">normalizeLogicalOperand</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">normalizePredicate</span><span class="p">)</span>
              <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">t</span><span class="p">;</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">transform</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">isFilter</span><span class="o">:</span> <span class="nx">isFilter</span><span class="p">,</span>
    <span class="nx">isLookup</span><span class="o">:</span> <span class="nx">isLookup</span><span class="p">,</span>
    <span class="nx">isWindow</span><span class="o">:</span> <span class="nx">isWindow</span><span class="p">,</span>
    <span class="nx">isCalculate</span><span class="o">:</span> <span class="nx">isCalculate</span><span class="p">,</span>
    <span class="nx">isBin</span><span class="o">:</span> <span class="nx">isBin</span><span class="p">,</span>
    <span class="nx">isTimeUnit</span><span class="o">:</span> <span class="nx">isTimeUnit$1</span><span class="p">,</span>
    <span class="nx">isAggregate</span><span class="o">:</span> <span class="nx">isAggregate$1</span><span class="p">,</span>
    <span class="nx">isStack</span><span class="o">:</span> <span class="nx">isStack</span><span class="p">,</span>
    <span class="nx">normalizeTransform</span><span class="o">:</span> <span class="nx">normalizeTransform</span>
  <span class="p">});</span>

  <span class="kd">function</span> <span class="nx">rangeFormula</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">binRequiresRange</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// read format from axis or legend, if there is no format then use config.numberFormat</span>
          <span class="kd">var</span> <span class="nx">guide</span> <span class="o">=</span> <span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">axis</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">||</span> <span class="nx">model</span><span class="p">.</span><span class="nx">legend</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">||</span> <span class="p">{})</span> <span class="o">:</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">startField</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span><span class="p">,</span> <span class="p">});</span>
          <span class="kd">var</span> <span class="nx">endField</span> <span class="o">=</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span><span class="p">,</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">});</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">formulaAs</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;range&#39;</span> <span class="p">}),</span>
              <span class="nx">formula</span><span class="o">:</span> <span class="nx">binFormatExpression</span><span class="p">(</span><span class="nx">startField</span><span class="p">,</span> <span class="nx">endField</span><span class="p">,</span> <span class="nx">guide</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">binKey</span><span class="p">(</span><span class="nx">bin</span><span class="p">,</span> <span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">binToString</span><span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">field</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getSignalsFromModel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">signal</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s2">&quot;_bins&quot;</span><span class="p">),</span>
          <span class="nx">extentSignal</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">key</span> <span class="o">+</span> <span class="s2">&quot;_extent&quot;</span><span class="p">)</span>
      <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">isBinTransform</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s1">&#39;as&#39;</span> <span class="k">in</span> <span class="nx">t</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">createBinComponent</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">as</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isBinTransform</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">as</span> <span class="o">=</span> <span class="p">[</span><span class="nx">t</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">as</span> <span class="o">+</span> <span class="s2">&quot;_end&quot;</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="nx">as</span> <span class="o">=</span> <span class="p">[</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">{}),</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">{</span> <span class="nx">binSuffix</span><span class="o">:</span> <span class="s1">&#39;end&#39;</span> <span class="p">})];</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">bin</span> <span class="o">=</span> <span class="nx">normalizeBin</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bin</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span> <span class="o">||</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">binKey</span><span class="p">(</span><span class="nx">bin</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">getSignalsFromModel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">key</span><span class="p">),</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">signal</span><span class="p">,</span> <span class="nx">extentSignal</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">extentSignal</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">binComponent</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">bin</span><span class="o">:</span> <span class="nx">bin</span><span class="p">,</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">as</span><span class="o">:</span> <span class="nx">as</span> <span class="p">},</span> <span class="nx">signal</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">signal</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{},</span> <span class="nx">extentSignal</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">extentSignal</span><span class="o">:</span> <span class="nx">extentSignal</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{});</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">binComponent</span><span class="o">:</span> <span class="nx">binComponent</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">BinNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">BinNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">BinNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">bins</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">bins</span> <span class="o">=</span> <span class="nx">bins</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">BinNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">bins</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">bins</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">reduceFieldDef</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">binComponentIndex</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">createBinComponent</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">model</span><span class="p">),</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">binComponent</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">binComponent</span><span class="p">;</span>
                  <span class="nx">binComponentIndex</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">binComponent</span><span class="p">,</span> <span class="nx">binComponentIndex</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">rangeFormula</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">binComponentIndex</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">bins</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">BinNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">bins</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Creates a bin node from BinTransform.</span>
<span class="cm">       * The optional parameter should provide</span>
<span class="cm">       */</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">makeFromTransform</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">createBinComponent</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">model</span><span class="p">),</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">binComponent</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">binComponent</span><span class="p">;</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">BinNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="p">(</span><span class="nx">_b</span> <span class="o">=</span> <span class="p">{},</span>
              <span class="nx">_b</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">binComponent</span><span class="p">,</span>
              <span class="nx">_b</span><span class="p">));</span>
          <span class="kd">var</span> <span class="nx">_b</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">other</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">bins</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">bins</span><span class="p">,</span> <span class="nx">other</span><span class="p">.</span><span class="nx">bins</span><span class="p">);</span>
          <span class="nx">other</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">vals</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">bins</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">c</span><span class="p">.</span><span class="nx">as</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">out</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">dependentFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">vals</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">bins</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">out</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">BinNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">flatten</span><span class="p">(</span><span class="nx">vals</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">bins</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">transform</span> <span class="o">=</span> <span class="p">[];</span>
              <span class="kd">var</span> <span class="nx">binTrans</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;bin&#39;</span><span class="p">,</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">as</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">signal</span> <span class="p">},</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">bin</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">bin</span><span class="p">.</span><span class="nx">bin</span><span class="p">.</span><span class="nx">extent</span> <span class="o">&amp;&amp;</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">extentSignal</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;extent&#39;</span><span class="p">,</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span>
                      <span class="nx">signal</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">extentSignal</span>
                  <span class="p">});</span>
                  <span class="nx">binTrans</span><span class="p">.</span><span class="nx">extent</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">extentSignal</span> <span class="p">};</span>
              <span class="p">}</span>
              <span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">binTrans</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">bin</span><span class="p">.</span><span class="nx">formula</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;formula&#39;</span><span class="p">,</span>
                      <span class="nx">expr</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">formula</span><span class="p">,</span>
                      <span class="nx">as</span><span class="o">:</span> <span class="nx">bin</span><span class="p">.</span><span class="nx">formulaAs</span>
                  <span class="p">});</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">transform</span><span class="p">;</span>
          <span class="p">}));</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">BinNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">FilterNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">FilterNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">FilterNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">filter</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">filter</span> <span class="o">=</span> <span class="nx">filter</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">expr</span> <span class="o">=</span> <span class="nx">expression</span><span class="p">(</span><span class="nx">_this</span><span class="p">.</span><span class="nx">model</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">_this</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">FilterNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">FilterNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">filter</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">FilterNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;filter&#39;</span><span class="p">,</span>
              <span class="nx">expr</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">expr</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">FilterNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">GeoJSONNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">GeoJSONNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">GeoJSONNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">fields</span><span class="p">,</span> <span class="nx">geojson</span><span class="p">,</span> <span class="nx">signal</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">fields</span> <span class="o">=</span> <span class="nx">fields</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">geojson</span> <span class="o">=</span> <span class="nx">geojson</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">signal</span> <span class="o">=</span> <span class="nx">signal</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">GeoJSONNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">GeoJSONNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">fields</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">geojson</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">signal</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">GeoJSONNode</span><span class="p">.</span><span class="nx">parseAll</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">geoJsonCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="p">[[</span><span class="nx">LONGITUDE</span><span class="p">,</span> <span class="nx">LATITUDE</span><span class="p">],</span> <span class="p">[</span><span class="nx">LONGITUDE2</span><span class="p">,</span> <span class="nx">LATITUDE2</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">coordinates</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">pair</span> <span class="o">=</span> <span class="nx">coordinates</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">field</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span> <span class="p">});</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                  <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GeoJSONNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">pair</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s2">&quot;geojson_&quot;</span> <span class="o">+</span> <span class="nx">geoJsonCounter</span><span class="o">++</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">SHAPE</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">SHAPE</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">GEOJSON</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GeoJSONNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s2">&quot;geojson_&quot;</span> <span class="o">+</span> <span class="nx">geoJsonCounter</span><span class="o">++</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">GeoJSONNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;geojson&#39;</span> <span class="p">},</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">fields</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">fields</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">fields</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">geojson</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">geojson</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">geojson</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">signal</span> <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">GeoJSONNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">GeoPointNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">GeoPointNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">GeoPointNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">projection</span><span class="p">,</span> <span class="nx">fields</span><span class="p">,</span> <span class="nx">as</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">projection</span> <span class="o">=</span> <span class="nx">projection</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">fields</span> <span class="o">=</span> <span class="nx">fields</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">as</span> <span class="o">=</span> <span class="nx">as</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">GeoPointNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">GeoPointNode</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">fields</span><span class="p">),</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">as</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">GeoPointNode</span><span class="p">.</span><span class="nx">parseAll</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">projectionName</span><span class="p">())</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="p">[[</span><span class="nx">LONGITUDE</span><span class="p">,</span> <span class="nx">LATITUDE</span><span class="p">],</span> <span class="p">[</span><span class="nx">LONGITUDE2</span><span class="p">,</span> <span class="nx">LATITUDE2</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">coordinates</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">pair</span> <span class="o">=</span> <span class="nx">coordinates</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">field</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span> <span class="p">});</span>
              <span class="kd">var</span> <span class="nx">suffix</span> <span class="o">=</span> <span class="nx">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="nx">LONGITUDE2</span> <span class="o">?</span> <span class="s1">&#39;2&#39;</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                  <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GeoPointNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">projectionName</span><span class="p">(),</span> <span class="nx">pair</span><span class="p">,</span> <span class="p">[</span><span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;x&#39;</span> <span class="o">+</span> <span class="nx">suffix</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;y&#39;</span> <span class="o">+</span> <span class="nx">suffix</span><span class="p">)]);</span>
              <span class="p">}</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">GeoPointNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;geopoint&#39;</span><span class="p">,</span>
              <span class="nx">projection</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">projection</span><span class="p">,</span>
              <span class="nx">fields</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">fields</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">as</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">GeoPointNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">IdentifierNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">IdentifierNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">IdentifierNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">IdentifierNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">IdentifierNode</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">IdentifierNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">SELECTION_ID</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">_a</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">IdentifierNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;identifier&#39;</span><span class="p">,</span> <span class="nx">as</span><span class="o">:</span> <span class="nx">SELECTION_ID</span> <span class="p">};</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">IdentifierNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="cm">/**</span>
<span class="cm">   * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)</span>
<span class="cm">   * about how fields have been parsed or whether they have been derived in a transforms. We use this to not parse the</span>
<span class="cm">   * same field again (or differently).</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">AncestorParse</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">AncestorParse</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">AncestorParse</span><span class="p">(</span><span class="nx">explicit</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">,</span> <span class="nx">parseNothing</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">explicit</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">explicit</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">implicit</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">implicit</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parseNothing</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">parseNothing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">=</span> <span class="nx">explicit</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">implicit</span> <span class="o">=</span> <span class="nx">implicit</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">parseNothing</span> <span class="o">=</span> <span class="nx">parseNothing</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">AncestorParse</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="nx">clone</span><span class="p">.</span><span class="nx">parseNothing</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">parseNothing</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">AncestorParse</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Split</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">LookupNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">LookupNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">LookupNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">secondary</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">secondary</span> <span class="o">=</span> <span class="nx">secondary</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">LookupNode</span><span class="p">.</span><span class="nx">make</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">counter</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">sources</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">sources</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SourceNode</span><span class="p">(</span><span class="nx">transform</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">fromSource</span> <span class="o">=</span> <span class="nx">sources</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">hash</span><span class="p">()];</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fromSource</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">sources</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">hash</span><span class="p">()]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
              <span class="nx">fromSource</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">fromOutputName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s2">&quot;lookup_&quot;</span> <span class="o">+</span> <span class="nx">counter</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">fromOutputNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OutputNode</span><span class="p">(</span><span class="nx">fromSource</span><span class="p">,</span> <span class="nx">fromOutputName</span><span class="p">,</span> <span class="s1">&#39;lookup&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodeRefCounts</span><span class="p">);</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">outputNodes</span><span class="p">[</span><span class="nx">fromOutputName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fromOutputNode</span><span class="p">;</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">LookupNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">transform</span><span class="p">,</span> <span class="nx">fromOutputNode</span><span class="p">.</span><span class="nx">getSource</span><span class="p">());</span>
      <span class="p">};</span>
      <span class="nx">LookupNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">toSet</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">fields</span> <span class="o">||</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">)</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span> <span class="o">:</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span><span class="p">]));</span>
      <span class="p">};</span>
      <span class="nx">LookupNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">foreign</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">fields</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// lookup a few fields and add create a flat output</span>
              <span class="nx">foreign</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">values</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">fields</span> <span class="p">},</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">as</span><span class="o">:</span> <span class="p">((</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">)</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span> <span class="o">:</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span><span class="p">])</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{});</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// lookup full record and nest it</span>
              <span class="kd">var</span> <span class="nx">asName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">as</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isString</span><span class="p">(</span><span class="nx">asName</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">NO_FIELDS_NEEDS_AS</span><span class="p">);</span>
                  <span class="nx">asName</span> <span class="o">=</span> <span class="s1">&#39;_lookup&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="nx">foreign</span> <span class="o">=</span> <span class="p">{</span>
                  <span class="nx">as</span><span class="o">:</span> <span class="p">[</span><span class="nx">asName</span><span class="p">]</span>
              <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;lookup&#39;</span><span class="p">,</span> <span class="nx">from</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">secondary</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">from</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fields</span><span class="o">:</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">lookup</span><span class="p">]</span> <span class="p">},</span> <span class="nx">foreign</span><span class="p">,</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="k">default</span> <span class="o">?</span> <span class="p">{</span> <span class="k">default</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="k">default</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">LookupNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="cm">/**</span>
<span class="cm">   * A class for the window transform nodes</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">WindowTransformNode</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">WindowTransformNode</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">WindowTransformNode</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">transform</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">WindowTransformNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">WindowTransformNode</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">WindowTransformNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">producedFields</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">windowFieldDef</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">out</span><span class="p">[</span><span class="nx">_this</span><span class="p">.</span><span class="nx">getDefaultName</span><span class="p">(</span><span class="nx">windowFieldDef</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">WindowTransformNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getDefaultName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">windowFieldDef</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">windowFieldDef</span><span class="p">.</span><span class="nx">as</span> <span class="o">||</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">windowFieldDef</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">WindowTransformNode</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assemble</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">ops</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">as</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">params</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nb">window</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">window_1</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">ops</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">window_1</span><span class="p">.</span><span class="nx">op</span><span class="p">);</span>
              <span class="nx">as</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getDefaultName</span><span class="p">(</span><span class="nx">window_1</span><span class="p">));</span>
              <span class="nx">params</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">window_1</span><span class="p">.</span><span class="nx">param</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">window_1</span><span class="p">.</span><span class="nx">param</span><span class="p">);</span>
              <span class="nx">fields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">window_1</span><span class="p">.</span><span class="nx">field</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">window_1</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">frame</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">frame</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">groupby</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">groupby</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">sortFields</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">sortOrder</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">sort</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">sort</span><span class="p">;</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">sortField</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
                  <span class="nx">sortFields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sortField</span><span class="p">.</span><span class="nx">field</span><span class="p">);</span>
                  <span class="nx">sortOrder</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sortField</span><span class="p">.</span><span class="nx">order</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">sortField</span><span class="p">.</span><span class="nx">order</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">field</span><span class="o">:</span> <span class="nx">sortFields</span><span class="p">,</span>
              <span class="nx">order</span><span class="o">:</span> <span class="nx">sortOrder</span><span class="p">,</span>
          <span class="p">};</span>
          <span class="kd">var</span> <span class="nx">ignorePeers</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">ignorePeers</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;window&#39;</span><span class="p">,</span>
              <span class="nx">params</span><span class="o">:</span> <span class="nx">params</span><span class="p">,</span>
              <span class="nx">as</span><span class="o">:</span> <span class="nx">as</span><span class="p">,</span>
              <span class="nx">ops</span><span class="o">:</span> <span class="nx">ops</span><span class="p">,</span>
              <span class="nx">fields</span><span class="o">:</span> <span class="nx">fields</span><span class="p">,</span>
              <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span><span class="p">,</span>
          <span class="p">};</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">ignorePeers</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">result</span><span class="p">.</span><span class="nx">ignorePeers</span> <span class="o">=</span> <span class="nx">ignorePeers</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">groupby</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">result</span><span class="p">.</span><span class="nx">groupby</span> <span class="o">=</span> <span class="nx">groupby</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">frame</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">result</span><span class="p">.</span><span class="nx">frame</span> <span class="o">=</span> <span class="nx">frame</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">WindowTransformNode</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">DataFlowNode</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">parseRoot</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">sources</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">data</span> <span class="o">||</span> <span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// if the model defines a data source or is the root, create a source node</span>
          <span class="kd">var</span> <span class="nx">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SourceNode</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">hash$$1</span> <span class="o">=</span> <span class="nx">source</span><span class="p">.</span><span class="nx">hash</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hash$$1</span> <span class="k">in</span> <span class="nx">sources</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// use a reference if we already have a source</span>
              <span class="k">return</span> <span class="nx">sources</span><span class="p">[</span><span class="nx">hash$$1</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// otherwise add a new one</span>
              <span class="nx">sources</span><span class="p">[</span><span class="nx">hash$$1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">source</span><span class="p">;</span>
              <span class="k">return</span> <span class="nx">source</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// If we don&#39;t have a source defined (overriding parent&#39;s data), use the parent&#39;s facet root or main.</span>
          <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">facetRoot</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">facetRoot</span> <span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">main</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Parses a transforms array into a chain of connected dataflow nodes.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">parseTransformArray</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">lookupCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">model</span><span class="p">.</span><span class="nx">transforms</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isCalculate</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CalculateNode</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span>
              <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span> <span class="s1">&#39;derived&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFilter</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeImplicitFromFilterTransform</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FilterNode</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">filter</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isBin</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="nx">BinNode</span><span class="p">.</span><span class="nx">makeFromTransform</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
              <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isTimeUnit$1</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">makeFromTransform</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span>
              <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">as</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isAggregate$1</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">agg</span> <span class="o">=</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">makeFromTransform</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">requiresSelectionId</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IdentifierNode</span><span class="p">(</span><span class="nx">head</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">agg</span><span class="p">.</span><span class="nx">producedFields</span><span class="p">());</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                  <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="s1">&#39;derived&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isLookup</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">lookup</span> <span class="o">=</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">LookupNode</span><span class="p">.</span><span class="nx">make</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">lookupCounter</span><span class="o">++</span><span class="p">);</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">lookup</span><span class="p">.</span><span class="nx">producedFields</span><span class="p">());</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
                  <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="s1">&#39;derived&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isWindow</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">window_1</span> <span class="o">=</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WindowTransformNode</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_e</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">window_1</span><span class="p">.</span><span class="nx">producedFields</span><span class="p">());</span> <span class="nx">_d</span> <span class="o">&lt;</span> <span class="nx">_e</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">_e</span><span class="p">[</span><span class="nx">_d</span><span class="p">];</span>
                  <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="s1">&#39;derived&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isStack</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">StackNode</span><span class="p">.</span><span class="nx">makeFromTransform</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">t</span><span class="p">);</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_g</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">producedFields</span><span class="p">());</span> <span class="nx">_f</span> <span class="o">&lt;</span> <span class="nx">_g</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">_g</span><span class="p">[</span><span class="nx">_f</span><span class="p">];</span>
                  <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">field</span><span class="p">,</span> <span class="s1">&#39;derived&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">invalidTransformIgnored</span><span class="p">(</span><span class="nx">t</span><span class="p">));</span>
              <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="k">return</span> <span class="nx">head</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*</span>
<span class="cm">  Description of the dataflow (http://asciiflow.com/):</span>
<span class="cm">       +--------+</span>
<span class="cm">       | Source |</span>
<span class="cm">       +---+----+</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">       FormatParse</span>
<span class="cm">       (explicit)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">       Transforms</span>
<span class="cm">  (Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">       FormatParse</span>
<span class="cm">       (implicit)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">   Binning (in `encoding`)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">   Timeunit (in `encoding`)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">  Formula From Sort Array</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">        +--+--+</span>
<span class="cm">        | Raw |</span>
<span class="cm">        +-----+</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">    Aggregate (in `encoding`)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">    Stack (in `encoding`)</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">    Invalid Filter</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">     +----------+</span>
<span class="cm">     |   Main   |</span>
<span class="cm">     +----------+</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">       +-------+</span>
<span class="cm">       | Facet |----&gt; &quot;column&quot;, &quot;column-layout&quot;, and &quot;row&quot;</span>
<span class="cm">       +-------+</span>
<span class="cm">           |</span>
<span class="cm">           v</span>
<span class="cm">    ...Child data...</span>
<span class="cm">  */</span>
  <span class="kd">function</span> <span class="nx">parseData</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nx">parseRoot</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">sources</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">outputNodes</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">outputNodes</span><span class="p">,</span> <span class="nx">outputNodeRefCounts</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">outputNodeRefCounts</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">ancestorParse</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">clone</span><span class="p">()</span> <span class="o">:</span> <span class="k">new</span> <span class="nx">AncestorParse</span><span class="p">();</span>
      <span class="c1">// format.parse: null means disable parsing</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">data</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">format</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">format</span><span class="p">.</span><span class="nx">parse</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">ancestorParse</span><span class="p">.</span><span class="nx">parseNothing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">head</span> <span class="o">=</span> <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeExplicit</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
      <span class="c1">// Default discrete selections require an identifier transform to</span>
      <span class="c1">// uniquely identify data points as the _id field is volatile. Add</span>
      <span class="c1">// this transform at the head of our pipeline such that the identifier</span>
      <span class="c1">// field is available for all subsequent datasets. Additional identifier</span>
      <span class="c1">// transforms will be necessary when new tuples are constructed</span>
      <span class="c1">// (e.g., post-aggregation).</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">requiresSelectionId</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isLayerModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)))</span> <span class="p">{</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IdentifierNode</span><span class="p">(</span><span class="nx">head</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// HACK: This is equivalent for merging bin extent for union scale.</span>
      <span class="c1">// FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale</span>
      <span class="kd">var</span> <span class="nx">parentIsLayer</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">parent</span> <span class="o">&amp;&amp;</span> <span class="nx">isLayerModel</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">parent</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parentIsLayer</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="nx">BinNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">transforms</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">parseTransformArray</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">head</span> <span class="o">=</span> <span class="nx">ParseNode</span><span class="p">.</span><span class="nx">makeImplicitFromEncoding</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">ancestorParse</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">GeoJSONNode</span><span class="p">.</span><span class="nx">parseAll</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">GeoPointNode</span><span class="p">.</span><span class="nx">parseAll</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">parentIsLayer</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="nx">BinNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">TimeUnitNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">CalculateNode</span><span class="p">.</span><span class="nx">parseAllForSortIndex</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// add an output node pre aggregation</span>
      <span class="kd">var</span> <span class="nx">rawName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">RAW</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">raw</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OutputNode</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">rawName</span><span class="p">,</span> <span class="nx">RAW</span><span class="p">,</span> <span class="nx">outputNodeRefCounts</span><span class="p">);</span>
      <span class="nx">outputNodes</span><span class="p">[</span><span class="nx">rawName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">raw</span><span class="p">;</span>
      <span class="nx">head</span> <span class="o">=</span> <span class="nx">raw</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">agg</span> <span class="o">=</span> <span class="nx">AggregateNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">agg</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">head</span> <span class="o">=</span> <span class="nx">agg</span><span class="p">;</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">requiresSelectionId</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IdentifierNode</span><span class="p">(</span><span class="nx">head</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">StackNode</span><span class="p">.</span><span class="nx">makeFromEncoding</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">FilterInvalidNode</span><span class="p">.</span><span class="nx">make</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="o">||</span> <span class="nx">head</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// output node for marks</span>
      <span class="kd">var</span> <span class="nx">mainName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OutputNode</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">mainName</span><span class="p">,</span> <span class="nx">MAIN</span><span class="p">,</span> <span class="nx">outputNodeRefCounts</span><span class="p">);</span>
      <span class="nx">outputNodes</span><span class="p">[</span><span class="nx">mainName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">main</span><span class="p">;</span>
      <span class="nx">head</span> <span class="o">=</span> <span class="nx">main</span><span class="p">;</span>
      <span class="c1">// add facet marker</span>
      <span class="kd">var</span> <span class="nx">facetRoot</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetModel</span><span class="p">(</span><span class="nx">model</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">facetName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;facet&#39;</span><span class="p">);</span>
          <span class="nx">facetRoot</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FacetNode</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">facetName</span><span class="p">,</span> <span class="nx">main</span><span class="p">.</span><span class="nx">getSource</span><span class="p">());</span>
          <span class="nx">outputNodes</span><span class="p">[</span><span class="nx">facetName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">facetRoot</span><span class="p">;</span>
          <span class="nx">head</span> <span class="o">=</span> <span class="nx">facetRoot</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="p">{</span> <span class="nx">outputNodes</span><span class="o">:</span> <span class="nx">outputNodes</span><span class="p">,</span>
          <span class="nx">outputNodeRefCounts</span><span class="o">:</span> <span class="nx">outputNodeRefCounts</span><span class="p">,</span>
          <span class="nx">raw</span><span class="o">:</span> <span class="nx">raw</span><span class="p">,</span>
          <span class="nx">main</span><span class="o">:</span> <span class="nx">main</span><span class="p">,</span>
          <span class="nx">facetRoot</span><span class="o">:</span> <span class="nx">facetRoot</span><span class="p">,</span>
          <span class="nx">ancestorParse</span><span class="o">:</span> <span class="nx">ancestorParse</span> <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">BaseConcatModel</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">BaseConcatModel</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">BaseConcatModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">parseData</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseData</span><span class="p">();</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseSelection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="c1">// Merge selections up the hierarchy so that they may be referenced</span>
          <span class="c1">// across unit specs. Persist their definitions within each child</span>
          <span class="c1">// to assemble signals which remain within output Vega unit groups.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseSelection</span><span class="p">();</span>
              <span class="nx">keys</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">_this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
              <span class="p">});</span>
          <span class="p">};</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseMarkGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseMarkGroup</span><span class="p">();</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="c1">// TODO(#2415): support shared axes</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sg</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span><span class="p">(</span><span class="nx">sg</span><span class="p">);</span> <span class="p">},</span> <span class="nx">signals</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span><span class="p">();</span> <span class="p">});</span>
          <span class="k">return</span> <span class="p">[];</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span><span class="p">());</span>
          <span class="p">},</span> <span class="nx">assembleLayoutSignals</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionData</span><span class="p">(</span><span class="nx">db</span><span class="p">);</span> <span class="p">},</span> <span class="nx">data</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">BaseConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleMarks</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// only children have marks</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleTitle</span><span class="p">();</span>
              <span class="kd">var</span> <span class="nx">style</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleGroupStyle</span><span class="p">();</span>
              <span class="kd">var</span> <span class="nx">layoutSizeEncodeEntry</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleLayoutSize</span><span class="p">();</span>
              <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">child</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;group&#39;</span><span class="p">)</span> <span class="p">},</span> <span class="p">(</span><span class="nx">title</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="nx">title</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">style</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">style</span><span class="o">:</span> <span class="nx">style</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">layoutSizeEncodeEntry</span> <span class="o">?</span> <span class="p">{</span>
                  <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="nx">layoutSizeEncodeEntry</span>
                  <span class="p">}</span>
              <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleGroup</span><span class="p">());</span>
          <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">BaseConcatModel</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Model</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">parseLayerLayoutSize</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">parseChildrenLayoutSize</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">layoutSizeCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">;</span>
      <span class="nx">layoutSizeCmpt</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">parseNonUnitLayoutSizeForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">));</span>
      <span class="nx">layoutSizeCmpt</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">parseNonUnitLayoutSizeForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">parseRepeatLayoutSize</span> <span class="o">=</span> <span class="nx">parseLayerLayoutSize</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">parseConcatLayoutSize</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">parseChildrenLayoutSize</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">layoutSizeCmpt</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">sizeTypeToMerge</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">isVConcat</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">;</span>
      <span class="nx">layoutSizeCmpt</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="nx">sizeTypeToMerge</span><span class="p">,</span> <span class="nx">parseNonUnitLayoutSizeForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">sizeTypeToMerge</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseChildrenLayoutSize</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">child</span><span class="p">.</span><span class="nx">parseLayoutSize</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseNonUnitLayoutSizeForChannel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">sizeType</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">sizeType</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">resolve</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">mergedSize</span><span class="p">;</span>
      <span class="c1">// Try to merge layout size</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">childSize</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">scaleResolve</span> <span class="o">=</span> <span class="nx">resolve</span><span class="p">.</span><span class="nx">scale</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleResolve</span> <span class="o">===</span> <span class="s1">&#39;independent&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">childSize</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="s1">&#39;range-step&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Do not merge independent scales with range-step as their size depends</span>
              <span class="c1">// on the scale domains, which can be different between scales.</span>
              <span class="nx">mergedSize</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mergedSize</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">scaleResolve</span> <span class="o">===</span> <span class="s1">&#39;independent&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">mergedSize</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="nx">childSize</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// For independent scale, only merge if all the sizes are the same.</span>
                  <span class="c1">// If the values are different, abandon the merge!</span>
                  <span class="nx">mergedSize</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
                  <span class="k">break</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="nx">mergedSize</span> <span class="o">=</span> <span class="nx">mergeValuesWithExplicit</span><span class="p">(</span><span class="nx">mergedSize</span><span class="p">,</span> <span class="nx">childSize</span><span class="p">,</span> <span class="nx">sizeType</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">mergedSize</span> <span class="o">=</span> <span class="nx">childSize</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">mergedSize</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If merged, rename size and set size of all children.</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_c</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_b</span> <span class="o">&lt;</span> <span class="nx">_c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_c</span><span class="p">[</span><span class="nx">_b</span><span class="p">];</span>
              <span class="nx">model</span><span class="p">.</span><span class="nx">renameLayoutSize</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">));</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">,</span> <span class="s1">&#39;merged&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">mergedSize</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// Otherwise, there is no merged size.</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">explicit</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
              <span class="nx">value</span><span class="o">:</span> <span class="kc">undefined</span>
          <span class="p">};</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseUnitLayoutSize</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">layoutSizeComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">layoutSizeComponent</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">defaultUnitSize</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;width&#39;</span><span class="p">);</span>
          <span class="nx">layoutSizeComponent</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">layoutSizeComponent</span><span class="p">.</span><span class="nx">explicit</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">defaultUnitSize</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">);</span>
          <span class="nx">layoutSizeComponent</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defaultUnitSize</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">sizeType</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">sizeType</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">scaleComponent</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">scaleComponent</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">scaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">range</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// For discrete domain with range.step, use dynamic width/height</span>
              <span class="k">return</span> <span class="s1">&#39;range-step&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">view</span><span class="p">[</span><span class="nx">sizeType</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">hasProjection</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">view</span><span class="p">[</span><span class="nx">sizeType</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// No scale - set default size</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">sizeType</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;text&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// width for text mark without x-field is a bit wider than typical range step</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">textXRangeStep</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// Set width/height equal to rangeStep config or if rangeStep is null, use value from default scale config.</span>
          <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span> <span class="o">||</span> <span class="nx">defaultScaleConfig</span><span class="p">.</span><span class="nx">rangeStep</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">ConcatModel</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">ConcatModel</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">ConcatModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;concat&#39;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">&amp;&amp;</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">.</span><span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span> <span class="o">||</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">.</span><span class="nx">y</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">CONCAT_CANNOT_SHARE_AXIS</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">isVConcat</span> <span class="o">=</span> <span class="nx">isVConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">(</span><span class="nx">isVConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="o">?</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">vconcat</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">hconcat</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">buildModel</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">_this</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;concat_&#39;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">),</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">ConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseConcatLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">ConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseAxisGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">ConcatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// TODO: allow customization</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">padding</span><span class="o">:</span> <span class="p">{</span> <span class="nx">row</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">column</span><span class="o">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="nx">offset</span><span class="o">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isVConcat</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">columns</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">bounds</span><span class="o">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span> 
              <span class="c1">// Use align each so it can work with multiple plots with different size</span>
              <span class="nx">align</span><span class="o">:</span> <span class="s1">&#39;each&#39;</span> <span class="p">});</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">ConcatModel</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">BaseConcatModel</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">makeWalkTree</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// to name datasources</span>
      <span class="kd">var</span> <span class="nx">datasetIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="cm">/**</span>
<span class="cm">       * Recursively walk down the tree.</span>
<span class="cm">       */</span>
      <span class="kd">function</span> <span class="nx">walkTree</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">dataSource</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">SourceNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// If the source is a named data source or a data source with values, we need</span>
              <span class="c1">// to put it in a different data source. Otherwise, Vega may override the data.</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isUrlData</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">);</span>
                  <span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">name</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
                      <span class="nx">source</span><span class="o">:</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
                      <span class="nx">transform</span><span class="o">:</span> <span class="p">[]</span>
                  <span class="p">};</span>
                  <span class="nx">dataSource</span> <span class="o">=</span> <span class="nx">newData</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">ParseNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parent</span> <span class="k">instanceof</span> <span class="nx">SourceNode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// If node&#39;s parent is a root source and the data source does not refer to another data source, use normal format parse</span>
                  <span class="nx">dataSource</span><span class="p">.</span><span class="nx">format</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">format</span> <span class="o">||</span> <span class="p">{},</span> <span class="p">{</span> <span class="nx">parse</span><span class="o">:</span> <span class="nx">node</span><span class="p">.</span><span class="nx">assembleFormatParse</span><span class="p">()</span> <span class="p">});</span>
                  <span class="c1">// add calculates for all nested fields</span>
                  <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">assembleTransforms</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="c1">// Otherwise use Vega expression to parse</span>
                  <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">assembleTransforms</span><span class="p">());</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FacetNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;data_&quot;</span> <span class="o">+</span> <span class="nx">datasetIndex</span><span class="o">++</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span> <span class="o">||</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">);</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="nx">node</span><span class="p">.</span><span class="nx">assemble</span><span class="p">().</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="p">});</span>
              <span class="c1">// break here because the rest of the tree has to be taken care of by the facet.</span>
              <span class="k">return</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FilterNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">CalculateNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">GeoPointNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">GeoJSONNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">AggregateNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">LookupNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">WindowTransformNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">IdentifierNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">assemble</span><span class="p">());</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">FilterInvalidNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">BinNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">TimeUnitNode</span> <span class="o">||</span>
              <span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">StackNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">assemble</span><span class="p">());</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">AggregateNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;data_&quot;</span> <span class="o">+</span> <span class="nx">datasetIndex</span><span class="o">++</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span> <span class="o">&amp;&amp;</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">setSource</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">parent</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Note that an output node may be required but we still do not assemble a</span>
                  <span class="c1">// separate data source for it.</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">setSource</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;data_&quot;</span> <span class="o">+</span> <span class="nx">datasetIndex</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// Here we set the name of the datasource we generated. From now on</span>
                  <span class="c1">// other assemblers can use it.</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">setSource</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
                  <span class="c1">// if this node has more than one child, we will add a datasource automatically</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">()</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">);</span>
                      <span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="p">{</span>
                          <span class="nx">name</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
                          <span class="nx">source</span><span class="o">:</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
                          <span class="nx">transform</span><span class="o">:</span> <span class="p">[]</span>
                      <span class="p">};</span>
                      <span class="nx">dataSource</span> <span class="o">=</span> <span class="nx">newData</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">switch</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">numChildren</span><span class="p">())</span> <span class="p">{</span>
              <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
                  <span class="c1">// done</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span> <span class="k">instanceof</span> <span class="nx">OutputNode</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span> <span class="o">||</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                      <span class="c1">// do not push empty datasources that are simply references</span>
                      <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">break</span><span class="p">;</span>
              <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
                  <span class="nx">walkTree</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">dataSource</span><span class="p">);</span>
                  <span class="k">break</span><span class="p">;</span>
              <span class="k">default</span><span class="o">:</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;data_&quot;</span> <span class="o">+</span> <span class="nx">datasetIndex</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="kd">var</span> <span class="nx">source_1</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span> <span class="o">||</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dataSource</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">source_1</span> <span class="o">=</span> <span class="nx">dataSource</span><span class="p">.</span><span class="nx">source</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="p">{</span>
                          <span class="nx">name</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
                          <span class="nx">source</span><span class="o">:</span> <span class="nx">source_1</span><span class="p">,</span>
                          <span class="nx">transform</span><span class="o">:</span> <span class="p">[]</span>
                      <span class="p">};</span>
                      <span class="nx">walkTree</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">newData</span><span class="p">);</span>
                  <span class="p">});</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">walkTree</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Assemble data sources that are derived from faceted data.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">assembleFacetData</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="kd">var</span> <span class="nx">walkTree</span> <span class="o">=</span> <span class="nx">makeWalkTree</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="nx">root</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">walkTree</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">source</span><span class="o">:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
          <span class="nx">name</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
          <span class="nx">transform</span><span class="o">:</span> <span class="p">[]</span>
      <span class="p">});</span> <span class="p">});</span>
      <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Create Vega Data array from a given compiled model and append all of them to the given array</span>
<span class="cm">   *</span>
<span class="cm">   * @param  model</span>
<span class="cm">   * @param  data array</span>
<span class="cm">   * @return modified data array</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">assembleRootData</span><span class="p">(</span><span class="nx">dataComponent</span><span class="p">,</span> <span class="nx">datasets</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">roots</span> <span class="o">=</span> <span class="nx">vals</span><span class="p">(</span><span class="nx">dataComponent</span><span class="p">.</span><span class="nx">sources</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="c1">// roots.forEach(debug);</span>
      <span class="kd">var</span> <span class="nx">walkTree</span> <span class="o">=</span> <span class="nx">makeWalkTree</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">sourceIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">roots</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// assign a name if the source does not have a name yet</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">.</span><span class="nx">hasName</span><span class="p">())</span> <span class="p">{</span>
              <span class="nx">root</span><span class="p">.</span><span class="nx">dataName</span> <span class="o">=</span> <span class="s2">&quot;source_&quot;</span> <span class="o">+</span> <span class="nx">sourceIndex</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">newData</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">assemble</span><span class="p">();</span>
          <span class="nx">walkTree</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">newData</span><span class="p">);</span>
      <span class="p">});</span>
      <span class="c1">// remove empty transform arrays for cleaner output</span>
      <span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">transform</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">delete</span> <span class="nx">d</span><span class="p">.</span><span class="nx">transform</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="c1">// move sources without transforms (the ones that are potentially used in lookups) to the beginning</span>
      <span class="kd">var</span> <span class="nx">whereTo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">((</span><span class="nx">d</span><span class="p">.</span><span class="nx">transform</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">d</span><span class="p">.</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">data</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">whereTo</span><span class="o">++</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// now fix the from references in lookup transforms</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">data_1</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">data_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">data_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">transform</span> <span class="o">||</span> <span class="p">[];</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;lookup&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">t</span><span class="p">.</span><span class="nx">from</span> <span class="o">=</span> <span class="nx">dataComponent</span><span class="p">.</span><span class="nx">outputNodes</span><span class="p">[</span><span class="nx">t</span><span class="p">.</span><span class="nx">from</span><span class="p">].</span><span class="nx">getSource</span><span class="p">();</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// inline values for datasets that are in the datastore</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">data_2</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span> <span class="nx">_c</span> <span class="o">&lt;</span> <span class="nx">data_2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">data_2</span><span class="p">[</span><span class="nx">_c</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">name</span> <span class="k">in</span> <span class="nx">datasets</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">d</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="nx">datasets</span><span class="p">[</span><span class="nx">d</span><span class="p">.</span><span class="nx">name</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">replaceRepeaterInFacet</span><span class="p">(</span><span class="nx">facet</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">replaceRepeater</span><span class="p">(</span><span class="nx">facet</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">replaceRepeaterInEncoding</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">replaceRepeater</span><span class="p">(</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Replaces repeated value and returns if the repeated value is valid.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">replaceRepeat</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isRepeatRef</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">field</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">field</span><span class="p">.</span><span class="nx">repeat</span> <span class="k">in</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// any needed to calm down ts compiler</span>
              <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">o</span><span class="p">,</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">repeater</span><span class="p">[</span><span class="nx">o</span><span class="p">.</span><span class="nx">field</span><span class="p">.</span><span class="nx">repeat</span><span class="p">]</span> <span class="p">});</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">noSuchRepeatedValue</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">field</span><span class="p">.</span><span class="nx">repeat</span><span class="p">));</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Replace repeater values in a field def with the concrete field name.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">replaceRepeaterInFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">replaceRepeat</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// the field def should be ignored</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span> <span class="o">&amp;&amp;</span> <span class="nx">isSortField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="nx">replaceRepeat</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
          <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="p">(</span><span class="nx">sort</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">fieldDef</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">replaceRepeaterInChannelDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fd</span> <span class="o">=</span> <span class="nx">replaceRepeaterInFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fd</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">fd</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isConditionalDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">condition</span><span class="o">:</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fd</span> <span class="o">=</span> <span class="nx">replaceRepeaterInFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fd</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">channelDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">condition</span><span class="o">:</span> <span class="nx">fd</span> <span class="p">});</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">condition</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">channelDefWithoutCondition</span> <span class="o">=</span> <span class="nx">__rest</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;condition&quot;</span><span class="p">]);</span>
                  <span class="k">return</span> <span class="nx">channelDefWithoutCondition</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">channelDef</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">replaceRepeater</span><span class="p">(</span><span class="nx">mapping</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">channel</span> <span class="k">in</span> <span class="nx">mapping</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mapping</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">mapping</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// array cannot have condition</span>
                  <span class="nx">out</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">cd</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">replaceRepeaterInChannelDef</span><span class="p">(</span><span class="nx">cd</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span> <span class="p">})</span>
                      <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">cd</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">cd</span><span class="p">;</span> <span class="p">});</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">cd</span> <span class="o">=</span> <span class="nx">replaceRepeaterInChannelDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">cd</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">out</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cd</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">out</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">FacetModel</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">FacetModel</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">FacetModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;facet&#39;</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">buildModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">_this</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;child&#39;</span><span class="p">),</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[</span><span class="nx">_this</span><span class="p">.</span><span class="nx">child</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">facet</span> <span class="o">=</span> <span class="nx">replaceRepeaterInFacet</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">facet</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">facet</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">initFacet</span><span class="p">(</span><span class="nx">facet</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">initFacet</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">facet</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// clone to prevent side effect to the original spec</span>
          <span class="k">return</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">facet</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">normalizedFacet</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">contains</span><span class="p">([</span><span class="nx">ROW</span><span class="p">,</span> <span class="nx">COLUMN</span><span class="p">],</span> <span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
                  <span class="c1">// Drop unsupported channel</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">incompatibleChannel</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="s1">&#39;facet&#39;</span><span class="p">));</span>
                  <span class="k">return</span> <span class="nx">normalizedFacet</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">emptyFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">));</span>
                  <span class="k">return</span> <span class="nx">normalizedFacet</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="c1">// Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.</span>
              <span class="nx">normalizedFacet</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">normalizedFacet</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">channelHasField</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">!!</span><span class="k">this</span><span class="p">.</span><span class="nx">facet</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fieldDef</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">facet</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">parseData</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">parseData</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseChildrenLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseSelection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// As a facet has a single child, the selection components are the same.</span>
          <span class="c1">// The child maintains its selections to assemble signals, which remain</span>
          <span class="c1">// within its unit.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">parseSelection</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseMarkGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">parseMarkGroup</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span><span class="p">();</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseHeader</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">parseHeader</span><span class="p">(</span><span class="s1">&#39;row&#39;</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">mergeChildAxis</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">mergeChildAxis</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseHeader</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">facet</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">header</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">header</span> <span class="o">||</span> <span class="p">{};</span>
              <span class="kd">var</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">:</span>
                  <span class="nx">header</span><span class="p">.</span><span class="nx">title</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">header</span><span class="p">.</span><span class="nx">title</span> <span class="o">:</span> <span class="nx">title</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// merge title with child to produce &quot;Title / Subtitle / Sub-subtitle&quot;</span>
                  <span class="nx">title$$1</span> <span class="o">+=</span> <span class="s1">&#39; / &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">title</span><span class="p">;</span>
                  <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">title</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                  <span class="nx">title</span><span class="o">:</span> <span class="nx">title$$1</span><span class="p">,</span>
                  <span class="nx">facetFieldDef</span><span class="o">:</span> <span class="nx">fieldDef</span><span class="p">,</span>
                  <span class="c1">// TODO: support adding label to footer as well</span>
                  <span class="nx">header</span><span class="o">:</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">makeHeaderComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="kc">true</span><span class="p">)]</span>
              <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">makeHeaderComponent</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">labels</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">sizeType</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="s1">&#39;height&#39;</span> <span class="o">:</span> <span class="s1">&#39;width&#39;</span><span class="p">;</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">labels</span><span class="o">:</span> <span class="nx">labels</span><span class="p">,</span>
              <span class="nx">sizeSignal</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">)</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
              <span class="nx">axes</span><span class="o">:</span> <span class="p">[]</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">mergeChildAxis</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">,</span> <span class="nx">layoutHeaders</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">,</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">resolve</span><span class="p">;</span>
              <span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parseGuideResolve</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// For shared axis, move the axes to facet&#39;s header or footer</span>
                  <span class="kd">var</span> <span class="nx">headerChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;column&#39;</span> <span class="o">:</span> <span class="s1">&#39;row&#39;</span><span class="p">;</span>
                  <span class="kd">var</span> <span class="nx">layoutHeader</span> <span class="o">=</span> <span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">headerChannel</span><span class="p">];</span>
                  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">axisComponent</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                      <span class="kd">var</span> <span class="nx">headerType</span> <span class="o">=</span> <span class="nx">getHeaderType</span><span class="p">(</span><span class="nx">axisComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">));</span>
                      <span class="nx">layoutHeader</span><span class="p">[</span><span class="nx">headerType</span><span class="p">]</span> <span class="o">=</span> <span class="nx">layoutHeader</span><span class="p">[</span><span class="nx">headerType</span><span class="p">]</span> <span class="o">||</span>
                          <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">makeHeaderComponent</span><span class="p">(</span><span class="nx">headerChannel</span><span class="p">,</span> <span class="kc">false</span><span class="p">)];</span>
                      <span class="kd">var</span> <span class="nx">mainAxis</span> <span class="o">=</span> <span class="nx">assembleAxis</span><span class="p">(</span><span class="nx">axisComponent</span><span class="p">,</span> <span class="s1">&#39;main&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="p">{</span> <span class="nx">header</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
                      <span class="c1">// LayoutHeader no longer keep track of property precedence, thus let&#39;s combine.</span>
                      <span class="nx">layoutHeader</span><span class="p">[</span><span class="nx">headerType</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="nx">axes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">mainAxis</span><span class="p">);</span>
                      <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">mainExtracted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span><span class="p">(</span><span class="nx">signals</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span><span class="p">();</span>
          <span class="k">return</span> <span class="p">[];</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionData</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getLayoutBandMixins</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">headerType</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">bandMixins</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">bandType</span> <span class="o">=</span> <span class="nx">headerType</span> <span class="o">===</span> <span class="s1">&#39;header&#39;</span> <span class="o">?</span> <span class="s1">&#39;headerBand&#39;</span> <span class="o">:</span> <span class="s1">&#39;footerBand&#39;</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">];</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">layoutHeaderComponent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutHeaders</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">headerComponent</span> <span class="o">=</span> <span class="nx">layoutHeaderComponent</span><span class="p">[</span><span class="nx">headerType</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">headerComponent</span> <span class="o">&amp;&amp;</span> <span class="nx">headerComponent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">sizeType</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;row&#39;</span> <span class="o">?</span> <span class="s1">&#39;height&#39;</span> <span class="o">:</span> <span class="s1">&#39;width&#39;</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">layoutSize</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">))</span> <span class="p">{</span>
                      <span class="c1">// If facet child does not have size signal, then apply headerBand</span>
                      <span class="nx">bandMixins</span><span class="p">[</span><span class="nx">bandType</span><span class="p">]</span> <span class="o">=</span> <span class="nx">bandMixins</span><span class="p">[</span><span class="nx">bandType</span><span class="p">]</span> <span class="o">||</span> <span class="p">{};</span>
                      <span class="nx">bandMixins</span><span class="p">[</span><span class="nx">bandType</span><span class="p">][</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">bandMixins</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">columns</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">columnDistinctSignal</span><span class="p">()</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
          <span class="c1">// TODO: determine default align based on shared / independent scales</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">padding</span><span class="o">:</span> <span class="p">{</span> <span class="nx">row</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">column</span><span class="o">:</span> <span class="mi">10</span> <span class="p">}</span> <span class="p">},</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLayoutBandMixins</span><span class="p">(</span><span class="s1">&#39;header&#39;</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLayoutBandMixins</span><span class="p">(</span><span class="s1">&#39;footer&#39;</span><span class="p">),</span> <span class="p">{</span> 
              <span class="c1">// TODO: support offset for rowHeader/rowFooter/rowTitle/columnHeader/columnFooter/columnTitle</span>
              <span class="nx">offset</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">columns</span><span class="o">:</span> <span class="nx">columns</span><span class="p">,</span> <span class="nx">bounds</span><span class="o">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="nx">align</span><span class="o">:</span> <span class="s1">&#39;all&#39;</span> <span class="p">});</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span><span class="p">();</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">columnDistinctSignal</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="k">instanceof</span> <span class="nx">FacetModel</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// For nested facet, we will add columns to group mark instead</span>
              <span class="c1">// See discussion in https://github.com/vega/vega/issues/952</span>
              <span class="c1">// and https://github.com/vega/vega-view/releases/tag/v1.2.6</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// In facetNode.assemble(), the name is always this.getName(&#39;column&#39;) + &#39;_layout&#39;.</span>
              <span class="kd">var</span> <span class="nx">facetLayoutDataName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;column_domain&#39;</span><span class="p">);</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;length(data(&#39;&quot;</span> <span class="o">+</span> <span class="nx">facetLayoutDataName</span> <span class="o">+</span> <span class="s2">&quot;&#39;))&quot;</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="k">instanceof</span> <span class="nx">FacetModel</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// Provide number of columns for layout.</span>
              <span class="c1">// See discussion in https://github.com/vega/vega/issues/952</span>
              <span class="c1">// and https://github.com/vega/vega-view/releases/tag/v1.2.6</span>
              <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="p">{</span>
                  <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="p">{</span>
                          <span class="c1">// TODO(https://github.com/vega/vega-lite/issues/2759):</span>
                          <span class="c1">// Correct the signal for facet of concat of facet_column</span>
                          <span class="nx">columns</span><span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">column</span><span class="p">,</span> <span class="p">{</span> <span class="nx">prefix</span><span class="o">:</span> <span class="s1">&#39;distinct&#39;</span> <span class="p">})</span> <span class="p">}</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleGroup</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">signals</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleGroup</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">signals</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="cm">/**</span>
<span class="cm">       * Aggregate cardinality for calculating size</span>
<span class="cm">       */</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCardinalityAggregateForChild</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">fields</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">ops</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">child</span> <span class="k">instanceof</span> <span class="nx">FacetModel</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">fields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">vgField</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">facet</span><span class="p">.</span><span class="nx">column</span><span class="p">));</span>
                  <span class="nx">ops</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;distinct&#39;</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">];</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
                  <span class="kd">var</span> <span class="nx">childScaleComponent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">childScaleComponent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">childScaleComponent</span><span class="p">.</span><span class="nx">merged</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">childScaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
                      <span class="kd">var</span> <span class="nx">range</span> <span class="o">=</span> <span class="nx">childScaleComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">range</span><span class="p">))</span> <span class="p">{</span>
                          <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">assembleDomain</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">child</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
                          <span class="kd">var</span> <span class="nx">field</span> <span class="o">=</span> <span class="nx">getFieldFromDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">);</span>
                          <span class="k">if</span> <span class="p">(</span><span class="nx">field</span><span class="p">)</span> <span class="p">{</span>
                              <span class="nx">fields</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">field</span><span class="p">);</span>
                              <span class="nx">ops</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;distinct&#39;</span><span class="p">);</span>
                          <span class="p">}</span>
                          <span class="k">else</span> <span class="p">{</span>
                              <span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Unknown field for </span><span class="cp">${</span><span class="n">channel</span><span class="cp">}</span><span class="s1">.  Cannot calculate view size.&#39;</span><span class="p">);</span>
                          <span class="p">}</span>
                      <span class="p">}</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">fields</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">fields</span><span class="o">:</span> <span class="nx">fields</span><span class="p">,</span> <span class="nx">ops</span><span class="o">:</span> <span class="nx">ops</span> <span class="p">}</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleMarks</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">child</span><span class="p">,</span> <span class="nx">facet</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">facet</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">facetRoot</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">facetRoot</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">assembleFacetData</span><span class="p">(</span><span class="nx">facetRoot</span><span class="p">);</span>
          <span class="c1">// If we facet by two dimensions, we need to add a cross operator to the aggregation</span>
          <span class="c1">// so that we create all groups</span>
          <span class="kd">var</span> <span class="nx">hasRow</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">ROW</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">hasColumn</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">channelHasField</span><span class="p">(</span><span class="nx">COLUMN</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">layoutSizeEncodeEntry</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleLayoutSize</span><span class="p">();</span>
          <span class="kd">var</span> <span class="nx">aggregateMixins</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">hasRow</span> <span class="o">&amp;&amp;</span> <span class="nx">hasColumn</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">aggregateMixins</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">cross</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">cardinalityAggregateForChild</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getCardinalityAggregateForChild</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">cardinalityAggregateForChild</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">aggregateMixins</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">aggregateMixins</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">,</span> <span class="nx">cardinalityAggregateForChild</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleTitle</span><span class="p">();</span>
          <span class="kd">var</span> <span class="nx">style</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleGroupStyle</span><span class="p">();</span>
          <span class="kd">var</span> <span class="nx">markGroup</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">),</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;group&#39;</span> <span class="p">},</span> <span class="p">(</span><span class="nx">title$$1</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="nx">title$$1</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">style</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">style</span><span class="o">:</span> <span class="nx">style</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">from</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">facet</span><span class="o">:</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">facetRoot</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">facetRoot</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">groupby</span><span class="o">:</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">hasRow</span> <span class="o">?</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">ROW</span><span class="p">)]</span> <span class="o">:</span> <span class="p">[],</span> <span class="nx">hasColumn</span> <span class="o">?</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">COLUMN</span><span class="p">)]</span> <span class="o">:</span> <span class="p">[])</span> <span class="p">},</span> <span class="nx">aggregateMixins</span><span class="p">)</span>
              <span class="p">},</span> <span class="nx">sort</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">hasRow</span> <span class="o">?</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">ROW</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span><span class="p">,</span> <span class="p">})]</span> <span class="o">:</span> <span class="p">[],</span> <span class="nx">hasColumn</span> <span class="o">?</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">COLUMN</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">})]</span> <span class="o">:</span> <span class="p">[]),</span>
                  <span class="nx">order</span><span class="o">:</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">hasRow</span> <span class="o">?</span> <span class="p">[(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">row</span><span class="p">.</span><span class="nx">sort</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;ascending&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="p">[],</span> <span class="nx">hasColumn</span> <span class="o">?</span> <span class="p">[(</span><span class="nx">facet</span><span class="p">.</span><span class="nx">column</span><span class="p">.</span><span class="nx">sort</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;ascending&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="p">[])</span>
              <span class="p">}</span> <span class="p">},</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">layoutSizeEncodeEntry</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">layoutSizeEncodeEntry</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleGroup</span><span class="p">());</span>
          <span class="k">return</span> <span class="p">[</span><span class="nx">markGroup</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">FacetModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getMapping</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">facet</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">FacetModel</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">ModelWithField</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">isFalseOrNull</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">v</span> <span class="o">===</span> <span class="kc">false</span> <span class="o">||</span> <span class="nx">v</span> <span class="o">===</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">AxisComponent</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">AxisComponent</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">AxisComponent</span><span class="p">(</span><span class="nx">explicit</span><span class="p">,</span> <span class="nx">implicit</span><span class="p">,</span> <span class="nx">mainExtracted</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">explicit</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">explicit</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">implicit</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">implicit</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mainExtracted</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">mainExtracted</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">=</span> <span class="nx">explicit</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">implicit</span> <span class="o">=</span> <span class="nx">implicit</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">mainExtracted</span> <span class="o">=</span> <span class="nx">mainExtracted</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">AxisComponent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">clone</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">AxisComponent</span><span class="p">(</span><span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">explicit</span><span class="p">),</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">implicit</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">mainExtracted</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">AxisComponent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasAxisPart</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">part</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// FIXME(https://github.com/vega/vega-lite/issues/2552) this method can be wrong if users use a Vega theme.</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">part</span> <span class="o">===</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// always has the axis container part</span>
              <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">part</span> <span class="o">===</span> <span class="s1">&#39;grid&#39;</span> <span class="o">||</span> <span class="nx">part</span> <span class="o">===</span> <span class="s1">&#39;title&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="o">!!</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">part</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="c1">// Other parts are enabled by default, so they should not be false or null.</span>
          <span class="k">return</span> <span class="o">!</span><span class="nx">isFalseOrNull</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">part</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">AxisComponent</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Split</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">getAxisConfig</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">orient</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">orient</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span> <span class="p">}</span>
      <span class="c1">// configTypes to loop, starting from higher precedence</span>
      <span class="kd">var</span> <span class="nx">configTypes</span> <span class="o">=</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;band&#39;</span> <span class="o">?</span> <span class="p">[</span><span class="s1">&#39;axisBand&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="p">[]).</span><span class="nx">concat</span><span class="p">([</span>
          <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;axisX&#39;</span> <span class="o">:</span> <span class="s1">&#39;axisY&#39;</span><span class="p">,</span>
          <span class="s1">&#39;axis&#39;</span> <span class="o">+</span> <span class="nx">orient</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="o">+</span> <span class="nx">orient</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
          <span class="s1">&#39;axis&#39;</span>
      <span class="p">]);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">configTypes_1</span> <span class="o">=</span> <span class="nx">configTypes</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">configTypes_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">configType</span> <span class="o">=</span> <span class="nx">configTypes_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">[</span><span class="nx">configType</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">config</span><span class="p">[</span><span class="nx">configType</span><span class="p">][</span><span class="nx">property</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">config</span><span class="p">[</span><span class="nx">configType</span><span class="p">][</span><span class="nx">property</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">labels$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">specifiedLabelsSpec</span><span class="p">,</span> <span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">||</span>
          <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">)</span> <span class="o">:</span>
              <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="s1">&#39;y2&#39;</span><span class="p">)</span> <span class="o">:</span>
                  <span class="kc">undefined</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">axis</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">axis</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">labelsSpec</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="c1">// Text</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isTimeFieldDef</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">))</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">isUTCScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">UTC</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">expr</span> <span class="o">=</span> <span class="nx">timeFormatExpression</span><span class="p">(</span><span class="s1">&#39;datum.value&#39;</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">,</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">axis</span><span class="p">.</span><span class="nx">shortTimeLabels</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">timeFormat</span><span class="p">,</span> <span class="nx">isUTCScale</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">expr</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">labelsSpec</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">expr</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// Label Angle</span>
      <span class="kd">var</span> <span class="nx">angle</span> <span class="o">=</span> <span class="nx">getAxisConfig</span><span class="p">(</span><span class="s1">&#39;labelAngle&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">orient</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">angle</span> <span class="o">=</span> <span class="nx">labelAngle</span><span class="p">(</span><span class="nx">axis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">labelsSpec</span><span class="p">.</span><span class="nx">angle</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">angle</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">align</span> <span class="o">=</span> <span class="nx">labelAlign$1</span><span class="p">(</span><span class="nx">angle</span><span class="p">,</span> <span class="nx">orient</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">align</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">labelsSpec</span><span class="p">.</span><span class="nx">align</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">align</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="nx">labelsSpec</span><span class="p">.</span><span class="nx">baseline</span> <span class="o">=</span> <span class="nx">labelBaseline$1</span><span class="p">(</span><span class="nx">angle</span><span class="p">,</span> <span class="nx">orient</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">labelsSpec</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">labelsSpec</span><span class="p">,</span> <span class="nx">specifiedLabelsSpec</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">labelsSpec</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">labelsSpec</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labelBaseline$1</span><span class="p">(</span><span class="nx">angle</span><span class="p">,</span> <span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">||</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">&lt;=</span> <span class="mi">45</span> <span class="o">||</span> <span class="mi">315</span> <span class="o">&lt;=</span> <span class="nx">angle</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">?</span> <span class="s1">&#39;bottom&#39;</span> <span class="o">:</span> <span class="s1">&#39;top&#39;</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">135</span> <span class="o">&lt;=</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;=</span> <span class="mi">225</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">?</span> <span class="s1">&#39;top&#39;</span> <span class="o">:</span> <span class="s1">&#39;bottom&#39;</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;middle&#39;</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">((</span><span class="nx">angle</span> <span class="o">&lt;=</span> <span class="mi">45</span> <span class="o">||</span> <span class="mi">315</span> <span class="o">&lt;=</span> <span class="nx">angle</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="mi">135</span> <span class="o">&lt;=</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;=</span> <span class="mi">225</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;middle&#39;</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">45</span> <span class="o">&lt;=</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;=</span> <span class="mi">135</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;left&#39;</span> <span class="o">?</span> <span class="s1">&#39;top&#39;</span> <span class="o">:</span> <span class="s1">&#39;bottom&#39;</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;left&#39;</span> <span class="o">?</span> <span class="s1">&#39;bottom&#39;</span> <span class="o">:</span> <span class="s1">&#39;top&#39;</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labelAngle</span><span class="p">(</span><span class="nx">axis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">axis</span><span class="p">.</span><span class="nx">labelAngle</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Make angle within [0,360)</span>
          <span class="k">return</span> <span class="p">((</span><span class="nx">axis</span><span class="p">.</span><span class="nx">labelAngle</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">([</span><span class="nx">NOMINAL</span><span class="p">,</span> <span class="nx">ORDINAL</span><span class="p">],</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="mi">270</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labelAlign$1</span><span class="p">(</span><span class="nx">angle</span><span class="p">,</span> <span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">angle</span> <span class="o">=</span> <span class="p">((</span><span class="nx">angle</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">||</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;center&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;</span> <span class="mi">180</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">?</span> <span class="s1">&#39;right&#39;</span> <span class="o">:</span> <span class="s1">&#39;left&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span> <span class="o">?</span> <span class="s1">&#39;left&#39;</span> <span class="o">:</span> <span class="s1">&#39;right&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">((</span><span class="nx">angle</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;center&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">90</span> <span class="o">&lt;=</span> <span class="nx">angle</span> <span class="o">&amp;&amp;</span> <span class="nx">angle</span> <span class="o">&lt;</span> <span class="mi">270</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;left&#39;</span> <span class="o">?</span> <span class="s1">&#39;left&#39;</span> <span class="o">:</span> <span class="s1">&#39;right&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;left&#39;</span> <span class="o">?</span> <span class="s1">&#39;right&#39;</span> <span class="o">:</span> <span class="s1">&#39;left&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// TODO: we need to refactor this method after we take care of config refactoring</span>
  <span class="cm">/**</span>
<span class="cm">   * Default rules for whether to show a grid should be shown for a channel.</span>
<span class="cm">   * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">grid</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">gridScale</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">gridChannel</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;y&#39;</span> <span class="o">:</span> <span class="s1">&#39;x&#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">gridChannel</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">gridChannel</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labelFlush</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">specifiedAxis</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">labelFlush</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">labelFlush</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;quantitative&#39;</span><span class="p">,</span> <span class="s1">&#39;temporal&#39;</span><span class="p">],</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">labelOverlap</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedAxis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">labelOverlap</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">labelOverlap</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// do not prevent overlap for nominal data because there is no way to infer what the missing labels are</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">&#39;nominal&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="s1">&#39;log&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;greedy&#39;</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">orient</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">X</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;bottom&#39;</span><span class="p">;</span>
          <span class="k">case</span> <span class="nx">Y</span><span class="o">:</span>
              <span class="k">return</span> <span class="s1">&#39;left&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="cm">/* istanbul ignore next: This should never happen. */</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">INVALID_CHANNEL_FOR_AXIS</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">tickCount</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">scaleType</span> <span class="o">!==</span> <span class="s1">&#39;log&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">contains</span><span class="p">([</span><span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;hours&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;quarter&#39;</span><span class="p">],</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">timeUnit</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// for binned data, we don&#39;t want more ticks than maxbins</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;ceil(&quot;</span> <span class="o">+</span> <span class="nx">size</span><span class="p">.</span><span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;/20)&quot;</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;ceil(&quot;</span> <span class="o">+</span> <span class="nx">size</span><span class="p">.</span><span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;/40)&quot;</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">values$1</span><span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">vals$$1</span> <span class="o">=</span> <span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">values</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">values</span> <span class="o">&amp;&amp;</span> <span class="nx">isDateTime</span><span class="p">(</span><span class="nx">vals$$1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">vals$$1</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">dt</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// normalize = true as end user won&#39;t put 0 = January</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="nx">dateTimeExpr</span><span class="p">(</span><span class="nx">dt</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="p">};</span>
          <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">vals$$1</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">QUANTITATIVE</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">domain</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleDomain</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span> <span class="o">&amp;&amp;</span> <span class="nx">domain</span> <span class="o">!==</span> <span class="s1">&#39;unaggregated&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isSelectionDomain</span><span class="p">(</span><span class="nx">domain</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// explicit value</span>
              <span class="k">return</span> <span class="nx">vals$$1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">signal</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">binToString</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">field</span> <span class="o">+</span> <span class="s2">&quot;_bins&quot;</span><span class="p">);</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">signal</span><span class="o">:</span> <span class="s2">&quot;sequence(&quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.start, &quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.stop + &quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.step, &quot;</span> <span class="o">+</span> <span class="nx">signal</span> <span class="o">+</span> <span class="s2">&quot;.step)&quot;</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">vals$$1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">parseUnitAxis</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">POSITION_SCALE_CHANNELS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">axis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">axis</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">parseAxis</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">)];</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">axis</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">OPPOSITE_ORIENT</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">bottom</span><span class="o">:</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span>
      <span class="nx">top</span><span class="o">:</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span>
      <span class="nx">left</span><span class="o">:</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span>
      <span class="nx">right</span><span class="o">:</span> <span class="s1">&#39;left&#39;</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">parseLayerAxis</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">,</span> <span class="nx">axes</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">axes</span><span class="p">,</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">resolve</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">axisCount</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">top</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bottom</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">right</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">left</span><span class="o">:</span> <span class="mi">0</span> <span class="p">};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_b</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_b</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">child</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span><span class="p">();</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_d</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">);</span> <span class="nx">_c</span> <span class="o">&lt;</span> <span class="nx">_d</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_d</span><span class="p">[</span><span class="nx">_c</span><span class="p">];</span>
              <span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">parseGuideResolve</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// If the resolve says shared (and has not been overridden)</span>
                  <span class="c1">// We will try to merge and see if there is a conflict</span>
                  <span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">mergeAxisComponents</span><span class="p">(</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">],</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="p">{</span>
                      <span class="c1">// If merge returns nothing, there is a conflict so we cannot make the axis shared.</span>
                      <span class="c1">// Thus, mark axis as independent and remove the axis component.</span>
                      <span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;independent&#39;</span><span class="p">;</span>
                      <span class="k">delete</span> <span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// Move axes to layer&#39;s axis component and merge shared axes</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_f</span> <span class="o">=</span> <span class="p">[</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">];</span> <span class="nx">_e</span> <span class="o">&lt;</span> <span class="nx">_f</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channel</span> <span class="o">=</span> <span class="nx">_f</span><span class="p">[</span><span class="nx">_e</span><span class="p">];</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_h</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_g</span> <span class="o">&lt;</span> <span class="nx">_h</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_g</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_h</span><span class="p">[</span><span class="nx">_g</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="p">{</span>
                  <span class="c1">// skip if the child does not have a particular axis</span>
                  <span class="k">continue</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;independent&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// If axes are independent, concat the axisComponent array.</span>
                  <span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
                  <span class="c1">// Automatically adjust orient</span>
                  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_k</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span> <span class="nx">_j</span> <span class="o">&lt;</span> <span class="nx">_k</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                      <span class="kd">var</span> <span class="nx">axisComponent</span> <span class="o">=</span> <span class="nx">_k</span><span class="p">[</span><span class="nx">_j</span><span class="p">];</span>
                      <span class="kd">var</span> <span class="nx">_l</span> <span class="o">=</span> <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">),</span> <span class="nx">orient$$1</span> <span class="o">=</span> <span class="nx">_l</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">explicit</span> <span class="o">=</span> <span class="nx">_l</span><span class="p">.</span><span class="nx">explicit</span><span class="p">;</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">axisCount</span><span class="p">[</span><span class="nx">orient$$1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">explicit</span><span class="p">)</span> <span class="p">{</span>
                          <span class="c1">// Change axis orient if the number do not match</span>
                          <span class="kd">var</span> <span class="nx">oppositeOrient</span> <span class="o">=</span> <span class="nx">OPPOSITE_ORIENT</span><span class="p">[</span><span class="nx">orient$$1</span><span class="p">];</span>
                          <span class="k">if</span> <span class="p">(</span><span class="nx">axisCount</span><span class="p">[</span><span class="nx">orient$$1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">axisCount</span><span class="p">[</span><span class="nx">oppositeOrient</span><span class="p">])</span> <span class="p">{</span>
                              <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">,</span> <span class="nx">oppositeOrient</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
                          <span class="p">}</span>
                      <span class="p">}</span>
                      <span class="nx">axisCount</span><span class="p">[</span><span class="nx">orient$$1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="c1">// After merging, make sure to remove axes from child</span>
              <span class="k">delete</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeAxisComponents</span><span class="p">(</span><span class="nx">mergedAxisCmpts</span><span class="p">,</span> <span class="nx">childAxisCmpts</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">mergedAxisCmpts</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// FIXME: this is a bit wrong once we support multiple axes</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">mergedAxisCmpts</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">childAxisCmpts</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// Cannot merge axis component with different number of axes.</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">length_1</span> <span class="o">=</span> <span class="nx">mergedAxisCmpts</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length_1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">merged</span> <span class="o">=</span> <span class="nx">mergedAxisCmpts</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">childAxisCmpts</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">((</span><span class="o">!!</span><span class="nx">merged</span><span class="p">)</span> <span class="o">!==</span> <span class="p">(</span><span class="o">!!</span><span class="nx">child</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">merged</span> <span class="o">&amp;&amp;</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">mergedOrient</span> <span class="o">=</span> <span class="nx">merged</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">);</span>
                  <span class="kd">var</span> <span class="nx">childOrient</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">mergedOrient</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="nx">childOrient</span><span class="p">.</span><span class="nx">explicit</span> <span class="o">&amp;&amp;</span> <span class="nx">mergedOrient</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="nx">childOrient</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// TODO: throw warning if resolve is explicit (We don&#39;t have info about explicit/implicit resolve yet.)</span>
                      <span class="c1">// Cannot merge due to inconsistent orient</span>
                      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="p">{</span>
                      <span class="nx">mergedAxisCmpts</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">mergeAxisComponent</span><span class="p">(</span><span class="nx">merged</span><span class="p">,</span> <span class="nx">child</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// For first one, return a copy of the child</span>
          <span class="k">return</span> <span class="nx">childAxisCmpts</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">axisComponent</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">clone</span><span class="p">();</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">mergedAxisCmpts</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">mergeAxisComponent</span><span class="p">(</span><span class="nx">merged</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">mergedValueWithExplicit</span> <span class="o">=</span> <span class="nx">mergeValuesWithExplicit</span><span class="p">(</span><span class="nx">merged</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">prop</span><span class="p">),</span> <span class="nx">child</span><span class="p">.</span><span class="nx">getWithExplicit</span><span class="p">(</span><span class="nx">prop</span><span class="p">),</span> <span class="nx">prop</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">,</span> 
          <span class="c1">// Tie breaker function</span>
          <span class="kd">function</span> <span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">switch</span> <span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">case</span> <span class="s1">&#39;title&#39;</span><span class="o">:</span>
                      <span class="k">return</span> <span class="nx">mergeTitleComponent</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">);</span>
                  <span class="k">case</span> <span class="s1">&#39;gridScale&#39;</span><span class="o">:</span>
                      <span class="k">return</span> <span class="p">{</span>
                          <span class="nx">explicit</span><span class="o">:</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">explicit</span><span class="p">,</span>
                          <span class="nx">value</span><span class="o">:</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">value</span> <span class="o">||</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">value</span>
                      <span class="p">};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">defaultTieBreaker</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">prop</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">);</span>
          <span class="p">});</span>
          <span class="nx">merged</span><span class="p">.</span><span class="nx">setWithExplicit</span><span class="p">(</span><span class="nx">prop</span><span class="p">,</span> <span class="nx">mergedValueWithExplicit</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">VG_AXIS_PROPERTIES_1</span> <span class="o">=</span> <span class="nx">VG_AXIS_PROPERTIES</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">VG_AXIS_PROPERTIES_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="nx">VG_AXIS_PROPERTIES_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
          <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">merged</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getFieldDefTitle</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">channel2</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;x2&#39;</span> <span class="o">:</span> <span class="s1">&#39;y2&#39;</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">fieldDef2</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel2</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">title1</span> <span class="o">=</span> <span class="nx">fieldDef</span> <span class="o">?</span> <span class="nx">fieldDef</span><span class="p">.</span><span class="nx">title</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">title2</span> <span class="o">=</span> <span class="nx">fieldDef2</span> <span class="o">?</span> <span class="nx">fieldDef2</span><span class="p">.</span><span class="nx">title</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">title1</span> <span class="o">&amp;&amp;</span> <span class="nx">title2</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">mergeTitle</span><span class="p">(</span><span class="nx">title1</span><span class="p">,</span> <span class="nx">title2</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">title1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">title1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">title2</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">title2</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">title1</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// falsy value to disable config</span>
          <span class="k">return</span> <span class="nx">title1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">title2</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// falsy value to disable config</span>
          <span class="k">return</span> <span class="nx">title2</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">parseAxis</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">axis</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">axis</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">axisComponent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AxisComponent</span><span class="p">();</span>
      <span class="c1">// 1.2. Add properties</span>
      <span class="nx">VG_AXIS_PROPERTIES</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">getProperty$1</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">axis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">explicit</span> <span class="o">=</span> 
              <span class="c1">// specified axis.values is already respected, but may get transformed.</span>
              <span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;values&#39;</span> <span class="o">?</span> <span class="o">!!</span><span class="nx">axis</span><span class="p">.</span><span class="nx">values</span> <span class="o">:</span>
                  <span class="c1">// both VL axis.encoding and axis.labelAngle affect VG axis.encode</span>
                  <span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;encode&#39;</span> <span class="o">?</span> <span class="o">!!</span><span class="nx">axis</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">||</span> <span class="o">!!</span><span class="nx">axis</span><span class="p">.</span><span class="nx">labelAngle</span> <span class="o">:</span>
                      <span class="c1">// title can be explicit if fieldDef.title is set</span>
                      <span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;title&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">===</span> <span class="nx">getFieldDefTitle</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span>
                          <span class="c1">// Otherwise, things are explicit if the returned value matches the specified property</span>
                          <span class="nx">value</span> <span class="o">===</span> <span class="nx">axis</span><span class="p">[</span><span class="nx">property</span><span class="p">];</span>
              <span class="kd">var</span> <span class="nx">configValue</span> <span class="o">=</span> <span class="nx">getAxisConfig</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">));</span>
              <span class="c1">// only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">explicit</span> <span class="o">||</span> <span class="nx">configValue</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Do not apply implicit rule if there is a config value</span>
                  <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">explicit</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">property</span> <span class="o">===</span> <span class="s1">&#39;grid&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">configValue</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Grid is an exception because we need to set grid = true to generate another grid axis</span>
                  <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">configValue</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">});</span>
      <span class="c1">// 2) Add guide encode definition groups</span>
      <span class="kd">var</span> <span class="nx">axisEncoding</span> <span class="o">=</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">||</span> <span class="p">{};</span>
      <span class="kd">var</span> <span class="nx">axisEncode</span> <span class="o">=</span> <span class="nx">AXIS_PARTS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">part</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">axisComponent</span><span class="p">.</span><span class="nx">hasAxisPart</span><span class="p">(</span><span class="nx">part</span><span class="p">))</span> <span class="p">{</span>
              <span class="c1">// No need to create encode for a disabled part.</span>
              <span class="k">return</span> <span class="nx">e</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">axisEncodingPart</span> <span class="o">=</span> <span class="nx">guideEncodeEntry</span><span class="p">(</span><span class="nx">axisEncoding</span><span class="p">[</span><span class="nx">part</span><span class="p">]</span> <span class="o">||</span> <span class="p">{},</span> <span class="nx">model</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">part</span> <span class="o">===</span> <span class="s1">&#39;labels&#39;</span> <span class="o">?</span>
              <span class="nx">labels$1</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">axisEncodingPart</span><span class="p">,</span> <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">))</span> <span class="o">:</span>
              <span class="nx">axisEncodingPart</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">value</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">e</span><span class="p">[</span><span class="nx">part</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">update</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">e</span><span class="p">;</span>
      <span class="p">},</span> <span class="p">{});</span>
      <span class="c1">// FIXME: By having encode as one property, we won&#39;t have fine grained encode merging.</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">keys</span><span class="p">(</span><span class="nx">axisEncode</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">axisComponent</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;encode&#39;</span><span class="p">,</span> <span class="nx">axisEncode</span><span class="p">,</span> <span class="o">!!</span><span class="nx">axis</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">||</span> <span class="nx">axis</span><span class="p">.</span><span class="nx">labelAngle</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">axisComponent</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getProperty$1</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span> <span class="nx">specifiedAxis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="s1">&#39;scale&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">channel</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;gridScale&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">gridScale</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;format&#39;</span><span class="o">:</span>
              <span class="c1">// We don&#39;t include temporal field here as we apply format in encode block</span>
              <span class="k">return</span> <span class="nx">numberFormat</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">format</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;grid&#39;</span><span class="o">:</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">grid</span><span class="p">,</span> <span class="nx">grid</span><span class="p">(</span><span class="nx">scaleType</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">case</span> <span class="s1">&#39;labelFlush&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">labelFlush</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">specifiedAxis</span><span class="p">);</span>
          <span class="k">case</span> <span class="s1">&#39;labelOverlap&#39;</span><span class="o">:</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="k">return</span> <span class="nx">labelOverlap</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">specifiedAxis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">case</span> <span class="s1">&#39;orient&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">orient</span><span class="p">,</span> <span class="nx">orient</span><span class="p">(</span><span class="nx">channel</span><span class="p">));</span>
          <span class="k">case</span> <span class="s1">&#39;tickCount&#39;</span><span class="o">:</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">channel</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">sizeType</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span> <span class="o">?</span> <span class="s1">&#39;height&#39;</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">sizeType</span> <span class="o">?</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="nx">sizeType</span><span class="p">)</span>
                  <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="k">return</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">tickCount</span><span class="p">,</span> <span class="nx">tickCount</span><span class="p">(</span><span class="nx">channel</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">scaleType</span><span class="p">,</span> <span class="nx">size</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">case</span> <span class="s1">&#39;title&#39;</span><span class="o">:</span>
              <span class="kd">var</span> <span class="nx">channel2</span> <span class="o">=</span> <span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span> <span class="o">?</span> <span class="s1">&#39;x2&#39;</span> <span class="o">:</span> <span class="s1">&#39;y2&#39;</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">fieldDef2</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">fieldDef</span><span class="p">(</span><span class="nx">channel2</span><span class="p">);</span>
              <span class="c1">// Keep undefined so we use default if title is unspecified.</span>
              <span class="c1">// For other falsy value, keep them so we will hide the title.</span>
              <span class="kd">var</span> <span class="nx">fieldDefTitle</span> <span class="o">=</span> <span class="nx">getFieldDefTitle</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">specifiedTitle</span> <span class="o">=</span> <span class="nx">fieldDefTitle</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">fieldDefTitle</span> <span class="o">:</span>
                  <span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">title</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">undefined</span> <span class="o">:</span> <span class="nx">specifiedAxis</span><span class="p">.</span><span class="nx">title</span><span class="p">;</span>
              <span class="k">return</span> <span class="nx">getSpecifiedOrDefaultValue</span><span class="p">(</span><span class="nx">specifiedTitle</span><span class="p">,</span> 
              <span class="c1">// If title not specified, store base parts of fieldDef (and fieldDef2 if exists)</span>
              <span class="nx">mergeTitleFieldDefs</span><span class="p">([</span><span class="nx">toFieldDefBase</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">)],</span> <span class="nx">fieldDef2</span> <span class="o">?</span> <span class="p">[</span><span class="nx">toFieldDefBase</span><span class="p">(</span><span class="nx">fieldDef2</span><span class="p">)]</span> <span class="o">:</span> <span class="p">[]));</span>
          <span class="k">case</span> <span class="s1">&#39;values&#39;</span><span class="o">:</span>
              <span class="k">return</span> <span class="nx">values$1</span><span class="p">(</span><span class="nx">specifiedAxis</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">fieldDef</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Otherwise, return specified property.</span>
      <span class="k">return</span> <span class="nx">isAxisProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">)</span> <span class="o">?</span> <span class="nx">specifiedAxis</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">normalizeMarkDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">mark</span><span class="p">)</span> <span class="o">:</span> <span class="p">{</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">mark</span> <span class="p">};</span>
      <span class="c1">// set orient, which can be overridden by rules as sometimes the specified orient is invalid.</span>
      <span class="kd">var</span> <span class="nx">specifiedOrient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span> <span class="o">||</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;orient&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span> <span class="o">=</span> <span class="nx">orient$1</span><span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">specifiedOrient</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedOrient</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">specifiedOrient</span> <span class="o">!==</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">orientOverridden</span><span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">,</span> <span class="nx">specifiedOrient</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="c1">// set opacity and filled if not specified in mark config</span>
      <span class="kd">var</span> <span class="nx">specifiedOpacity</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">:</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;opacity&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedOpacity</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">markDef</span><span class="p">.</span><span class="nx">opacity</span> <span class="o">=</span> <span class="nx">defaultOpacity</span><span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">specifiedFilled</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">filled</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedFilled</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">markDef</span><span class="p">.</span><span class="nx">filled</span> <span class="o">=</span> <span class="nx">filled</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">markDef</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defaultOpacity</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">POINT</span><span class="p">,</span> <span class="nx">TICK</span><span class="p">,</span> <span class="nx">CIRCLE</span><span class="p">,</span> <span class="nx">SQUARE</span><span class="p">],</span> <span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// point-based marks</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isAggregate</span><span class="p">(</span><span class="nx">encoding</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="mf">0.7</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">filled</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">filledConfig</span> <span class="o">=</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;filled&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">filledConfig</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">filledConfig</span> <span class="o">:</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="nx">POINT</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="nx">LINE</span> <span class="o">&amp;&amp;</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="nx">RULE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">orient$1</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">specifiedOrient</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">POINT</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">CIRCLE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">SQUARE</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">TEXT$1</span><span class="o">:</span>
          <span class="k">case</span> <span class="nx">RECT</span><span class="o">:</span>
              <span class="c1">// orient is meaningless for these marks.</span>
              <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">yIsRange</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">xIsRange</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">mark</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="nx">BAR</span><span class="o">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">yIsRange</span> <span class="o">||</span> <span class="nx">xIsRange</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// Ranged bar does not always have clear orientation, so we allow overriding</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedOrient</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">specifiedOrient</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// If y is range and x is non-range, non-bin Q, y is likely a prebinned field</span>
                  <span class="kd">var</span> <span class="nx">xDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">xIsRange</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">xDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">xDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">QUANTITATIVE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="c1">// If x is range and y is non-range, non-bin Q, x is likely a prebinned field</span>
                  <span class="kd">var</span> <span class="nx">yDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">yIsRange</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">yDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">yDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">QUANTITATIVE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">yDef</span><span class="p">.</span><span class="nx">bin</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="cm">/* tslint:disable */</span>
          <span class="k">case</span> <span class="nx">RULE</span><span class="o">:</span> <span class="c1">// intentionally fall through</span>
              <span class="c1">// return undefined for line segment rule and bar with both axis ranged</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">xIsRange</span> <span class="o">&amp;&amp;</span> <span class="nx">yIsRange</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="k">case</span> <span class="nx">AREA</span><span class="o">:</span> <span class="c1">// intentionally fall through</span>
              <span class="c1">// If there are range for both x and y, y (vertical) has higher precedence.</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">yIsRange</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">xIsRange</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="nx">RULE</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="k">case</span> <span class="nx">LINE</span><span class="o">:</span> <span class="c1">// intentional fall through</span>
          <span class="k">case</span> <span class="nx">TICK</span><span class="o">:</span> <span class="c1">// Tick is opposite to bar, line, area and never have ranged mark.</span>
              <span class="cm">/* tslint:enable */</span>
              <span class="kd">var</span> <span class="nx">xIsContinuous</span> <span class="o">=</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isContinuous</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
              <span class="kd">var</span> <span class="nx">yIsContinuous</span> <span class="o">=</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isContinuous</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">xIsContinuous</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">yIsContinuous</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="s1">&#39;tick&#39;</span> <span class="o">?</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">:</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">xIsContinuous</span> <span class="o">&amp;&amp;</span> <span class="nx">yIsContinuous</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="s1">&#39;tick&#39;</span> <span class="o">?</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">xIsContinuous</span> <span class="o">&amp;&amp;</span> <span class="nx">yIsContinuous</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">xDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// we can cast here since they are surely fieldDef</span>
                  <span class="kd">var</span> <span class="nx">yDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
                  <span class="kd">var</span> <span class="nx">xIsTemporal</span> <span class="o">=</span> <span class="nx">xDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">TEMPORAL</span><span class="p">;</span>
                  <span class="kd">var</span> <span class="nx">yIsTemporal</span> <span class="o">=</span> <span class="nx">yDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">TEMPORAL</span><span class="p">;</span>
                  <span class="c1">// temporal without timeUnit is considered continuous, but better serves as dimension</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">xIsTemporal</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">yIsTemporal</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="s1">&#39;tick&#39;</span> <span class="o">?</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">xIsTemporal</span> <span class="o">&amp;&amp;</span> <span class="nx">yIsTemporal</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="s1">&#39;tick&#39;</span> <span class="o">?</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">:</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="nx">yDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="s1">&#39;tick&#39;</span> <span class="o">?</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">:</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">yDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">mark</span> <span class="o">!==</span> <span class="s1">&#39;tick&#39;</span> <span class="o">?</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">:</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">specifiedOrient</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// When ambiguous, use user specified one.</span>
                      <span class="k">return</span> <span class="nx">specifiedOrient</span><span class="p">;</span>
                  <span class="p">}</span>
                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="nx">LINE</span> <span class="o">&amp;&amp;</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">order</span><span class="p">))</span> <span class="p">{</span>
                      <span class="c1">// Except for connected scatterplot, we should log warning for unclear orientation of QxQ plots.</span>
                      <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">unclearOrientContinuous</span><span class="p">(</span><span class="nx">mark</span><span class="p">));</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="c1">// For Discrete x Discrete case, return undefined.</span>
                  <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">unclearOrientDiscreteOrEmpty</span><span class="p">(</span><span class="nx">mark</span><span class="p">));</span>
                  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
              <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="s1">&#39;vertical&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">area</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;area&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;include&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">),</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="s1">&#39;x2&#39;</span> <span class="o">:</span> <span class="s1">&#39;y2&#39;</span><span class="p">),</span> <span class="nx">defined</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;rect&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">x</span><span class="p">(</span><span class="nx">model</span><span class="p">),</span> <span class="nx">y</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">x</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">sizeDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">xDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">x2Def</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">xScaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">X</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">xScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">X</span><span class="p">);</span>
      <span class="c1">// x, x2, and width -- we must specify two of these in all conditions</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">||</span> <span class="nx">x2Def</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">),</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// vertical</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">xDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">xScaleType</span> <span class="o">=</span> <span class="nx">xScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">xDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">sizeDef</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">xScaleType</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">binnedPosition</span><span class="p">(</span><span class="nx">xDef</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">binSpacing</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">config</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">binSpacing</span> <span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">binSpacing</span><span class="p">,</span> <span class="nx">xScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;reverse&#39;</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="p">{</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">xScaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span><span class="p">)</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="nx">bandPosition</span><span class="p">(</span><span class="nx">xDef</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="c1">// sized bin, normal point-ordinal axis, quantitative x-axis, or no x</span>
          <span class="k">return</span> <span class="nx">centeredBandPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">defaultSizeRef</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">xScaleName</span><span class="p">,</span> <span class="nx">xScale</span><span class="p">,</span> <span class="nx">config</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">y</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">sizeDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">yDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">y2Def</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">yScaleName</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="nx">Y</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">yScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">Y</span><span class="p">);</span>
      <span class="c1">// y, y2 &amp; height -- we must specify two of these in all conditions</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">||</span> <span class="nx">y2Def</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">),</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">yDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">yScaleType</span> <span class="o">=</span> <span class="nx">yScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">yDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">sizeDef</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">yScaleType</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">binnedPosition</span><span class="p">(</span><span class="nx">yDef</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">binSpacing</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">config</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">binSpacing</span> <span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">binSpacing</span><span class="p">,</span> <span class="nx">yScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;reverse&#39;</span><span class="p">));</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">yScaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">bandPosition</span><span class="p">(</span><span class="nx">yDef</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">centeredBandPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">),</span> <span class="nx">defaultSizeRef</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">yScaleName</span><span class="p">,</span> <span class="nx">yScale</span><span class="p">,</span> <span class="nx">config</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">defaultSizeRef</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">scaleName</span><span class="p">,</span> <span class="nx">scale</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">discreteBandSize</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">discreteBandSize</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">scale</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scaleType</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">POINT</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">scaleRange</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">scaleRange</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumber</span><span class="p">(</span><span class="nx">scaleRange</span><span class="p">.</span><span class="nx">step</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">scaleRange</span><span class="p">.</span><span class="nx">step</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">};</span>
              <span class="p">}</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">scaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">bandRef</span><span class="p">(</span><span class="nx">scaleName</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span> <span class="c1">// non-ordinal scale</span>
              <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">continuousBandSize</span> <span class="p">};</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span> <span class="o">&amp;&amp;</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">20</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">geoshape</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}));</span>
      <span class="p">},</span>
      <span class="nx">postEncodingTransform</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">shapeDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">shape</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;geoshape&#39;</span><span class="p">,</span> <span class="nx">projection</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">projectionName</span><span class="p">()</span> <span class="p">},</span> <span class="p">(</span><span class="nx">shapeDef</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">shapeDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">shapeDef</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">GEOJSON</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">vgField</span><span class="p">(</span><span class="nx">shapeDef</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">})</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
          <span class="k">return</span> <span class="p">[</span><span class="nx">transform</span><span class="p">];</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">line</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">)),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">vgChannel</span><span class="o">:</span> <span class="s1">&#39;strokeWidth&#39;</span> <span class="c1">// VL&#39;s line size is strokeWidth</span>
          <span class="p">}),</span> <span class="nx">defined</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">trail</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;trail&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;include&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">)),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">),</span> <span class="nx">defined</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">encodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">fixedShape</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;include&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">)),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">),</span> <span class="nx">shapeMixins</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fixedShape</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">shapeMixins</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fixedShape</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fixedShape</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="nx">shape</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">fixedShape</span> <span class="p">}</span> <span class="p">};</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;symbol&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">encodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">circle</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;symbol&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">encodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;circle&#39;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">square</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;symbol&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">encodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;square&#39;</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">rect</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;rect&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">x$1</span><span class="p">(</span><span class="nx">model</span><span class="p">),</span> <span class="nx">y$1</span><span class="p">(</span><span class="nx">model</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">x$1</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">xDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">x2Def</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">xScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">X</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">xScaleType</span> <span class="o">=</span> <span class="nx">xScale</span> <span class="o">?</span> <span class="nx">xScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">xDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">xDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">x2Def</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">binnedPosition</span><span class="p">(</span><span class="nx">xDef</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">xScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;reverse&#39;</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">xDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">xScale</span> <span class="o">&amp;&amp;</span> <span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">xScaleType</span><span class="p">))</span> <span class="p">{</span>
          <span class="cm">/* istanbul ignore else */</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">xScaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">bandPosition</span><span class="p">(</span><span class="nx">xDef</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// We don&#39;t support rect mark with point/ordinal scale</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithMark</span><span class="p">(</span><span class="nx">RECT</span><span class="p">,</span> <span class="nx">xScaleType</span><span class="p">));</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// continuous scale or no scale</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMax&#39;</span><span class="p">),</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">y$1</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">yDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">y2Def</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">yScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">Y</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">yScaleType</span> <span class="o">=</span> <span class="nx">yScale</span> <span class="o">?</span> <span class="nx">yScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">yDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">yDef</span><span class="p">.</span><span class="nx">bin</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">y2Def</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">binnedPosition</span><span class="p">(</span><span class="nx">yDef</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">scaleName</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">yScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;reverse&#39;</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">yDef</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">yScale</span> <span class="o">&amp;&amp;</span> <span class="nx">hasDiscreteDomain</span><span class="p">(</span><span class="nx">yScaleType</span><span class="p">))</span> <span class="p">{</span>
          <span class="cm">/* istanbul ignore else */</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">yScaleType</span> <span class="o">===</span> <span class="nx">ScaleType</span><span class="p">.</span><span class="nx">BAND</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">bandPosition</span><span class="p">(</span><span class="nx">yDef</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// We don&#39;t support rect mark with point/ordinal scale</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">scaleTypeNotWorkWithMark</span><span class="p">(</span><span class="nx">RECT</span><span class="p">,</span> <span class="nx">yScaleType</span><span class="p">));</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span> <span class="c1">// continuous scale or no scale</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMax&#39;</span><span class="p">),</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMin&#39;</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span><span class="p">));</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">rule</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;rule&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">latitude</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">longitude</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Show nothing if we have none of x, y, lat, and long.</span>
              <span class="k">return</span> <span class="p">{};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="s1">&#39;zeroOrMin&#39;</span> <span class="o">:</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">?</span> <span class="s1">&#39;zeroOrMin&#39;</span> <span class="o">:</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">)),</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">!==</span> <span class="s1">&#39;vertical&#39;</span> <span class="o">?</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMax&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">orient</span> <span class="o">!==</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="nx">pointPosition2</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="s1">&#39;zeroOrMax&#39;</span><span class="p">,</span> <span class="s1">&#39;y2&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">vgChannel</span><span class="o">:</span> <span class="s1">&#39;strokeWidth&#39;</span><span class="p">,</span>
              <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span>
          <span class="p">}));</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">text$3</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;text&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">)),</span> <span class="nx">text$2</span><span class="p">(</span><span class="nx">model</span><span class="p">),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">vgChannel</span><span class="o">:</span> <span class="s1">&#39;fontSize&#39;</span> <span class="c1">// VL&#39;s text size is fontSize</span>
           <span class="p">})),</span> <span class="nx">valueIfDefined</span><span class="p">(</span><span class="s1">&#39;align&#39;</span><span class="p">,</span> <span class="nx">align</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span><span class="p">)));</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">align</span><span class="p">(</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">align</span> <span class="o">||</span> <span class="nx">getMarkConfig</span><span class="p">(</span><span class="s1">&#39;align&#39;</span><span class="p">,</span> <span class="nx">markDef</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;center&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// If there is a config, Vega-parser will process this already.</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">tick</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">vgMark</span><span class="o">:</span> <span class="s1">&#39;rect&#39;</span><span class="p">,</span>
      <span class="nx">encodeEntry</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">vgSizeChannel</span> <span class="o">=</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="s1">&#39;width&#39;</span> <span class="o">:</span> <span class="s1">&#39;height&#39;</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">vgThicknessChannel</span> <span class="o">=</span> <span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="s1">&#39;height&#39;</span> <span class="o">:</span> <span class="s1">&#39;width&#39;</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">baseEncodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span> <span class="nx">size</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="nx">orient</span><span class="o">:</span> <span class="s1">&#39;ignore&#39;</span> <span class="p">}),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">width</span><span class="p">),</span> <span class="s1">&#39;xc&#39;</span><span class="p">),</span> <span class="nx">pointPosition</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">mid</span><span class="p">(</span><span class="nx">height</span><span class="p">),</span> <span class="s1">&#39;yc&#39;</span><span class="p">),</span> <span class="nx">nonPosition</span><span class="p">(</span><span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="nx">model</span><span class="p">,</span> <span class="p">{</span>
              <span class="nx">defaultValue</span><span class="o">:</span> <span class="nx">defaultSize</span><span class="p">(</span><span class="nx">model</span><span class="p">),</span>
              <span class="nx">vgChannel</span><span class="o">:</span> <span class="nx">vgSizeChannel</span>
          <span class="p">}),</span> <span class="p">(</span><span class="nx">_a</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">vgThicknessChannel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">thickness</span> <span class="o">||</span> <span class="nx">config</span><span class="p">.</span><span class="nx">tick</span><span class="p">.</span><span class="nx">thickness</span> <span class="p">},</span> <span class="nx">_a</span><span class="p">));</span>
          <span class="kd">var</span> <span class="nx">_a</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">defaultSize</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">orient</span> <span class="o">=</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="s1">&#39;x&#39;</span> <span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">markDef</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">tick</span><span class="p">.</span><span class="nx">bandSize</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nx">tick</span><span class="p">.</span><span class="nx">bandSize</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scaleRange</span> <span class="o">=</span> <span class="nx">scale</span> <span class="o">?</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">rangeStep</span> <span class="o">=</span> <span class="nx">scaleRange</span> <span class="o">&amp;&amp;</span> <span class="nx">isVgRangeStep</span><span class="p">(</span><span class="nx">scaleRange</span><span class="p">)</span> <span class="o">?</span>
              <span class="nx">scaleRange</span><span class="p">.</span><span class="nx">step</span> <span class="o">:</span>
              <span class="nx">config</span><span class="p">.</span><span class="nx">scale</span><span class="p">.</span><span class="nx">rangeStep</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">rangeStep</span> <span class="o">!==</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// FIXME consolidate this log</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Function does not handle non-numeric rangeStep&#39;</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">rangeStep</span> <span class="o">/</span> <span class="mf">1.5</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">markCompiler</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">area</span><span class="o">:</span> <span class="nx">area</span><span class="p">,</span>
      <span class="nx">bar</span><span class="o">:</span> <span class="nx">bar</span><span class="p">,</span>
      <span class="nx">circle</span><span class="o">:</span> <span class="nx">circle</span><span class="p">,</span>
      <span class="nx">geoshape</span><span class="o">:</span> <span class="nx">geoshape</span><span class="p">,</span>
      <span class="nx">line</span><span class="o">:</span> <span class="nx">line</span><span class="p">,</span>
      <span class="nx">point</span><span class="o">:</span> <span class="nx">point</span><span class="p">,</span>
      <span class="nx">rect</span><span class="o">:</span> <span class="nx">rect</span><span class="p">,</span>
      <span class="nx">rule</span><span class="o">:</span> <span class="nx">rule</span><span class="p">,</span>
      <span class="nx">square</span><span class="o">:</span> <span class="nx">square</span><span class="p">,</span>
      <span class="nx">text</span><span class="o">:</span> <span class="nx">text$3</span><span class="p">,</span>
      <span class="nx">tick</span><span class="o">:</span> <span class="nx">tick</span><span class="p">,</span>
      <span class="nx">trail</span><span class="o">:</span> <span class="nx">trail</span>
  <span class="p">};</span>
  <span class="kd">function</span> <span class="nx">parseMarkGroup</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">contains</span><span class="p">([</span><span class="nx">LINE</span><span class="p">,</span> <span class="nx">AREA</span><span class="p">,</span> <span class="nx">TRAIL</span><span class="p">],</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">parsePathMark</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">getMarkGroups</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">FACETED_PATH_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;faceted_path_&#39;</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">parsePathMark</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">details</span> <span class="o">=</span> <span class="nx">pathGroupingFields</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">pathMarks</span> <span class="o">=</span> <span class="nx">getMarkGroups</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="p">{</span>
          <span class="c1">// If has subfacet for line/area group, need to use faceted data from below.</span>
          <span class="nx">fromPrefix</span><span class="o">:</span> <span class="p">(</span><span class="nx">details</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nx">FACETED_PATH_PREFIX</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
      <span class="p">});</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">details</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// have level of details - need to facet line into subgroups</span>
          <span class="c1">// TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)</span>
          <span class="k">return</span> <span class="p">[{</span>
                  <span class="nx">name</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;pathgroup&#39;</span><span class="p">),</span>
                  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span>
                  <span class="nx">from</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">facet</span><span class="o">:</span> <span class="p">{</span>
                          <span class="nx">name</span><span class="o">:</span> <span class="nx">FACETED_PATH_PREFIX</span> <span class="o">+</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">),</span>
                          <span class="nx">data</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">),</span>
                          <span class="nx">groupby</span><span class="o">:</span> <span class="nx">details</span><span class="p">,</span>
                      <span class="p">}</span>
                  <span class="p">},</span>
                  <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                      <span class="nx">update</span><span class="o">:</span> <span class="p">{</span>
                          <span class="nx">width</span><span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;width&#39;</span> <span class="p">}</span> <span class="p">},</span>
                          <span class="nx">height</span><span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="p">{</span> <span class="nx">group</span><span class="o">:</span> <span class="s1">&#39;height&#39;</span> <span class="p">}</span> <span class="p">}</span>
                      <span class="p">}</span>
                  <span class="p">},</span>
                  <span class="nx">marks</span><span class="o">:</span> <span class="nx">pathMarks</span>
              <span class="p">}];</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">pathMarks</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getSort</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">stack</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">markDef</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">order</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">.</span><span class="nx">order</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">order</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isValueDef</span><span class="p">(</span><span class="nx">order</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">order</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">order</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">stack</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)</span>
          <span class="k">return</span> <span class="nx">sortParams</span><span class="p">(</span><span class="nx">order</span><span class="p">,</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">});</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isPathMark</span><span class="p">(</span><span class="nx">mark</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// For both line and area, we sort values based on dimension by default</span>
          <span class="kd">var</span> <span class="nx">dimensionChannelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">orient</span> <span class="o">===</span> <span class="s1">&#39;horizontal&#39;</span> <span class="o">?</span> <span class="s1">&#39;y&#39;</span> <span class="o">:</span> <span class="s1">&#39;x&#39;</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">dimensionChannelDef</span><span class="p">))</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">dimensionChannelDef</span><span class="p">.</span><span class="nx">sort</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">sortField</span> <span class="o">=</span> <span class="nx">isSortField</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">?</span>
                  <span class="nx">vgField</span><span class="p">({</span>
                      <span class="c1">// FIXME: this op might not already exist?</span>
                      <span class="c1">// FIXME: what if dimensionChannel (x or y) contains custom domain?</span>
                      <span class="nx">aggregate</span><span class="o">:</span> <span class="nx">isAggregate</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">)</span> <span class="o">?</span> <span class="nx">s</span><span class="p">.</span><span class="nx">op</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
                      <span class="nx">field</span><span class="o">:</span> <span class="nx">s</span><span class="p">.</span><span class="nx">field</span>
                  <span class="p">},</span> <span class="p">{</span> <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span> <span class="p">})</span> <span class="o">:</span>
                  <span class="nx">vgField</span><span class="p">(</span><span class="nx">dimensionChannelDef</span><span class="p">,</span> <span class="p">{</span>
                      <span class="c1">// For stack with imputation, we only have bin_mid</span>
                      <span class="nx">binSuffix</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span> <span class="o">&amp;&amp;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">impute</span> <span class="o">?</span> <span class="s1">&#39;mid&#39;</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
                      <span class="nx">expr</span><span class="o">:</span> <span class="s1">&#39;datum&#39;</span>
                  <span class="p">});</span>
              <span class="k">return</span> <span class="p">{</span>
                  <span class="nx">field</span><span class="o">:</span> <span class="nx">sortField</span><span class="p">,</span>
                  <span class="nx">order</span><span class="o">:</span> <span class="s1">&#39;descending&#39;</span>
              <span class="p">};</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getMarkGroups</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">fromPrefix</span><span class="o">:</span> <span class="s1">&#39;&#39;</span> <span class="p">};</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">clip</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">clip</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span>
          <span class="o">!!</span><span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">clip</span> <span class="o">:</span> <span class="nx">scaleClip</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">style</span> <span class="o">=</span> <span class="nx">getStyles</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">markDef</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">key$$1</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">key</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">sort</span> <span class="o">=</span> <span class="nx">getSort</span><span class="p">(</span><span class="nx">model</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">postEncodingTransform</span> <span class="o">=</span> <span class="nx">markCompiler</span><span class="p">[</span><span class="nx">mark</span><span class="p">].</span><span class="nx">postEncodingTransform</span> <span class="o">?</span> <span class="nx">markCompiler</span><span class="p">[</span><span class="nx">mark</span><span class="p">].</span><span class="nx">postEncodingTransform</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="o">:</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">__assign</span><span class="p">({</span> <span class="nx">name</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;marks&#39;</span><span class="p">),</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">markCompiler</span><span class="p">[</span><span class="nx">mark</span><span class="p">].</span><span class="nx">vgMark</span> <span class="p">},</span> <span class="p">(</span><span class="nx">clip</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">clip</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">style</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">style</span><span class="o">:</span> <span class="nx">style</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">key$$1</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">key</span><span class="o">:</span> <span class="p">{</span> <span class="nx">field</span><span class="o">:</span> <span class="nx">key$$1</span><span class="p">.</span><span class="nx">field</span> <span class="p">}</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">sort</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">sort</span><span class="o">:</span> <span class="nx">sort</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">from</span><span class="o">:</span> <span class="p">{</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">fromPrefix</span> <span class="o">+</span> <span class="nx">model</span><span class="p">.</span><span class="nx">requestDataName</span><span class="p">(</span><span class="nx">MAIN</span><span class="p">)</span> <span class="p">},</span> <span class="nx">encode</span><span class="o">:</span> <span class="p">{</span>
                  <span class="nx">update</span><span class="o">:</span> <span class="nx">markCompiler</span><span class="p">[</span><span class="nx">mark</span><span class="p">].</span><span class="nx">encodeEntry</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span>
              <span class="p">}</span> <span class="p">},</span> <span class="p">(</span><span class="nx">postEncodingTransform</span> <span class="o">?</span> <span class="p">{</span>
              <span class="nx">transform</span><span class="o">:</span> <span class="nx">postEncodingTransform</span>
          <span class="p">}</span> <span class="o">:</span> <span class="p">{}))];</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * Returns list of path grouping fields</span>
<span class="cm">   * that the model&#39;s spec contains.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">pathGroupingFields</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">encoding</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">details</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">switch</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group</span>
              <span class="k">case</span> <span class="s1">&#39;x&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;y&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;order&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;tooltip&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;href&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;x2&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;y2&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;latitude&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;longitude&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;latitude2&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;longitude2&#39;</span><span class="o">:</span>
              <span class="c1">// TODO: case &#39;cursor&#39;:</span>
              <span class="c1">// text, shape, shouldn&#39;t be a part of line/trail/area</span>
              <span class="k">case</span> <span class="s1">&#39;text&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;shape&#39;</span><span class="o">:</span>
                  <span class="k">return</span> <span class="nx">details</span><span class="p">;</span>
              <span class="k">case</span> <span class="s1">&#39;detail&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;key&#39;</span><span class="o">:</span>
                  <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
                      <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span> <span class="o">:</span> <span class="p">[</span><span class="nx">channelDef</span><span class="p">]).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                              <span class="nx">details</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{}));</span>
                          <span class="p">}</span>
                      <span class="p">});</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="nx">details</span><span class="p">;</span>
              <span class="k">case</span> <span class="s1">&#39;size&#39;</span><span class="o">:</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="s1">&#39;trail&#39;</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// For trail, size should not group trail lines.</span>
                      <span class="k">return</span> <span class="nx">details</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="c1">// For line, it should group lines.</span>
              <span class="cm">/* tslint:disable */</span>
              <span class="c1">// intentional fall through</span>
              <span class="k">case</span> <span class="s1">&#39;color&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;fill&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;stroke&#39;</span><span class="o">:</span>
              <span class="k">case</span> <span class="s1">&#39;opacity&#39;</span><span class="o">:</span>
                  <span class="c1">// TODO strokeDashOffset:</span>
                  <span class="cm">/* tslint:enable */</span>
                  <span class="kd">var</span> <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">fieldDef</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">details</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">vgField</span><span class="p">(</span><span class="nx">fieldDef</span><span class="p">,</span> <span class="p">{}));</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="nx">details</span><span class="p">;</span>
              <span class="k">default</span><span class="o">:</span>
                  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Bug: Channel &quot;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span> <span class="s2">&quot; unimplemented for line mark&quot;</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">},</span> <span class="p">[]);</span>
  <span class="p">}</span>
  <span class="cm">/**</span>
<span class="cm">   * If scales are bound to interval selections, we want to automatically clip</span>
<span class="cm">   * marks to account for panning/zooming interactions. We identify bound scales</span>
<span class="cm">   * by the domainRaw property, which gets added during scale parsing.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">scaleClip</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">xScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">yScale</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">getScaleComponent</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="nx">xScale</span> <span class="o">&amp;&amp;</span> <span class="nx">xScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">))</span> <span class="o">||</span>
          <span class="p">(</span><span class="nx">yScale</span> <span class="o">&amp;&amp;</span> <span class="nx">yScale</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;domainRaw&#39;</span><span class="p">))</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Internal model of Vega-Lite specification for the compiler.</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">UnitModel</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">UnitModel</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">UnitModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">parentGivenSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">parentGivenSize</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">parentGivenSize</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">fit</span> <span class="o">=</span> <span class="nx">fit</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;unit&#39;</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedScales</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedAxes</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedLegends</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedProjection</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">selection</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">initSize</span><span class="p">(</span><span class="nx">__assign</span><span class="p">({},</span> <span class="nx">parentGivenSize</span><span class="p">,</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">width</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">width</span><span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">width</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">height</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">height</span><span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">height</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{})));</span>
          <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">=</span> <span class="nx">normalizeEncoding</span><span class="p">(</span><span class="nx">replaceRepeaterInEncoding</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">||</span> <span class="p">{},</span> <span class="nx">repeater</span><span class="p">),</span> <span class="nx">mark</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">markDef</span> <span class="o">=</span> <span class="nx">normalizeMarkDef</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="c1">// calculate stack properties</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">stack</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedScales</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">initScales</span><span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedAxes</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">initAxes</span><span class="p">(</span><span class="nx">encoding</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedLegends</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">initLegend</span><span class="p">(</span><span class="nx">encoding</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">specifiedProjection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">projection</span><span class="p">;</span>
          <span class="c1">// Selections will be initialized upon parse.</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">selection</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">selection</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;hasProjection&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">isGeoShapeMark</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">mark</span> <span class="o">===</span> <span class="nx">GEOSHAPE</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">hasGeoPosition</span> <span class="o">=</span> <span class="nx">encoding</span> <span class="o">&amp;&amp;</span> <span class="nx">GEOPOSITION_CHANNELS</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">]);</span> <span class="p">});</span>
              <span class="k">return</span> <span class="nx">isGeoShapeMark</span> <span class="o">||</span> <span class="nx">hasGeoPosition</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="cm">/**</span>
<span class="cm">       * Return specified Vega-lite scale domain for a particular channel</span>
<span class="cm">       * @param channel</span>
<span class="cm">       */</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">scaleDomain</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">scale</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">specifiedScales</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">return</span> <span class="nx">scale</span> <span class="o">?</span> <span class="nx">scale</span><span class="p">.</span><span class="nx">domain</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">axis</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">specifiedAxes</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">legend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">specifiedLegends</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">initScales</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">mark</span><span class="p">,</span> <span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">SCALE_CHANNELS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">scales</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">fieldDef</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">specifiedScale</span><span class="p">;</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">;</span>
                  <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">scale</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="p">{</span>
                  <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">;</span>
                  <span class="nx">specifiedScale</span> <span class="o">=</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">fieldDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">scales</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">specifiedScale</span> <span class="o">||</span> <span class="p">{};</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">scales</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">initAxes</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[</span><span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span><span class="p">].</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_axis</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Position Axis</span>
              <span class="c1">// TODO: handle ConditionFieldDef</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">||</span>
                  <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">X</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x2</span><span class="p">))</span> <span class="o">||</span>
                  <span class="p">(</span><span class="nx">channel</span> <span class="o">===</span> <span class="nx">Y</span> <span class="o">&amp;&amp;</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y2</span><span class="p">)))</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">axisSpec</span> <span class="o">=</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">axis</span> <span class="o">:</span> <span class="kc">null</span><span class="p">;</span>
                  <span class="c1">// We no longer support false in the schema, but we keep false here for backward compatibility.</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">axisSpec</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">axisSpec</span> <span class="o">!==</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">_axis</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">axisSpec</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">_axis</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">initLegend</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">NONPOSITION_SCALE_CHANNELS</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_legend</span><span class="p">,</span> <span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">legend</span> <span class="o">=</span> <span class="nx">isFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">)</span> <span class="o">?</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">legend</span> <span class="o">:</span>
                      <span class="p">(</span><span class="nx">hasConditionalFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">))</span> <span class="o">?</span> <span class="nx">channelDef</span><span class="p">.</span><span class="nx">condition</span><span class="p">[</span><span class="s1">&#39;legend&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="kc">null</span><span class="p">;</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">legend</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">legend</span> <span class="o">!==</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
                      <span class="nx">_legend</span><span class="p">[</span><span class="nx">channel</span><span class="p">]</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">legend</span><span class="p">);</span>
                  <span class="p">}</span>
              <span class="p">}</span>
              <span class="k">return</span> <span class="nx">_legend</span><span class="p">;</span>
          <span class="p">},</span> <span class="p">{});</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">parseData</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseUnitLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseSelection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span> <span class="o">=</span> <span class="nx">parseUnitSelection</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">selection</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseMarkGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">mark</span> <span class="o">=</span> <span class="nx">parseMarkGroup</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">axes</span> <span class="o">=</span> <span class="nx">parseUnitAxis</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleTopLevelSignals</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">signals</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleUnitSelectionSignals</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">[]);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleUnitSelectionData</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleLayoutSignals</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleMarks</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">marks</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">mark</span> <span class="o">||</span> <span class="p">[];</span>
          <span class="c1">// If this unit is part of a layer, selections should augment</span>
          <span class="c1">// all in concert rather than each unit individually. This</span>
          <span class="c1">// ensures correct interleaving of clipping and brushed marks.</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">||</span> <span class="o">!</span><span class="nx">isLayerModel</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">marks</span> <span class="o">=</span> <span class="nx">assembleUnitSelectionMarks</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">marks</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">marks</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">correctDataNames</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">width</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">),</span>
              <span class="nx">height</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getSizeSignalRef</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getMapping</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toSpec</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">excludeConfig</span><span class="p">,</span> <span class="nx">excludeData</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">encoding</span><span class="p">);</span>
          <span class="kd">var</span> <span class="nx">spec</span><span class="p">;</span>
          <span class="nx">spec</span> <span class="o">=</span> <span class="p">{</span>
              <span class="nx">mark</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">markDef</span><span class="p">,</span>
              <span class="nx">encoding</span><span class="o">:</span> <span class="nx">encoding</span>
          <span class="p">};</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">excludeConfig</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">spec</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">excludeData</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">spec</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">duplicate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="c1">// remove defaults</span>
          <span class="k">return</span> <span class="nx">spec</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&quot;mark&quot;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">markDef</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
      <span class="p">});</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">channelHasField</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">channelHasField</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">encoding</span><span class="p">,</span> <span class="nx">channel</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">UnitModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">fieldDef</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">channelDef</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">encoding</span><span class="p">[</span><span class="nx">channel</span><span class="p">];</span>
          <span class="k">return</span> <span class="nx">getFieldDef</span><span class="p">(</span><span class="nx">channelDef</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">UnitModel</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">ModelWithField</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">LayerModel</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">LayerModel</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">LayerModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">parentGivenSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;layer&#39;</span><span class="p">;</span>
          <span class="kd">var</span> <span class="nx">layoutSize</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({},</span> <span class="nx">parentGivenSize</span><span class="p">,</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">width</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">width</span><span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">width</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">height</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">height</span><span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">height</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">initSize</span><span class="p">(</span><span class="nx">layoutSize</span><span class="p">);</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">layer</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">layer</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">layer</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="k">new</span> <span class="nx">LayerModel</span><span class="p">(</span><span class="nx">layer</span><span class="p">,</span> <span class="nx">_this</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;layer_&#39;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">),</span> <span class="nx">layoutSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitSpec</span><span class="p">(</span><span class="nx">layer</span><span class="p">))</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="k">new</span> <span class="nx">UnitModel</span><span class="p">(</span><span class="nx">layer</span><span class="p">,</span> <span class="nx">_this</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;layer_&#39;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">),</span> <span class="nx">layoutSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">);</span>
              <span class="p">}</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">INVALID_SPEC</span><span class="p">);</span>
          <span class="p">});</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">parseData</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseData</span><span class="p">();</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseLayerLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseSelection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
          <span class="c1">// Merge selections up the hierarchy so that they may be referenced</span>
          <span class="c1">// across unit specs. Persist their definitions within each child</span>
          <span class="c1">// to assemble signals which remain within output Vega unit groups.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span> <span class="o">=</span> <span class="p">{};</span>
          <span class="kd">var</span> <span class="nx">_loop_1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseSelection</span><span class="p">();</span>
              <span class="nx">keys</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">_this</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">selection</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
              <span class="p">});</span>
          <span class="p">};</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">_loop_1</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseMarkGroup</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">child</span><span class="p">.</span><span class="nx">parseMarkGroup</span><span class="p">();</span>
          <span class="p">}</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseAxisAndHeader</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseLayerAxis</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sg</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span><span class="p">(</span><span class="nx">sg</span><span class="p">);</span> <span class="p">},</span> <span class="nx">signals</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="c1">// TODO: Support same named selections across children.</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionSignals</span><span class="p">());</span>
          <span class="p">},</span> <span class="p">[]);</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span><span class="p">());</span>
          <span class="p">},</span> <span class="nx">assembleLayoutSignals</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleSelectionData</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleSelectionData</span><span class="p">(</span><span class="nx">db</span><span class="p">);</span> <span class="p">},</span> <span class="nx">data</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleTitle</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleTitle</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">title</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// If title does not provide layer, look into children</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">_a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="nx">title</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleTitle</span><span class="p">();</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="nx">title</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleMarks</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">assembleLayerSelectionMarks</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">flatten</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nx">assembleMarks</span><span class="p">();</span>
          <span class="p">})));</span>
      <span class="p">};</span>
      <span class="nx">LayerModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLegends</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">legends</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">legends</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">assembleLegends</span><span class="p">());</span>
          <span class="p">},</span> <span class="nx">assembleLegends</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">LayerModel</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">Model</span><span class="p">));</span>

  <span class="kd">var</span> <span class="nx">RepeatModel</span> <span class="o">=</span> <span class="cm">/** @class */</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_super</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">__extends</span><span class="p">(</span><span class="nx">RepeatModel</span><span class="p">,</span> <span class="nx">_super</span><span class="p">);</span>
      <span class="kd">function</span> <span class="nx">RepeatModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">repeatValues</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">repeatValues</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;repeat&#39;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">&amp;&amp;</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">.</span><span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span> <span class="o">||</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">resolve</span><span class="p">.</span><span class="nx">axis</span><span class="p">.</span><span class="nx">y</span> <span class="o">===</span> <span class="s1">&#39;shared&#39;</span><span class="p">))</span> <span class="p">{</span>
              <span class="nx">warn</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">REPEAT_CANNOT_SHARE_AXIS</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">repeat</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">repeat</span><span class="p">;</span>
          <span class="nx">_this</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">_initChildren</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">_this</span><span class="p">.</span><span class="nx">repeat</span><span class="p">,</span> <span class="nx">repeatValues</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">RepeatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_initChildren</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">repeat</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
          <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">repeat</span><span class="p">.</span><span class="nx">row</span> <span class="o">||</span> <span class="p">[</span><span class="nx">repeater</span> <span class="o">?</span> <span class="nx">repeater</span><span class="p">.</span><span class="nx">row</span> <span class="o">:</span> <span class="kc">null</span><span class="p">];</span>
          <span class="kd">var</span> <span class="nx">column</span> <span class="o">=</span> <span class="nx">repeat</span><span class="p">.</span><span class="nx">column</span> <span class="o">||</span> <span class="p">[</span><span class="nx">repeater</span> <span class="o">?</span> <span class="nx">repeater</span><span class="p">.</span><span class="nx">column</span> <span class="o">:</span> <span class="kc">null</span><span class="p">];</span>
          <span class="c1">// cross product</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">row_1</span> <span class="o">=</span> <span class="nx">row</span><span class="p">;</span> <span class="nx">_i</span> <span class="o">&lt;</span> <span class="nx">row_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="kd">var</span> <span class="nx">rowField</span> <span class="o">=</span> <span class="nx">row_1</span><span class="p">[</span><span class="nx">_i</span><span class="p">];</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">column_1</span> <span class="o">=</span> <span class="nx">column</span><span class="p">;</span> <span class="nx">_a</span> <span class="o">&lt;</span> <span class="nx">column_1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">_a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                  <span class="kd">var</span> <span class="nx">columnField</span> <span class="o">=</span> <span class="nx">column_1</span><span class="p">[</span><span class="nx">_a</span><span class="p">];</span>
                  <span class="kd">var</span> <span class="nx">name_1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">rowField</span> <span class="o">?</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nx">rowField</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">columnField</span> <span class="o">?</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nx">columnField</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
                  <span class="kd">var</span> <span class="nx">childRepeat</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="nx">row</span><span class="o">:</span> <span class="nx">rowField</span><span class="p">,</span>
                      <span class="nx">column</span><span class="o">:</span> <span class="nx">columnField</span>
                  <span class="p">};</span>
                  <span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">buildModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">spec</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="s1">&#39;child&#39;</span> <span class="o">+</span> <span class="nx">name_1</span><span class="p">),</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">childRepeat</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="kc">false</span><span class="p">));</span>
              <span class="p">}</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">children</span><span class="p">;</span>
      <span class="p">};</span>
      <span class="nx">RepeatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">parseLayoutSize</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="nx">parseRepeatLayoutSize</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">};</span>
      <span class="nx">RepeatModel</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">assembleLayout</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// TODO: allow customization</span>
          <span class="k">return</span> <span class="p">{</span>
              <span class="nx">padding</span><span class="o">:</span> <span class="p">{</span> <span class="nx">row</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">column</span><span class="o">:</span> <span class="mi">10</span> <span class="p">},</span>
              <span class="nx">offset</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
              <span class="nx">columns</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">repeat</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">repeat</span><span class="p">.</span><span class="nx">column</span> <span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="nx">repeat</span><span class="p">.</span><span class="nx">column</span><span class="p">.</span><span class="nx">length</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
              <span class="nx">bounds</span><span class="o">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
              <span class="nx">align</span><span class="o">:</span> <span class="s1">&#39;all&#39;</span>
          <span class="p">};</span>
      <span class="p">};</span>
      <span class="k">return</span> <span class="nx">RepeatModel</span><span class="p">;</span>
  <span class="p">}(</span><span class="nx">BaseConcatModel</span><span class="p">));</span>

  <span class="kd">function</span> <span class="nx">buildModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">unitSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isFacetSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">FacetModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">LayerModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">unitSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isUnitSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">UnitModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">unitSize</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">fit</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isRepeatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">RepeatModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isConcatSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nx">ConcatModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">parentGivenName</span><span class="p">,</span> <span class="nx">repeater</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">INVALID_SPEC</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Vega-Lite&#39;s main function, for compiling Vega-lite spec into Vega spec.</span>
<span class="cm">   *</span>
<span class="cm">   * At a high-level, we make the following transformations in different phases:</span>
<span class="cm">   *</span>
<span class="cm">   * Input spec</span>
<span class="cm">   *     |</span>
<span class="cm">   *     |  (Normalization)</span>
<span class="cm">   *     v</span>
<span class="cm">   * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)</span>
<span class="cm">   *     |</span>
<span class="cm">   *     |  (Build Model)</span>
<span class="cm">   *     v</span>
<span class="cm">   * A model tree of the spec</span>
<span class="cm">   *     |</span>
<span class="cm">   *     |  (Parse)</span>
<span class="cm">   *     v</span>
<span class="cm">   * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)</span>
<span class="cm">   *     |</span>
<span class="cm">   *     | (Optimize)</span>
<span class="cm">   *     v</span>
<span class="cm">   * A model tree with parsed components with the data component optimized</span>
<span class="cm">   *     |</span>
<span class="cm">   *     | (Assemble)</span>
<span class="cm">   *     v</span>
<span class="cm">   * Vega spec</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">compile</span><span class="p">(</span><span class="nx">inputSpec</span><span class="p">,</span> <span class="nx">opt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span>
      <span class="c1">// 0. Augment opt with default opts</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">logger</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// set the singleton logger to the provided logger</span>
          <span class="nx">set</span><span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">logger</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">fieldTitle</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// set the singleton field title formatter</span>
          <span class="nx">setTitleFormatter</span><span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">fieldTitle</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">try</span> <span class="p">{</span>
          <span class="c1">// 1. Initialize config by deep merging default config with the config provided via option and the input spec.</span>
          <span class="kd">var</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">initConfig</span><span class="p">(</span><span class="nx">mergeDeep</span><span class="p">({},</span> <span class="nx">opt</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span> <span class="nx">inputSpec</span><span class="p">.</span><span class="nx">config</span><span class="p">));</span>
          <span class="c1">// 2. Normalize: Convert input spec -&gt; normalized spec</span>
          <span class="c1">// - Decompose all extended unit specs into composition of unit spec.  For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.</span>
          <span class="kd">var</span> <span class="nx">spec</span> <span class="o">=</span> <span class="nx">normalize$2</span><span class="p">(</span><span class="nx">inputSpec</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
          <span class="c1">// - Normalize autosize to be a autosize properties object.</span>
          <span class="kd">var</span> <span class="nx">autosize</span> <span class="o">=</span> <span class="nx">normalizeAutoSize</span><span class="p">(</span><span class="nx">inputSpec</span><span class="p">.</span><span class="nx">autosize</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">autosize</span><span class="p">,</span> <span class="nx">isLayerSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="o">||</span> <span class="nx">isUnitSpec</span><span class="p">(</span><span class="nx">spec</span><span class="p">));</span>
          <span class="c1">// 3. Build Model: normalized spec -&gt; Model (a tree structure)</span>
          <span class="c1">// This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.</span>
          <span class="c1">// See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, RepeatModel, ConcatModel) for different types of models.</span>
          <span class="kd">var</span> <span class="nx">model</span> <span class="o">=</span> <span class="nx">buildModel</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">autosize</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;fit&#39;</span><span class="p">);</span>
          <span class="c1">// 4 Parse: Model --&gt; Model with components</span>
          <span class="c1">// Note that components = intermediate representations that are equivalent to Vega specs.</span>
          <span class="c1">// We need these intermediate representation because we need to merge many visualizaiton &quot;components&quot; like projections, scales, axes, and legends.</span>
          <span class="c1">// We will later convert these components into actual Vega specs in the assemble phase.</span>
          <span class="c1">// In this phase, we do a bottom-up traversal over the whole tree to</span>
          <span class="c1">// parse for each type of components once (e.g., data, layout, mark, scale).</span>
          <span class="c1">// By doing bottom-up traversal, we start parsing components of unit specs and</span>
          <span class="c1">// then merge child components of parent composite specs.</span>
          <span class="c1">//</span>
          <span class="c1">// Please see inside model.parse() for order of different components parsed.</span>
          <span class="nx">model</span><span class="p">.</span><span class="nx">parse</span><span class="p">();</span>
          <span class="c1">// 5. Optimize the dataflow.  This will modify the data component of the model.</span>
          <span class="nx">optimizeDataflow</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
          <span class="c1">// 6. Assemble: convert model components --&gt; Vega Spec.</span>
          <span class="k">return</span> <span class="nx">assembleTopLevelModel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">getTopLevelProperties</span><span class="p">(</span><span class="nx">inputSpec</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">autosize</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">finally</span> <span class="p">{</span>
          <span class="c1">// Reset the singleton logger if a logger is provided</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">logger</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">reset</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="c1">// Reset the singleton field title formatter if provided</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">opt</span><span class="p">.</span><span class="nx">fieldTitle</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">resetTitleFormatter</span><span class="p">();</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">getTopLevelProperties</span><span class="p">(</span><span class="nx">topLevelSpec</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">autosize</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nx">autosize</span><span class="o">:</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">autosize</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">autosize</span><span class="p">.</span><span class="nx">type</span> <span class="o">?</span> <span class="nx">autosize</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">autosize</span> <span class="p">},</span> <span class="nx">extractTopLevelProperties</span><span class="p">(</span><span class="nx">config</span><span class="p">),</span> <span class="nx">extractTopLevelProperties</span><span class="p">(</span><span class="nx">topLevelSpec</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="cm">/*</span>
<span class="cm">   * Assemble the top-level model.</span>
<span class="cm">   *</span>
<span class="cm">   * Note: this couldn&#39;t be `model.assemble()` since the top-level model</span>
<span class="cm">   * needs some special treatment to generate top-level properties.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">assembleTopLevelModel</span><span class="p">(</span><span class="nx">model</span><span class="p">,</span> <span class="nx">topLevelProperties</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// TODO: change type to become VgSpec</span>
      <span class="c1">// Config with Vega-Lite only config removed.</span>
      <span class="kd">var</span> <span class="nx">vgConfig</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">config</span> <span class="o">?</span> <span class="nx">stripAndRedirectConfig</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">config</span><span class="p">)</span> <span class="o">:</span> <span class="kc">undefined</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">assembleSelectionData</span><span class="p">([]),</span> 
      <span class="c1">// only assemble data in the root</span>
      <span class="nx">assembleRootData</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">component</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">topLevelProperties</span><span class="p">.</span><span class="nx">datasets</span> <span class="o">||</span> <span class="p">{}));</span>
      <span class="k">delete</span> <span class="nx">topLevelProperties</span><span class="p">.</span><span class="nx">datasets</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">projections</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">assembleProjections</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">title$$1</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">assembleTitle</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">style</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">assembleGroupStyle</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">layoutSignals</span> <span class="o">=</span> <span class="nx">model</span><span class="p">.</span><span class="nx">assembleLayoutSignals</span><span class="p">();</span>
      <span class="c1">// move width and height signals with values to top level</span>
      <span class="nx">layoutSignals</span> <span class="o">=</span> <span class="nx">layoutSignals</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">signal</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">((</span><span class="nx">signal</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s1">&#39;width&#39;</span> <span class="o">||</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s1">&#39;height&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">signal</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">topLevelProperties</span><span class="p">[</span><span class="nx">signal</span><span class="p">.</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="nx">signal</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
              <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">});</span>
      <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">__assign</span><span class="p">({</span> <span class="nv">$schema</span><span class="o">:</span> <span class="s1">&#39;https://vega.github.io/schema/vega/v3.json&#39;</span> <span class="p">},</span> <span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">description</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">description</span><span class="o">:</span> <span class="nx">model</span><span class="p">.</span><span class="nx">description</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">topLevelProperties</span><span class="p">,</span> <span class="p">(</span><span class="nx">title$$1</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="nx">title$$1</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">(</span><span class="nx">style</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">style</span><span class="o">:</span> <span class="nx">style</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="p">{</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">data</span> <span class="p">},</span> <span class="p">(</span><span class="nx">projections</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">projections</span><span class="o">:</span> <span class="nx">projections</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}),</span> <span class="nx">model</span><span class="p">.</span><span class="nx">assembleGroup</span><span class="p">(</span><span class="nx">layoutSignals</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">assembleSelectionTopLevelSignals</span><span class="p">([]))),</span> <span class="p">(</span><span class="nx">vgConfig</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">config</span><span class="o">:</span> <span class="nx">vgConfig</span> <span class="p">}</span> <span class="o">:</span> <span class="p">{}));</span>
      <span class="k">return</span> <span class="p">{</span>
          <span class="nx">spec</span><span class="o">:</span> <span class="nx">output</span>
          <span class="c1">// TODO: add warning / errors here</span>
      <span class="p">};</span>
  <span class="p">}</span>



  <span class="kd">var</span> <span class="nx">facet</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>

  <span class="p">});</span>

  <span class="cm">/**</span>
<span class="cm">   * Required Encoding Channels for each mark type</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">DEFAULT_REQUIRED_CHANNEL_MAP</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">text</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">],</span>
      <span class="nx">line</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
      <span class="nx">trail</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
      <span class="nx">area</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>
  <span class="p">};</span>
  <span class="cm">/**</span>
<span class="cm">   * Supported Encoding Channel for each mark type</span>
<span class="cm">   */</span>
  <span class="kd">var</span> <span class="nx">DEFAULT_SUPPORTED_CHANNEL_TYPE</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">bar</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">]),</span>
      <span class="nx">line</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">]),</span>
      <span class="nx">trail</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">]),</span>
      <span class="nx">area</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">]),</span>
      <span class="nx">tick</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">]),</span>
      <span class="nx">circle</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">]),</span>
      <span class="nx">square</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">]),</span>
      <span class="nx">point</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">]),</span>
      <span class="nx">geoshape</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;detail&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">]),</span>
      <span class="nx">text</span><span class="o">:</span> <span class="nx">toSet</span><span class="p">([</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;stroke&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="c1">// TODO(#724) revise</span>
  <span class="p">};</span>
  <span class="c1">// TODO: consider if we should add validate method and</span>
  <span class="c1">// requires ZSchema in the main vega-lite repo</span>
  <span class="cm">/**</span>
<span class="cm">   * Further check if encoding mapping of a spec is invalid and</span>
<span class="cm">   * return error if it is invalid.</span>
<span class="cm">   *</span>
<span class="cm">   * This checks if</span>
<span class="cm">   * (1) all the required encoding channels for the mark type are specified</span>
<span class="cm">   * (2) all the specified encoding channels are supported by the mark type</span>
<span class="cm">   * @param  {[type]} spec [description]</span>
<span class="cm">   * @param  {RequiredChannelMap = DefaultRequiredChannelMap}  requiredChannelMap</span>
<span class="cm">   * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap</span>
<span class="cm">   * @return {String} Return one reason why the encoding is invalid,</span>
<span class="cm">   *                  or null if the encoding is valid.</span>
<span class="cm">   */</span>
  <span class="kd">function</span> <span class="nx">getEncodingMappingError</span><span class="p">(</span><span class="nx">spec</span><span class="p">,</span> <span class="nx">requiredChannelMap</span><span class="p">,</span> <span class="nx">supportedChannelMap</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">requiredChannelMap</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">requiredChannelMap</span> <span class="o">=</span> <span class="nx">DEFAULT_REQUIRED_CHANNEL_MAP</span><span class="p">;</span> <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">supportedChannelMap</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">supportedChannelMap</span> <span class="o">=</span> <span class="nx">DEFAULT_SUPPORTED_CHANNEL_TYPE</span><span class="p">;</span> <span class="p">}</span>
      <span class="kd">var</span> <span class="nx">mark</span> <span class="o">=</span> <span class="nx">isMarkDef</span><span class="p">(</span><span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">)</span> <span class="o">?</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">.</span><span class="nx">type</span> <span class="o">:</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">mark</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">encoding</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">encoding</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">requiredChannels</span> <span class="o">=</span> <span class="nx">requiredChannelMap</span><span class="p">[</span><span class="nx">mark</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">supportedChannels</span> <span class="o">=</span> <span class="nx">supportedChannelMap</span><span class="p">[</span><span class="nx">mark</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">requiredChannels</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// all required channels are in encoding`</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">requiredChannels</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">in</span> <span class="nx">encoding</span><span class="p">))</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;Missing encoding channel \&quot;&#39;</span> <span class="o">+</span> <span class="nx">requiredChannels</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span>
                  <span class="s1">&#39;\&quot; for mark \&quot;&#39;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s1">&#39;\&quot;&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">channel</span> <span class="k">in</span> <span class="nx">encoding</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// all channels in encoding are supported</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">supportedChannels</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span> <span class="p">{</span>
              <span class="k">return</span> <span class="s1">&#39;Encoding channel \&quot;&#39;</span> <span class="o">+</span> <span class="nx">channel</span> <span class="o">+</span>
                  <span class="s1">&#39;\&quot; is not supported by mark type \&quot;&#39;</span> <span class="o">+</span> <span class="nx">mark</span> <span class="o">+</span> <span class="s1">&#39;\&quot;&#39;</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">mark</span> <span class="o">===</span> <span class="nx">BAR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">encoding</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="s1">&#39;Missing both x and y for bar&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">validate</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
    <span class="nx">DEFAULT_REQUIRED_CHANNEL_MAP</span><span class="o">:</span> <span class="nx">DEFAULT_REQUIRED_CHANNEL_MAP</span><span class="p">,</span>
    <span class="nx">DEFAULT_SUPPORTED_CHANNEL_TYPE</span><span class="o">:</span> <span class="nx">DEFAULT_SUPPORTED_CHANNEL_TYPE</span><span class="p">,</span>
    <span class="nx">getEncodingMappingError</span><span class="o">:</span> <span class="nx">getEncodingMappingError</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">version</span> <span class="o">=</span> <span class="s2">&quot;2.5.0&quot;</span><span class="p">;</span>

  <span class="nx">exports</span><span class="p">.</span><span class="nx">aggregate</span> <span class="o">=</span> <span class="nx">aggregate</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">axis</span> <span class="o">=</span> <span class="nx">axis</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">bin</span> <span class="o">=</span> <span class="nx">bin</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">channel</span> <span class="o">=</span> <span class="nx">channel</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">compositeMark</span> <span class="o">=</span> <span class="nx">index</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">config</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">datetime</span> <span class="o">=</span> <span class="nx">datetime</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">encoding</span> <span class="o">=</span> <span class="nx">encoding</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">facet</span> <span class="o">=</span> <span class="nx">facet</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">fieldDef</span> <span class="o">=</span> <span class="nx">fielddef</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">legend</span> <span class="o">=</span> <span class="nx">legend</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">mark</span> <span class="o">=</span> <span class="nx">mark</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">scale</span> <span class="o">=</span> <span class="nx">scale</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">sort</span> <span class="o">=</span> <span class="nx">sort</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">spec</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="nx">stack$1</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">timeUnit</span> <span class="o">=</span> <span class="nx">timeunit</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="nx">transform</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="nx">type</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">util</span> <span class="o">=</span> <span class="nx">util</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">validate</span> <span class="o">=</span> <span class="nx">validate</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">compile</span> <span class="o">=</span> <span class="nx">compile</span><span class="p">;</span>
  <span class="nx">exports</span><span class="p">.</span><span class="nx">version</span> <span class="o">=</span> <span class="nx">version</span><span class="p">;</span>

  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">exports</span><span class="p">,</span> <span class="s1">&#39;__esModule&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>

<span class="p">})));</span>
<span class="c1">//# sourceMappingURL=vega-lite.js.map</span>
</pre></div>
</body>
</html>
